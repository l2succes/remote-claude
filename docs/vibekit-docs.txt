Directory structure:
â””â”€â”€ superagent-ai-vibekit/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ LLM.md
    â”œâ”€â”€ package.json
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ vitest.config.ts
    â”œâ”€â”€ .env.example
    â”œâ”€â”€ .npmignore
    â”œâ”€â”€ assets/
    â”‚   â””â”€â”€ dockerfiles/
    â”‚       â”œâ”€â”€ Dockerfile.claude
    â”‚       â”œâ”€â”€ Dockerfile.codex
    â”‚       â”œâ”€â”€ Dockerfile.gemini
    â”‚       â”œâ”€â”€ Dockerfile.grok
    â”‚       â”œâ”€â”€ Dockerfile.opencode
    â”‚       â””â”€â”€ Dockerfile.shopify
    â”œâ”€â”€ docs/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ components.json
    â”‚   â”œâ”€â”€ docs.json
    â”‚   â”œâ”€â”€ eslint.config.mjs
    â”‚   â”œâ”€â”€ middleware.ts
    â”‚   â”œâ”€â”€ next-env.d.ts
    â”‚   â”œâ”€â”€ next.config.ts
    â”‚   â”œâ”€â”€ package.json
    â”‚   â”œâ”€â”€ postcss.config.mjs
    â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”œâ”€â”€ agents/
    â”‚   â”‚   â”œâ”€â”€ claude-code.mdx
    â”‚   â”‚   â”œâ”€â”€ codex.mdx
    â”‚   â”‚   â”œâ”€â”€ gemini.mdx
    â”‚   â”‚   â”œâ”€â”€ grok.mdx
    â”‚   â”‚   â””â”€â”€ opencode.mdx
    â”‚   â”œâ”€â”€ api-reference/
    â”‚   â”‚   â”œâ”€â”€ configuration.mdx
    â”‚   â”‚   â”œâ”€â”€ create-pull-request.mdx
    â”‚   â”‚   â”œâ”€â”€ execute-command.mdx
    â”‚   â”‚   â”œâ”€â”€ generate-code.mdx
    â”‚   â”‚   â”œâ”€â”€ get-host.mdx
    â”‚   â”‚   â”œâ”€â”€ get-session.mdx
    â”‚   â”‚   â”œâ”€â”€ kill-sandbox.mdx
    â”‚   â”‚   â”œâ”€â”€ openapi.json
    â”‚   â”‚   â”œâ”€â”€ pause-sandbox.mdx
    â”‚   â”‚   â”œâ”€â”€ push-to-branch.mdx
    â”‚   â”‚   â”œâ”€â”€ resume-sandbox.mdx
    â”‚   â”‚   â”œâ”€â”€ run-tests.mdx
    â”‚   â”‚   â””â”€â”€ set-session.mdx
    â”‚   â”œâ”€â”€ app/
    â”‚   â”‚   â”œâ”€â”€ globals.css
    â”‚   â”‚   â”œâ”€â”€ layout.tsx
    â”‚   â”‚   â”œâ”€â”€ (app)/
    â”‚   â”‚   â”‚   â”œâ”€â”€ client-page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ loading.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ success/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ billing/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client-page.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ profile/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client-page.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ projects/
    â”‚   â”‚   â”‚       â””â”€â”€ [id]/
    â”‚   â”‚   â”‚           â”œâ”€â”€ client-page.tsx
    â”‚   â”‚   â”‚           â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚           â””â”€â”€ [agentId]/
    â”‚   â”‚   â”‚               â”œâ”€â”€ client-page.tsx
    â”‚   â”‚   â”‚               â”œâ”€â”€ loading.tsx
    â”‚   â”‚   â”‚               â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚               â””â”€â”€ _components/
    â”‚   â”‚   â”‚                   â”œâ”€â”€ agent-details.tsx
    â”‚   â”‚   â”‚                   â”œâ”€â”€ appearance.tsx
    â”‚   â”‚   â”‚                   â”œâ”€â”€ mintlify.tsx
    â”‚   â”‚   â”‚                   â”œâ”€â”€ preview.tsx
    â”‚   â”‚   â”‚                   â”œâ”€â”€ prompt.tsx
    â”‚   â”‚   â”‚                   â”œâ”€â”€ sdk.tsx
    â”‚   â”‚   â”‚                   â””â”€â”€ settings.tsx
    â”‚   â”‚   â”œâ”€â”€ (auth)/
    â”‚   â”‚   â”‚   â””â”€â”€ (routes)/
    â”‚   â”‚   â”‚       â”œâ”€â”€ sign-in/
    â”‚   â”‚   â”‚       â”‚   â””â”€â”€ [[...sign-in]]/
    â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ client-page.tsx
    â”‚   â”‚   â”‚       â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ sign-up/
    â”‚   â”‚   â”‚       â”‚   â””â”€â”€ [[...sign-up]]/
    â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ client-page.tsx
    â”‚   â”‚   â”‚       â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚       â””â”€â”€ waitlist/
    â”‚   â”‚   â”‚           â””â”€â”€ page.tsx
    â”‚   â”‚   â”œâ”€â”€ (embed)/
    â”‚   â”‚   â”‚   â””â”€â”€ embed/
    â”‚   â”‚   â”‚       â””â”€â”€ [id]/
    â”‚   â”‚   â”‚           â”œâ”€â”€ client-page.tsx
    â”‚   â”‚   â”‚           â””â”€â”€ page.tsx
    â”‚   â”‚   â”œâ”€â”€ actions/
    â”‚   â”‚   â”‚   â”œâ”€â”€ agent.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ inngest.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ prompt.ts
    â”‚   â”‚   â”‚   â””â”€â”€ waitlist.ts
    â”‚   â”‚   â””â”€â”€ api/
    â”‚   â”‚       â”œâ”€â”€ clerk/
    â”‚   â”‚       â”‚   â””â”€â”€ webhooks/
    â”‚   â”‚       â”‚       â””â”€â”€ route.ts
    â”‚   â”‚       â”œâ”€â”€ embed/
    â”‚   â”‚       â”‚   â””â”€â”€ route.ts
    â”‚   â”‚       â”œâ”€â”€ github/
    â”‚   â”‚       â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ callback/
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ route.ts
    â”‚   â”‚       â”‚   â”‚   â””â”€â”€ url/
    â”‚   â”‚       â”‚   â”‚       â””â”€â”€ route.ts
    â”‚   â”‚       â”‚   â””â”€â”€ repositories/
    â”‚   â”‚       â”‚       â””â”€â”€ route.ts
    â”‚   â”‚       â”œâ”€â”€ inngest/
    â”‚   â”‚       â”‚   â””â”€â”€ route.ts
    â”‚   â”‚       â””â”€â”€ vibekit/
    â”‚   â”‚           â””â”€â”€ route.ts
    â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â”œâ”€â”€ browser.mdx
    â”‚   â”‚   â”œâ”€â”€ index.mdx
    â”‚   â”‚   â”œâ”€â”€ node.mdx
    â”‚   â”‚   â”œâ”€â”€ overview.mdx
    â”‚   â”‚   â””â”€â”€ types.mdx
    â”‚   â”œâ”€â”€ cli/
    â”‚   â”‚   â”œâ”€â”€ agent-support.mdx
    â”‚   â”‚   â”œâ”€â”€ configuration-files.mdx
    â”‚   â”‚   â”œâ”€â”€ environment-variables.mdx
    â”‚   â”‚   â”œâ”€â”€ index.mdx
    â”‚   â”‚   â”œâ”€â”€ installation.mdx
    â”‚   â”‚   â”œâ”€â”€ local-sandbox.mdx
    â”‚   â”‚   â”œâ”€â”€ observability.mdx
    â”‚   â”‚   â”œâ”€â”€ overview.mdx
    â”‚   â”‚   â”œâ”€â”€ proxy-server.mdx
    â”‚   â”‚   â”œâ”€â”€ quick-reference.mdx
    â”‚   â”‚   â””â”€â”€ redaction.mdx
    â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”œâ”€â”€ code-block.tsx
    â”‚   â”‚   â”œâ”€â”€ conditional-layout.tsx
    â”‚   â”‚   â”œâ”€â”€ markdown-editor.tsx
    â”‚   â”‚   â”œâ”€â”€ navbar.tsx
    â”‚   â”‚   â””â”€â”€ ui/
    â”‚   â”‚       â”œâ”€â”€ avatar.tsx
    â”‚   â”‚       â”œâ”€â”€ badge.tsx
    â”‚   â”‚       â”œâ”€â”€ button.tsx
    â”‚   â”‚       â”œâ”€â”€ card.tsx
    â”‚   â”‚       â”œâ”€â”€ color-picker.tsx
    â”‚   â”‚       â”œâ”€â”€ command.tsx
    â”‚   â”‚       â”œâ”€â”€ dialog.tsx
    â”‚   â”‚       â”œâ”€â”€ dropdown-menu.tsx
    â”‚   â”‚       â”œâ”€â”€ file-upload.tsx
    â”‚   â”‚       â”œâ”€â”€ form.tsx
    â”‚   â”‚       â”œâ”€â”€ input-otp.tsx
    â”‚   â”‚       â”œâ”€â”€ input.tsx
    â”‚   â”‚       â”œâ”€â”€ label.tsx
    â”‚   â”‚       â”œâ”€â”€ scroll-area.tsx
    â”‚   â”‚       â”œâ”€â”€ select.tsx
    â”‚   â”‚       â”œâ”€â”€ skeleton.tsx
    â”‚   â”‚       â”œâ”€â”€ sonner.tsx
    â”‚   â”‚       â”œâ”€â”€ switch.tsx
    â”‚   â”‚       â”œâ”€â”€ table.tsx
    â”‚   â”‚       â”œâ”€â”€ tabs.tsx
    â”‚   â”‚       â”œâ”€â”€ text-shimmer.tsx
    â”‚   â”‚       â””â”€â”€ textarea.tsx
    â”‚   â”œâ”€â”€ convex/
    â”‚   â”‚   â”œâ”€â”€ actionLogs.ts
    â”‚   â”‚   â”œâ”€â”€ agents.ts
    â”‚   â”‚   â”œâ”€â”€ organizations.ts
    â”‚   â”‚   â”œâ”€â”€ projects.ts
    â”‚   â”‚   â”œâ”€â”€ schema.ts
    â”‚   â”‚   â”œâ”€â”€ userProfiles.ts
    â”‚   â”‚   â””â”€â”€ _generated/
    â”‚   â”‚       â”œâ”€â”€ api.d.ts
    â”‚   â”‚       â”œâ”€â”€ api.js
    â”‚   â”‚       â”œâ”€â”€ dataModel.d.ts
    â”‚   â”‚       â”œâ”€â”€ server.d.ts
    â”‚   â”‚       â””â”€â”€ server.js
    â”‚   â”œâ”€â”€ hooks/
    â”‚   â”‚   â””â”€â”€ use-github.ts
    â”‚   â”œâ”€â”€ lib/
    â”‚   â”‚   â”œâ”€â”€ clerk.ts
    â”‚   â”‚   â”œâ”€â”€ github.ts
    â”‚   â”‚   â”œâ”€â”€ inngest.ts
    â”‚   â”‚   â”œâ”€â”€ stripe.ts
    â”‚   â”‚   â”œâ”€â”€ utils.ts
    â”‚   â”‚   â””â”€â”€ vibekit.ts
    â”‚   â”œâ”€â”€ providers/
    â”‚   â”‚   â””â”€â”€ convex.tsx
    â”‚   â”œâ”€â”€ proxy/
    â”‚   â”‚   â”œâ”€â”€ anthropic-sdk.mdx
    â”‚   â”‚   â”œâ”€â”€ aws-deployment.mdx
    â”‚   â”‚   â”œâ”€â”€ claude-code.mdx
    â”‚   â”‚   â”œâ”€â”€ configuration.mdx
    â”‚   â”‚   â”œâ”€â”€ cursor-cli.mdx
    â”‚   â”‚   â”œâ”€â”€ deployment.mdx
    â”‚   â”‚   â”œâ”€â”€ gcp-deployment.mdx
    â”‚   â”‚   â”œâ”€â”€ gemini-cli.mdx
    â”‚   â”‚   â”œâ”€â”€ index.mdx
    â”‚   â”‚   â”œâ”€â”€ litellm.mdx
    â”‚   â”‚   â”œâ”€â”€ openai-codex.mdx
    â”‚   â”‚   â”œâ”€â”€ openai-sdk.mdx
    â”‚   â”‚   â”œâ”€â”€ other-frameworks.mdx
    â”‚   â”‚   â”œâ”€â”€ quickstart.mdx
    â”‚   â”‚   â””â”€â”€ vercel-ai-sdk.mdx
    â”‚   â”œâ”€â”€ sdk/
    â”‚   â”‚   â”œâ”€â”€ ask-mode.mdx
    â”‚   â”‚   â”œâ”€â”€ github-integration.mdx
    â”‚   â”‚   â”œâ”€â”€ index.mdx
    â”‚   â”‚   â”œâ”€â”€ quickstart.mdx
    â”‚   â”‚   â”œâ”€â”€ secrets.mdx
    â”‚   â”‚   â”œâ”€â”€ session-management.mdx
    â”‚   â”‚   â””â”€â”€ streaming.mdx
    â”‚   â”œâ”€â”€ snippets/
    â”‚   â”‚   â””â”€â”€ snippet-intro.mdx
    â”‚   â””â”€â”€ supported-sandboxes/
    â”‚       â”œâ”€â”€ cloudflare.mdx
    â”‚       â”œâ”€â”€ dagger.mdx
    â”‚       â”œâ”€â”€ daytona.mdx
    â”‚       â”œâ”€â”€ e2b.mdx
    â”‚       â”œâ”€â”€ flyio.mdx
    â”‚       â”œâ”€â”€ modal.mdx
    â”‚       â””â”€â”€ northflank.mdx
    â”œâ”€â”€ packages/
    â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ tsup.config.ts
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â”œâ”€â”€ browser.ts
    â”‚   â”‚       â”œâ”€â”€ index.ts
    â”‚   â”‚       â”œâ”€â”€ node.ts
    â”‚   â”‚       â”œâ”€â”€ oauth-web.ts
    â”‚   â”‚       â””â”€â”€ oauth.ts
    â”‚   â”œâ”€â”€ cli/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ Dockerfile
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsup.config.ts
    â”‚   â”‚   â”œâ”€â”€ src/
    â”‚   â”‚   â”‚   â”œâ”€â”€ cli.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ agents/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ base.js
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ claude.js
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ codex.js
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ cursor.js
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ gemini.js
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ opencode.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ analytics/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ analytics.js
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ system-info.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ auth-helper-factory.js
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ claude-auth-helper.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ settings.js
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ status-display.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ config/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ config.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ manager.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ logging/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ logger.js
    â”‚   â”‚   â”‚   â”œâ”€â”€ sandbox/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ docker-sandbox.js
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ docker.js
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ sandbox-config.js
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ sandbox-engine.js
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ sandbox-exec.js
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ sandbox-utils.js
    â”‚   â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚   â”‚       â”œâ”€â”€ aliases.js
    â”‚   â”‚   â”‚       â”œâ”€â”€ claude-settings.js
    â”‚   â”‚   â”‚       â””â”€â”€ redaction.js
    â”‚   â”‚   â””â”€â”€ test/
    â”‚   â”‚       â”œâ”€â”€ setup.js
    â”‚   â”‚       â”œâ”€â”€ vitest.config.js
    â”‚   â”‚       â””â”€â”€ sandbox/
    â”‚   â”‚           â””â”€â”€ sandbox-utils.test.js
    â”‚   â”œâ”€â”€ cloudflare/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ Dockerfile
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ index.ts
    â”‚   â”œâ”€â”€ dagger/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ tsup.config.ts
    â”‚   â”‚   â”œâ”€â”€ vitest.config.ts
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â”œâ”€â”€ index.ts
    â”‚   â”‚       â”œâ”€â”€ provider.ts
    â”‚   â”‚       â”œâ”€â”€ dagger/
    â”‚   â”‚       â”‚   â”œâ”€â”€ registry-integration.ts
    â”‚   â”‚       â”‚   â””â”€â”€ vibekit-dagger.ts
    â”‚   â”‚       â”œâ”€â”€ setup/
    â”‚   â”‚       â”‚   â””â”€â”€ installer.ts
    â”‚   â”‚       â””â”€â”€ storage/
    â”‚   â”‚           â””â”€â”€ environment-store.ts
    â”‚   â”œâ”€â”€ dashboard/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ components.json
    â”‚   â”‚   â”œâ”€â”€ eslint.config.mjs
    â”‚   â”‚   â”œâ”€â”€ next-env.d.ts
    â”‚   â”‚   â”œâ”€â”€ next.config.ts
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ postcss.config.mjs
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ .npmignore
    â”‚   â”‚   â”œâ”€â”€ app/
    â”‚   â”‚   â”‚   â”œâ”€â”€ globals.css
    â”‚   â”‚   â”‚   â”œâ”€â”€ layout.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ api/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ analytics/
    â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ route.ts
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ summary/
    â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ route.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ settings/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ settings/
    â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”‚   â”œâ”€â”€ app-sidebar.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ metric-card.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ nav-main.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ nav-projects.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ nav-user.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ team-switcher.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ theme-provider.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ theme-toggle.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ ui/
    â”‚   â”‚   â”‚       â”œâ”€â”€ avatar.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ badge.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ breadcrumb.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ button.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ card.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ dropdown-menu.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ input.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ label.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ separator.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ sheet.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ sidebar.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ skeleton.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ switch.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ table.tsx
    â”‚   â”‚   â”‚       â””â”€â”€ tooltip.tsx
    â”‚   â”‚   â”œâ”€â”€ hooks/
    â”‚   â”‚   â”‚   â”œâ”€â”€ use-mobile.ts
    â”‚   â”‚   â”‚   â””â”€â”€ use-mobile.tsx
    â”‚   â”‚   â”œâ”€â”€ lib/
    â”‚   â”‚   â”‚   â”œâ”€â”€ analytics.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ types.ts
    â”‚   â”‚   â”‚   â””â”€â”€ utils.ts
    â”‚   â”‚   â””â”€â”€ public/
    â”‚   â”‚       â””â”€â”€ opencode.webp
    â”‚   â”œâ”€â”€ daytona/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ index.ts
    â”‚   â”œâ”€â”€ e2b/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ index.ts
    â”‚   â”œâ”€â”€ northflank/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ index.ts
    â”‚   â””â”€â”€ sdk/
    â”‚       â”œâ”€â”€ README.md
    â”‚       â”œâ”€â”€ package.json
    â”‚       â”œâ”€â”€ tsconfig.json
    â”‚       â”œâ”€â”€ tsup.config.ts
    â”‚       â””â”€â”€ src/
    â”‚           â”œâ”€â”€ index.ts
    â”‚           â”œâ”€â”€ types.ts
    â”‚           â”œâ”€â”€ agents/
    â”‚           â”‚   â”œâ”€â”€ base.ts
    â”‚           â”‚   â”œâ”€â”€ claude.ts
    â”‚           â”‚   â”œâ”€â”€ codex.ts
    â”‚           â”‚   â”œâ”€â”€ gemini.ts
    â”‚           â”‚   â”œâ”€â”€ grok.ts
    â”‚           â”‚   â”œâ”€â”€ opencode.ts
    â”‚           â”‚   â””â”€â”€ utils.ts
    â”‚           â”œâ”€â”€ constants/
    â”‚           â”‚   â”œâ”€â”€ agents.ts
    â”‚           â”‚   â”œâ”€â”€ index.ts
    â”‚           â”‚   â””â”€â”€ providers.ts
    â”‚           â”œâ”€â”€ core/
    â”‚           â”‚   â””â”€â”€ vibekit.ts
    â”‚           â”œâ”€â”€ registry/
    â”‚           â”‚   â”œâ”€â”€ aws-ecr.ts
    â”‚           â”‚   â”œâ”€â”€ docker-hub.ts
    â”‚           â”‚   â”œâ”€â”€ github-container-registry.ts
    â”‚           â”‚   â”œâ”€â”€ image-resolver.ts
    â”‚           â”‚   â”œâ”€â”€ index.ts
    â”‚           â”‚   â””â”€â”€ registry-manager.ts
    â”‚           â””â”€â”€ services/
    â”‚               â”œâ”€â”€ config-manager.ts
    â”‚               â”œâ”€â”€ docker-client.ts
    â”‚               â””â”€â”€ index.ts
    â”œâ”€â”€ templates/
    â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ components.json
    â”‚   â”‚   â”œâ”€â”€ eslint.config.mjs
    â”‚   â”‚   â”œâ”€â”€ next.config.ts
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ postcss.config.mjs
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ app/
    â”‚   â”‚   â”‚   â”œâ”€â”€ globals.css
    â”‚   â”‚   â”‚   â”œâ”€â”€ layout.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ actions/
    â”‚   â”‚   â”‚       â””â”€â”€ auth.ts
    â”‚   â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”‚   â””â”€â”€ ui/
    â”‚   â”‚   â”‚       â”œâ”€â”€ accordion.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ alert-dialog.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ alert.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ aspect-ratio.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ avatar.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ badge.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ breadcrumb.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ button.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ calendar.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ card.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ carousel.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ chart.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ checkbox.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ collapsible.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ command.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ context-menu.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ dialog.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ drawer.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ dropdown-menu.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ form.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ hover-card.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ input-otp.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ input.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ label.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ menubar.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ navigation-menu.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ pagination.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ popover.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ progress.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ radio-group.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ resizable.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ scroll-area.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ select.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ separator.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ sheet.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ sidebar.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ skeleton.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ slider.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ sonner.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ switch.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ table.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ tabs.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ textarea.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ toggle-group.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ toggle.tsx
    â”‚   â”‚   â”‚       â””â”€â”€ tooltip.tsx
    â”‚   â”‚   â”œâ”€â”€ hooks/
    â”‚   â”‚   â”‚   â””â”€â”€ use-mobile.ts
    â”‚   â”‚   â””â”€â”€ lib/
    â”‚   â”‚       â””â”€â”€ utils.ts
    â”‚   â”œâ”€â”€ cloudflare/
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ wrangler.jsonc
    â”‚   â”‚   â”œâ”€â”€ .dev.vars.example
    â”‚   â”‚   â”œâ”€â”€ .editorconfig
    â”‚   â”‚   â”œâ”€â”€ .prettierrc
    â”‚   â”‚   â””â”€â”€ src/
    â”‚   â”‚       â””â”€â”€ index.ts
    â”‚   â”œâ”€â”€ codex-clone/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ components.json
    â”‚   â”‚   â”œâ”€â”€ eslint.config.mjs
    â”‚   â”‚   â”œâ”€â”€ next.config.ts
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â”œâ”€â”€ postcss.config.mjs
    â”‚   â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”‚   â”œâ”€â”€ .env.example
    â”‚   â”‚   â”œâ”€â”€ app/
    â”‚   â”‚   â”‚   â”œâ”€â”€ client-page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ container.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ globals.css
    â”‚   â”‚   â”‚   â”œâ”€â”€ layout.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ streaming.css
    â”‚   â”‚   â”‚   â”œâ”€â”€ _components/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ task-form.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ task-list.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ actions/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ inngest.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ vibekit.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ api/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ github/
    â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ branches/
    â”‚   â”‚   â”‚   â”‚   â”‚       â”‚   â””â”€â”€ route.ts
    â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ callback/
    â”‚   â”‚   â”‚   â”‚   â”‚       â”‚   â””â”€â”€ route.ts
    â”‚   â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ repositories/
    â”‚   â”‚   â”‚   â”‚   â”‚       â”‚   â””â”€â”€ route.ts
    â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ url/
    â”‚   â”‚   â”‚   â”‚   â”‚           â””â”€â”€ route.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ inngest/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ route.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ auth/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ success/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ environments/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ client-page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ _components/
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ create-environment-dialog.tsx
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ environments-list.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ task/
    â”‚   â”‚   â”‚       â””â”€â”€ [id]/
    â”‚   â”‚   â”‚           â”œâ”€â”€ client-page.tsx
    â”‚   â”‚   â”‚           â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚           â””â”€â”€ _components/
    â”‚   â”‚   â”‚               â”œâ”€â”€ message-input.tsx
    â”‚   â”‚   â”‚               â””â”€â”€ navbar.tsx
    â”‚   â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”‚   â”œâ”€â”€ markdown.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ navbar.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ streaming-indicator.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ ui/
    â”‚   â”‚   â”‚       â”œâ”€â”€ button.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ dialog.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ scroll-area.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ select.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ separator.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ skeleton.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ table.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ tabs.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ text-shimmer.tsx
    â”‚   â”‚   â”‚       â”œâ”€â”€ theme-toggle.tsx
    â”‚   â”‚   â”‚       â””â”€â”€ tooltip.tsx
    â”‚   â”‚   â”œâ”€â”€ hooks/
    â”‚   â”‚   â”‚   â””â”€â”€ use-github-auth.ts
    â”‚   â”‚   â”œâ”€â”€ lib/
    â”‚   â”‚   â”‚   â”œâ”€â”€ github.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ inngest.ts
    â”‚   â”‚   â”‚   â””â”€â”€ utils.ts
    â”‚   â”‚   â””â”€â”€ stores/
    â”‚   â”‚       â”œâ”€â”€ environments.ts
    â”‚   â”‚       â””â”€â”€ tasks.ts
    â”‚   â””â”€â”€ v0-clone/
    â”‚       â”œâ”€â”€ README.md
    â”‚       â”œâ”€â”€ components.json
    â”‚       â”œâ”€â”€ config.ts
    â”‚       â”œâ”€â”€ eslint.config.mjs
    â”‚       â”œâ”€â”€ middleware.ts
    â”‚       â”œâ”€â”€ next.config.ts
    â”‚       â”œâ”€â”€ package.json
    â”‚       â”œâ”€â”€ postcss.config.mjs
    â”‚       â”œâ”€â”€ tsconfig.json
    â”‚       â”œâ”€â”€ .env.example
    â”‚       â”œâ”€â”€ app/
    â”‚       â”‚   â”œâ”€â”€ client-page.tsx
    â”‚       â”‚   â”œâ”€â”€ globals.css
    â”‚       â”‚   â”œâ”€â”€ layout.tsx
    â”‚       â”‚   â”œâ”€â”€ page.tsx
    â”‚       â”‚   â”œâ”€â”€ actions/
    â”‚       â”‚   â”‚   â”œâ”€â”€ github.ts
    â”‚       â”‚   â”‚   â”œâ”€â”€ inngest.ts
    â”‚       â”‚   â”‚   â”œâ”€â”€ session.ts
    â”‚       â”‚   â”‚   â””â”€â”€ vibekit.ts
    â”‚       â”‚   â”œâ”€â”€ api/
    â”‚       â”‚   â”‚   â”œâ”€â”€ auth/
    â”‚       â”‚   â”‚   â”‚   â””â”€â”€ [...nextauth]/
    â”‚       â”‚   â”‚   â”‚       â””â”€â”€ route.ts
    â”‚       â”‚   â”‚   â”œâ”€â”€ check-url/
    â”‚       â”‚   â”‚   â”‚   â””â”€â”€ route.ts
    â”‚       â”‚   â”‚   â””â”€â”€ inngest/
    â”‚       â”‚   â”‚       â””â”€â”€ route.ts
    â”‚       â”‚   â”œâ”€â”€ session/
    â”‚       â”‚   â”‚   â””â”€â”€ [id]/
    â”‚       â”‚   â”‚       â”œâ”€â”€ client-page.tsx
    â”‚       â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚       â”‚   â””â”€â”€ sessions/
    â”‚       â”‚       â”œâ”€â”€ client-page.tsx
    â”‚       â”‚       â””â”€â”€ page.tsx
    â”‚       â”œâ”€â”€ components/
    â”‚       â”‚   â”œâ”€â”€ booting-machine.tsx
    â”‚       â”‚   â”œâ”€â”€ file-diff.tsx
    â”‚       â”‚   â”œâ”€â”€ login-dialog.tsx
    â”‚       â”‚   â”œâ”€â”€ markdown.tsx
    â”‚       â”‚   â”œâ”€â”€ navbar.tsx
    â”‚       â”‚   â”œâ”€â”€ templates-section.tsx
    â”‚       â”‚   â”œâ”€â”€ chat/
    â”‚       â”‚   â”‚   â”œâ”€â”€ chat-form.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ index.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ message.tsx
    â”‚       â”‚   â”œâ”€â”€ preview/
    â”‚       â”‚   â”‚   â”œâ”€â”€ code.tsx
    â”‚       â”‚   â”‚   â”œâ”€â”€ index.tsx
    â”‚       â”‚   â”‚   â””â”€â”€ toolbar.tsx
    â”‚       â”‚   â””â”€â”€ ui/
    â”‚       â”‚       â”œâ”€â”€ avatar.tsx
    â”‚       â”‚       â”œâ”€â”€ button.tsx
    â”‚       â”‚       â”œâ”€â”€ dialog.tsx
    â”‚       â”‚       â”œâ”€â”€ dropdown-menu.tsx
    â”‚       â”‚       â”œâ”€â”€ form.tsx
    â”‚       â”‚       â”œâ”€â”€ input.tsx
    â”‚       â”‚       â”œâ”€â”€ label.tsx
    â”‚       â”‚       â”œâ”€â”€ scroll-area.tsx
    â”‚       â”‚       â”œâ”€â”€ select.tsx
    â”‚       â”‚       â”œâ”€â”€ separator.tsx
    â”‚       â”‚       â”œâ”€â”€ skeleton.tsx
    â”‚       â”‚       â”œâ”€â”€ table.tsx
    â”‚       â”‚       â”œâ”€â”€ tabs.tsx
    â”‚       â”‚       â”œâ”€â”€ text-shimmer.tsx
    â”‚       â”‚       â””â”€â”€ theme-toggle.tsx
    â”‚       â”œâ”€â”€ convex/
    â”‚       â”‚   â”œâ”€â”€ messages.ts
    â”‚       â”‚   â”œâ”€â”€ schema.ts
    â”‚       â”‚   â”œâ”€â”€ sessions.ts
    â”‚       â”‚   â””â”€â”€ _generated/
    â”‚       â”‚       â”œâ”€â”€ api.d.ts
    â”‚       â”‚       â”œâ”€â”€ api.js
    â”‚       â”‚       â”œâ”€â”€ dataModel.d.ts
    â”‚       â”‚       â”œâ”€â”€ server.d.ts
    â”‚       â”‚       â””â”€â”€ server.js
    â”‚       â”œâ”€â”€ lib/
    â”‚       â”‚   â”œâ”€â”€ auth.ts
    â”‚       â”‚   â”œâ”€â”€ hooks.ts
    â”‚       â”‚   â”œâ”€â”€ inngest.ts
    â”‚       â”‚   â””â”€â”€ utils.ts
    â”‚       â”œâ”€â”€ providers/
    â”‚       â”‚   â”œâ”€â”€ auth-provider.tsx
    â”‚       â”‚   â”œâ”€â”€ convex-provider.tsx
    â”‚       â”‚   â””â”€â”€ theme-provider.tsx
    â”‚       â””â”€â”€ public/
    â”‚           â””â”€â”€ convex.webp
    â”œâ”€â”€ test/
    â”‚   â”œâ”€â”€ claude-oauth-web.test.ts
    â”‚   â”œâ”€â”€ claude-oauth.test.ts
    â”‚   â”œâ”€â”€ claude.test.ts
    â”‚   â”œâ”€â”€ cloudflare.test.ts
    â”‚   â”œâ”€â”€ codex.test.ts
    â”‚   â”œâ”€â”€ dagger.test.ts
    â”‚   â”œâ”€â”€ daytona.test.ts
    â”‚   â”œâ”€â”€ gemini.test.ts
    â”‚   â”œâ”€â”€ grok.test.ts
    â”‚   â”œâ”€â”€ opencode.test.ts
    â”‚   â”œâ”€â”€ setup.ts
    â”‚   â”œâ”€â”€ vibekit-core.test.ts
    â”‚   â”œâ”€â”€ vibekit.test.ts
    â”‚   â””â”€â”€ helpers/
    â”‚       â””â”€â”€ test-utils.ts
    â””â”€â”€ .github/
        â”œâ”€â”€ PULL_REQUEST_TEMPLATE.md
        â”œâ”€â”€ ISSUE_TEMPLATE/
        â”‚   â”œâ”€â”€ bug_report.yml
        â”‚   â””â”€â”€ feature_request.yml
        â””â”€â”€ workflows/
            â”œâ”€â”€ ci.yml
            â”œâ”€â”€ claude-code-review.yml
            â””â”€â”€ claude.yml

================================================
FILE: README.md
================================================
<div align="center">

<img width="700px" src="./assets/vibekit-cli.png" />

# VibeKit is the safety layer for your coding agent ðŸ––

Run Claude Code, Gemini, Codex â€” or any coding agent â€” in a clean, isolated sandbox with sensitive data redaction and observability baked in.

---

[Website](https://vibekit.sh) â€¢ [Docs](https://docs.vibekit.sh) â€¢ [Discord](https://discord.com/invite/mhmJUTjW4b)

---
</div>

## ðŸš€ Quick Start

Install the VibeKit CLI globally:

```bash
npm install -g vibekit
```

Run claude code with enhanced security and tracking

```bash
vibekit claude
```

## âš¡ï¸ Key Features

ðŸ³ **Local sandbox** - Runs agent output in isolated Docker containers â€” zero risk to your local setup

ðŸ”’ **Built-in redaction** - Auto-removes secrets, api keys, and other sensitive data completions

ðŸ“Š **Observability** - Complete visibility into agent operations with real-time logs, traces, and metrics

ðŸŒ **Universal agent support** - Works with Claude Code, Gemini CLI, Grok CLI, Codex CLI, OpenCode, and more

ðŸ’» **Works offline & locally** - No cloud dependencies or internet required â€” works entirely on your machine

## ðŸ“¦ Related Packages

Looking to integrate VibeKit into your application? Check out these packages:

### [ðŸŒ VibeKit Proxy](https://github.com/superagent-ai/vibekit-proxy)
The runtime firewall for AI. Blocks OWASP LLM vulnerabilities in real time (prompt injection, data leaks, insecure outputs).

```bash
# Node
npm i -g vibekit-proxy

# Rust
cargo install vibekit-proxy
```


### [ðŸ“š VibeKit SDK](https://github.com/superagent-ai/vibekit/tree/main/packages/sdk)
Run coding agents in secure sandboxes with full control and monitoring.

```bash
npm install @vibe-kit/sdk
```

Perfect for building applications that need to execute AI-generated code safely.

### [ðŸ” VibeKit Auth](https://github.com/superagent-ai/vibekit/tree/main/packages/auth) 
Use your MAX subscriptions in AI Apps.

```bash
npm install @vibe-kit/auth
```

Handle authentication flows for your VibeKit-powered applications.


## ðŸ¤ Contributing

Contributions welcome! Open an issue, start a discussion, or submit a pull request.

## ðŸ“„ License

MIT â€” see [LICENSE](./LICENSE) for details.

Â© 2025 Superagent Technologies Inc.



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2024 Superagent Technologies Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: LLM.md
================================================
# VibeKit SDK API Documentation

## Overview
VibeKit is a TypeScript SDK for running AI coding agents (Claude, Codex, Gemini, OpenCode) in secure sandboxes with GitHub integration.

**Core Package**: `@vibe-kit/vibekit`  
**Version**: 0.0.43  
**Main Entry**: `dist/index.js`

**Sandbox Providers**:
- `@vibe-kit/e2b` - E2B cloud execution environment
- `@vibe-kit/daytona` - Daytona development platform  
- `@vibe-kit/northflank` - Northflank container platform
- `@vibe-kit/cloudflare` - Cloudflare edge sandboxes (Workers only)

## Installation
```bash
# Core VibeKit package
npm install @vibe-kit/vibekit

# Sandbox providers (choose one or more)
npm install @vibe-kit/e2b        # E2B sandbox provider
npm install @vibe-kit/daytona    # Daytona sandbox provider  
npm install @vibe-kit/northflank # Northflank sandbox provider
npm install @vibe-kit/cloudflare # Cloudflare sandbox provider (Workers only)
```

## Quick Start
```typescript
import { VibeKit } from '@vibe-kit/vibekit';
import { createE2BProvider } from '@vibe-kit/e2b';

// Create sandbox provider
const e2bProvider = createE2BProvider({
  apiKey: 'your-e2b-key',
  templateId: 'vibekit-codex'  // or vibekit-claude, vibekit-gemini, etc.
});

// Create VibeKit instance with builder pattern
const vibekit = new VibeKit()
  .withAgent({
    type: 'codex',
    provider: 'openai',
    apiKey: 'your-openai-key',
    model: 'codex-mini-latest'
  })
  .withSandbox(e2bProvider)
  .withGithub({
    token: 'your-github-token',
    repository: 'owner/repo'
  });

// Set up event listeners
vibekit.on('update', (message) => {
  console.log('Update:', message);
});

vibekit.on('error', (error) => {
  console.error('Error:', error);
});

// Generate code
const result = await vibekit.generateCode(
  'Add error handling to login function',
  'code'  // mode: 'code' or 'ask'
);

// Clean up
await vibekit.kill();
```









## Usage Examples

### Basic Code Generation
```typescript
import { VibeKit } from '@vibe-kit/vibekit';
import { createE2BProvider } from '@vibe-kit/e2b';

// Create sandbox provider
const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY,
  templateId: 'vibekit-claude'
});

// Create VibeKit instance
const vibekit = new VibeKit()
  .withAgent({
    type: 'claude',
    provider: 'anthropic',
    apiKey: process.env.ANTHROPIC_API_KEY,
    model: 'claude-sonnet-4-20250514'
  })
  .withSandbox(e2bProvider)
  .withGithub({
    token: process.env.GITHUB_TOKEN,
    repository: 'owner/repo'
  })
  .withWorkingDirectory('/var/vibe0');

// Set up event listeners
vibekit.on('update', (msg) => console.log('Progress:', msg));
vibekit.on('error', (err) => console.error('Error:', err));

// Generate code
const result = await vibekit.generateCode(
  'Add input validation to the user registration form',
  'code'  // mode: 'code' or 'ask'
);

if (result.exitCode === 0) {
  const pr = await vibekit.createPullRequest({
    name: 'enhancement',
    color: '0075ca',
    description: 'New feature or request'
  });
  console.log('PR created:', pr.html_url);
}

// Clean up
await vibekit.kill();
```

### Different Sandbox Providers
```typescript
import { VibeKit } from '@vibe-kit/vibekit';
import { createE2BProvider } from '@vibe-kit/e2b';
import { createDaytonaProvider } from '@vibe-kit/daytona';
import { createNorthflankProvider } from '@vibe-kit/northflank';
import { createCloudflareProvider } from '@vibe-kit/cloudflare';

// Using E2B
const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY,
  templateId: 'vibekit-codex'
});

// Using Daytona
const daytonaProvider = createDaytonaProvider({
  apiKey: process.env.DAYTONA_API_KEY,
  serverUrl: process.env.DAYTONA_SERVER_URL
});

// Using Northflank
const northflankProvider = createNorthflankProvider({
  apiKey: process.env.NORTHFLANK_API_KEY,
  projectId: process.env.NORTHFLANK_PROJECT_ID
});

// Using Cloudflare (Workers only)
const cloudflareProvider = createCloudflareProvider({
  env: env, // Worker env object with Sandbox binding
  hostname: "your-worker.domain.workers.dev"
});

// Create VibeKit with any provider
const vibekit = new VibeKit()
  .withAgent({
    type: 'codex',
    provider: 'openai',
    apiKey: process.env.OPENAI_API_KEY,
    model: 'codex-mini-latest'
  })
  .withSandbox(e2bProvider) // or daytonaProvider, northflankProvider, cloudflareProvider
  .withGithub({
    token: process.env.GITHUB_TOKEN,
    repository: 'owner/repo'
  });

const response = await vibekit.generateCode(
  'Refactor the authentication middleware',
  'code'
);

await vibekit.kill();
```

### Different Agent Types
```typescript
import { VibeKit } from '@vibe-kit/vibekit';
import { createE2BProvider } from '@vibe-kit/e2b';

const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY,
  templateId: 'vibekit-claude'  // Use appropriate template for each agent
});

// Claude Agent
const claudeVibekit = new VibeKit()
  .withAgent({
    type: 'claude',
    provider: 'anthropic',
    apiKey: process.env.ANTHROPIC_API_KEY,
    model: 'claude-sonnet-4-20250514'
  })
  .withSandbox(e2bProvider);

// Codex Agent
const codexVibekit = new VibeKit()
  .withAgent({
    type: 'codex',
    provider: 'openai',
    apiKey: process.env.OPENAI_API_KEY,
    model: 'codex-mini-latest'
  })
  .withSandbox(e2bProvider);

// Gemini Agent
const geminiVibekit = new VibeKit()
  .withAgent({
    type: 'gemini',
    provider: 'google',
    apiKey: process.env.GEMINI_API_KEY,
    model: 'gemini-2.5-pro'
  })
  .withSandbox(e2bProvider);

// OpenCode Agent
const opencodeVibekit = new VibeKit()
  .withAgent({
    type: 'opencode',
    provider: 'anthropic',
    apiKey: process.env.ANTHROPIC_API_KEY,
    model: 'claude-sonnet-4-20250514'
  })
  .withSandbox(e2bProvider);

// Set up streaming
claudeVibekit.on('update', (message) => {
  console.log('Claude update:', message);
});

const result = await claudeVibekit.generateCode(
  'Add rate limiting to the authentication function',
  'code'
);

await claudeVibekit.kill();
```

### Sandbox Management
```typescript
import { VibeKit } from '@vibe-kit/vibekit';
import { createE2BProvider } from '@vibe-kit/e2b';

const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY,
  templateId: 'vibekit-claude'
});

const vibekit = new VibeKit()
  .withAgent({
    type: 'claude',
    provider: 'anthropic',
    apiKey: process.env.ANTHROPIC_API_KEY,
    model: 'claude-sonnet-4-20250514'
  })
  .withSandbox(e2bProvider)
  .withSecrets({ 
    MY_SECRET: 'secret-value',
    DATABASE_URL: 'postgres://...'
  });

// Set up command output streaming
vibekit.on('update', console.log);

// Execute custom commands
const cmdResult = await vibekit.executeCommand('npm test');

// Get sandbox host for port forwarding
const host = await vibekit.getHost(3000);
console.log('App running at:', host);

// Pause/resume for cost optimization
await vibekit.pause();
// ... later
await vibekit.resume();

// Clean up
await vibekit.kill();
```

### Cloudflare Workers Integration (Complete Setup)

**IMPORTANT**: Cloudflare sandboxes ONLY work within Cloudflare Workers - they cannot be used in regular Node.js applications, serverless functions, or any other environment.

#### 1. Required Project Structure
```
my-vibekit-worker/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ index.ts          # Your Worker code
â”œâ”€â”€ wrangler.json         # Cloudflare configuration
â”œâ”€â”€ package.json
â””â”€â”€ node_modules/
    â””â”€â”€ @cloudflare/
        â””â”€â”€ sandbox/
            â””â”€â”€ Dockerfile  # Container configuration
```

#### 2. wrangler.json Configuration
```jsonc
{
  "name": "my-vibekit-worker",
  "main": "src/index.ts",
  "compatibility_date": "2024-01-01",
  "containers": [
    {
      "class_name": "Sandbox",
      "image": "./node_modules/@cloudflare/sandbox/Dockerfile",
      "max_instances": 1
    }
  ],
  "durable_objects": {
    "bindings": [
      {
        "class_name": "Sandbox", 
        "name": "Sandbox"
      }
    ]
  },
  "migrations": [
    {
      "new_sqlite_classes": ["Sandbox"],
      "tag": "v1"
    }
  ],
  "vars": {
    "ANTHROPIC_API_KEY": "your-key-here"
  }
}
```

#### 3. Complete Worker Implementation
```typescript
import { VibeKit } from '@vibe-kit/vibekit';
import { createCloudflareProvider, proxyToSandbox } from '@vibe-kit/cloudflare';

// REQUIRED: Export Sandbox class for Durable Objects
export { Sandbox } from "@cloudflare/sandbox";

interface Env {
  ANTHROPIC_API_KEY: string;
  OPENAI_API_KEY?: string;
  GITHUB_TOKEN?: string;
  Sandbox: DurableObjectNamespace; // The Durable Object binding
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    
    // REQUIRED: Handle preview URL routing for sandbox services
    const proxyResponse = await proxyToSandbox(request, env);
    if (proxyResponse) return proxyResponse;

    // Handle VibeKit requests
    if (url.pathname === '/vibekit' || url.pathname.startsWith('/api/')) {
      try {
        // Create Cloudflare provider - MUST be inside Worker
        const provider = createCloudflareProvider({
          env: env, // Worker env with Sandbox binding
          hostname: request.headers.get("host") || "localhost"
        });

        // Create VibeKit instance
        const vibekit = new VibeKit()
          .withAgent({
            type: 'claude',
            provider: 'anthropic', 
            apiKey: env.ANTHROPIC_API_KEY,
            model: 'claude-sonnet-4-20250514'
          })
          .withSandbox(provider)
          .withGithub({
            token: env.GITHUB_TOKEN,
            repository: 'your-org/your-repo'
          });

        // Handle different endpoints
        if (url.pathname === '/vibekit/generate') {
          const body = await request.json() as { prompt: string; mode: string };
          
          const result = await vibekit.generateCode({
            prompt: body.prompt,
            mode: body.mode as 'code' | 'ask'
          });

          return new Response(JSON.stringify(result), {
            headers: { 'Content-Type': 'application/json' }
          });
        }

        if (url.pathname === '/vibekit/host') {
          const body = await request.json() as { port: number };
          const host = await vibekit.getHost(body.port);
          
          return new Response(JSON.stringify({ url: host }), {
            headers: { 'Content-Type': 'application/json' }
          });
        }

        return new Response('VibeKit Worker ready', { status: 200 });

      } catch (error) {
        return new Response(JSON.stringify({ 
          error: error.message 
        }), { 
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        });
      }
    }

    return new Response('Not found', { status: 404 });
  }
};
```

#### 4. Preview URLs and Service Exposure

When your sandbox creates a service (like a web server), Cloudflare automatically generates preview URLs:

```typescript
// In your VibeKit code generation:
const result = await vibekit.generateCode({
  prompt: "Create a Node.js web server on port 3000",
  mode: "code"
});

// Get the preview URL
const previewUrl = await vibekit.getHost(3000);
// Returns: https://3000-sandbox-id.your-worker.domain.workers.dev

// This URL is automatically routed by proxyToSandbox()
```

#### 5. Local Development Port Configuration

For local development with `wrangler dev`, only ports explicitly exposed in the Dockerfile are available for port forwarding. This is not an issue in production.

To test multiple ports locally, create a custom Dockerfile:

```dockerfile
FROM docker.io/cloudflare/sandbox:0.1.3

EXPOSE 3000
EXPOSE 8080
EXPOSE 3001

# Always end with the same command as the base image
CMD ["bun", "index.ts"]
```

Then update your wrangler.json to use the custom Dockerfile:

```jsonc
{
  "containers": [
    {
      "class_name": "Sandbox",
      "image": "./Dockerfile",  // Point to your custom Dockerfile
      "max_instances": 1
    }
  ]
}
```

#### 6. Deployment Commands
```bash
# Install dependencies
npm install @vibe-kit/vibekit @vibe-kit/cloudflare

# Deploy to Cloudflare
wrangler deploy

# For local development
wrangler dev
```

#### 7. Environment Variables in Worker
Set these in wrangler.json `vars` section or via Cloudflare dashboard:
```jsonc
{
  "vars": {
    "ANTHROPIC_API_KEY": "your-anthropic-key",
    "OPENAI_API_KEY": "your-openai-key", 
    "GITHUB_TOKEN": "your-github-token"
  }
}
```

#### 8. Key Differences from Other Providers

- **Worker-Only**: Cannot run outside Cloudflare Workers
- **No API Keys**: Uses Durable Object bindings instead of API keys
- **Automatic Preview URLs**: Services are automatically exposed with public URLs
- **Edge Distribution**: Sandboxes run on Cloudflare's global edge network
- **Container Platform**: Built on Cloudflare's container technology
- **Routing Required**: Must implement proxyToSandbox for preview URLs
- **Export Required**: Must export the Sandbox class from your Worker

#### 9. Troubleshooting

**"Sandbox binding not found"**: Ensure your wrangler.json has proper Durable Object configuration and you're passing the correct `env` object.

**Preview URLs not working**: Make sure you're calling `proxyToSandbox()` at the beginning of your fetch handler.

**Container errors**: The Dockerfile is provided by @cloudflare/sandbox package - don't create your own unless customizing.

## Supported Sandbox Runtimes

- **E2B**: Cloud-based code execution environment
- **Daytona**: Development environment platform
- **Northflank**: Container-based sandbox platform
- **Cloudflare**: Edge-native sandboxes on Cloudflare Workers (Workers only)

## Error Handling

All methods return promises that may reject. Always wrap in try-catch:

```typescript
try {
  const result = await vibekit.generateCode('...', 'code');
  if (result.exitCode !== 0) {
    console.error('Command failed:', result.stderr);
  }
} catch (error) {
  console.error('SDK error:', error.message);
} finally {
  // Always clean up
  await vibekit.kill();
}
```

## Environment Variables

Common environment variables:
- `OPENAI_API_KEY` - OpenAI API key
- `ANTHROPIC_API_KEY` - Anthropic API key
- `GOOGLE_API_KEY` - Google API key
- `E2B_API_KEY` - E2B sandbox API key
- `DAYTONA_API_KEY` - Daytona API key
- `NORTHFLANK_API_KEY` - Northflank API key
- `GITHUB_TOKEN` - GitHub personal access token

**Note**: Cloudflare sandboxes don't require separate API keys - they use your Worker's environment and Durable Object bindings.

## TypeScript Support

Fully typed with TypeScript definitions included. Import types:

```typescript
import type {
  VibeKit,
  AgentResponse,
  AgentType,
  ModelProvider
} from '@vibe-kit/vibekit';

import type {
  E2BConfig
} from '@vibe-kit/e2b';

import type {
  DaytonaConfig
} from '@vibe-kit/daytona';

import type {
  NorthflankConfig
} from '@vibe-kit/northflank';

import type {
  CloudflareConfig
} from '@vibe-kit/cloudflare';
```



================================================
FILE: package.json
================================================
{
    "name": "vibekit-workspace",
    "private": true,
    "type": "module",
    "version": "1.0.0",
    "bin": {
        "vibekit": "./packages/cli/dist/cli.js"
    },
    "engines": {
        "node": ">=18.0.0"
    },
    "workspaces": [
        "packages/*"
    ],
    "scripts": {
        "build": "npm run build --workspaces",
        "build:packages": "npm run build --workspace=packages/e2b && npm run build --workspace=packages/daytona && npm run build --workspace=packages/northflank && npm run build --workspace=packages/cloudflare && npm run build --workspace=packages/dagger && npm run build --workspace=packages/auth && npm run build --workspace=packages/sdk && npm run build --workspace=packages/cli",
        "dev": "npm run dev --workspace=packages/sdk",
        "type-check": "npm run build --workspace=packages/sdk && npm run build:types --workspace=packages/dagger && npm run type-check --workspaces",
        "test": "vitest"
    },
    "devDependencies": {
        "@types/node": "^22.15.18",
        "@vitest/coverage-v8": "^3.1.3",
        "@vitest/ui": "^3.1.3",
        "tsup": "^8.4.0",
        "typescript": "^5.8.3",
        "vitest": "^3.1.3"
    },
    "dependencies": {
        "dotenv": "^17.2.0"
    }
}



================================================
FILE: tsconfig.json
================================================
{
    "compilerOptions": {
      "target": "ES2022",
      "module": "ESNext",
      "moduleResolution": "Bundler",
      "declaration": true,
      "outDir": "dist",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true
    },
    "include": ["packages/sdk", "test/codex.test.ts"]
  }
  


================================================
FILE: vitest.config.ts
================================================
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    setupFiles: ["./test/setup.ts"],
    env: {
      // Ensure environment variables are loaded
      dotenv: '.env'
    }
  },
});


================================================
FILE: .env.example
================================================
# VibeKit Environment Configuration
# Copy this file to .env and fill in your actual values

# ===================================================================
# AI Agent API Keys (at least one required)
# ===================================================================

# OpenAI API Key (for Codex agent)
OPENAI_API_KEY=sk-...
OPENAI_MODEL=gpt-4o

# Anthropic API Key (for Claude agent)
ANTHROPIC_API_KEY=sk-ant-...
ANTHROPIC_MODEL=claude-3-5-sonnet-20241022

# Google API Key (for Gemini agent)
GOOGLE_API_KEY=...
GOOGLE_MODEL=gemini-1.5-pro

# Groq API Key (for OpenCode agent)
GROQ_API_KEY=gsk_...
GROQ_MODEL=llama-3.1-70b-versatile

# ===================================================================
# GitHub Integration (optional, required for PR creation)
# ===================================================================

# GitHub Personal Access Token
GITHUB_TOKEN=ghp_...

# Default repository for PR operations (format: owner/repo)
GITHUB_REPOSITORY=your-username/your-repo

# ===================================================================
# Default Agent Configuration
# ===================================================================

# Default agent to use when none specified
VIBEKIT_DEFAULT_AGENT=claude

# Default model (overrides agent-specific defaults)
VIBEKIT_DEFAULT_MODEL=claude-3-5-sonnet-20241022

# Default timeout for operations (milliseconds)
VIBEKIT_DEFAULT_TIMEOUT=30000

# Default working directory in sandboxes
VIBEKIT_DEFAULT_WORKING_DIR=/vibe0

# ===================================================================
# Docker Configuration
# ===================================================================

# Docker registry to use
DOCKER_REGISTRY=docker.io

# Your Docker Hub username (for image uploads)
DOCKER_USERNAME=your-username

# Prefer registry images over local builds
VIBEKIT_PREFER_REGISTRY_IMAGES=true

# ===================================================================
# Local Provider Settings
# ===================================================================

# Directory for VibeKit data storage
VIBEKIT_STORAGE_PATH=~/.vibekit

# Log level (debug, info, warn, error)
VIBEKIT_LOG_LEVEL=info

# Maximum number of concurrent environments
VIBEKIT_MAX_ENVIRONMENTS=10

# ===================================================================
# Telemetry Configuration (optional)
# ===================================================================

# Enable telemetry tracking
VIBEKIT_TELEMETRY_ENABLED=false

# OpenTelemetry endpoint for sending telemetry data
VIBEKIT_TELEMETRY_ENDPOINT=https://your-telemetry-endpoint.com/v1/traces

# Service name for telemetry identification
VIBEKIT_TELEMETRY_SERVICE_NAME=vibekit-cli

# Service version for telemetry
VIBEKIT_TELEMETRY_SERVICE_VERSION=1.0.0

# Custom headers for telemetry requests (JSON format)
VIBEKIT_TELEMETRY_HEADERS={"Authorization": "Bearer your-token"}

# Telemetry request timeout (milliseconds)
VIBEKIT_TELEMETRY_TIMEOUT=5000

# Sampling ratio (0.0 to 1.0) - 1.0 means 100% sampling
VIBEKIT_TELEMETRY_SAMPLING_RATIO=1.0

# Session ID for telemetry correlation (auto-generated if not provided)
VIBEKIT_TELEMETRY_SESSION_ID=

# ===================================================================
# Development Settings
# ===================================================================

# Enable debug logging for troubleshooting
DEBUG=vibekit:*

# Node environment
NODE_ENV=development



================================================
FILE: .npmignore
================================================
src/
test/
coverage/
.github/
*.ts
!dist/**/*.ts
tsconfig.json
test-*.ts
.env*

# Exclude template node_modules and build artifacts
templates/*/node_modules/
templates/*/.next/
templates/*/dist/
templates/*/build/
templates/*/.turbo/
templates/*/coverage/

# Exclude package node_modules and build artifacts (except necessary ones)
packages/*/node_modules/
packages/*/.next/
packages/*/dist/
packages/*/build/
packages/*/.turbo/
packages/*/coverage/

# Exclude CLI dashboard build artifacts
packages/cli/src/dashboard/node_modules/
packages/cli/src/dashboard/.next/
packages/cli/src/dashboard/dist/
packages/cli/src/dashboard/build/


================================================
FILE: assets/dockerfiles/Dockerfile.claude
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git ripgrep

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install Claude Code globalliy
RUN npm install -g @anthropic-ai/claude-code@latest


================================================
FILE: assets/dockerfiles/Dockerfile.codex
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install OpenAI Codex globally
RUN npm install -g @openai/codex@latest


================================================
FILE: assets/dockerfiles/Dockerfile.gemini
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install OpenAI Codex globally
RUN npm install -g @google/gemini-cli


================================================
FILE: assets/dockerfiles/Dockerfile.grok
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install OpenAI Codex globally
RUN npm install -g @vibe-kit/grok-cli@latest


================================================
FILE: assets/dockerfiles/Dockerfile.opencode
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install OpenAI Codex globally
RUN npm install -g opencode-ai@latest


================================================
FILE: assets/dockerfiles/Dockerfile.shopify
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install system dependencies and Node.js
RUN apt-get update && apt-get install -y \
    curl \
    git \
    ripgrep \
    ca-certificates \
    gnupg \
    && curl -fsSL https://deb.nodesource.com/setup_20.x | bash - \
    && apt-get install -y nodejs \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Install Node.js packages globally
RUN npm install -g \
    @anthropic-ai/claude-code@latest \
    @shopify/cli@latest \
    && npm cache clean --force

# Verify installations
RUN node -v && npm -v && git --version


================================================
FILE: docs/README.md
================================================
# Mintlify Starter Kit

Click on `Use this template` to copy the Mintlify starter kit. The starter kit contains examples including

- Guide pages
- Navigation
- Customizations
- API Reference pages
- Use of popular components

### Development

Install the [Mintlify CLI](https://www.npmjs.com/package/mintlify) to preview the documentation changes locally. To install, use the following command

```
npm i -g mintlify
```

Run the following command at the root of your documentation (where docs.json is)

```
mintlify dev
```

### Publishing Changes

Install our Github App to auto propagate changes from your repo to your deployment. Changes will be deployed to production automatically after pushing to the default branch. Find the link to install on your dashboard. 

#### Troubleshooting

- Mintlify dev isn't running - Run `mintlify install` it'll re-install dependencies.
- Page loads as a 404 - Make sure you are running in a folder with `docs.json`



================================================
FILE: docs/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: docs/docs.json
================================================
{
  "$schema": "https://mintlify.com/docs.json",
  "theme": "mint",
  "name": "VibeKit",
  "colors": {
    "primary": "#000000",
    "light": "#FFFFFF",
    "dark": "#000000"
  },
  "styling": {
    "eyebrows": "breadcrumbs",
    "codeblocks": "dark"
  },
  "background": {
    "color": {
      "light": "#FAFAFA",
      "dark": "#000"
    }
  },
  "appearance": {
    "default": "dark",
    "strict": false
  },
  "icons": {
    "library": "lucide"
  },
  "favicon": "/favicon.png",
  "navigation": {
    "tabs": [
      {
        "tab": "Proxy",
        "groups": [
          {
            "group": "Getting Started",
            "pages": [
              "proxy/index",
              "proxy/quickstart",
              "proxy/configuration"
            ]
          },
          {
            "group": "Supported frameworks",
            "pages": [
              "proxy/anthropic-sdk",
              "proxy/claude-code",
              "proxy/cursor-cli",
              "proxy/gemini-cli",
              "proxy/litellm",
              "proxy/openai-codex",
              "proxy/openai-sdk",
              "proxy/other-frameworks",
              "proxy/vercel-ai-sdk"
            ]
          },
          {
            "group": "Deployment",
            "pages": [
              "proxy/deployment",
              "proxy/aws-deployment",
              "proxy/gcp-deployment"
            ]
          }
        ]
      },
      {
        "tab": "CLI",
        "groups": [
          {
            "group": "Getting Started",
            "pages": [
              "cli/index",
              "cli/installation",
              "cli/quick-reference"
            ]
          },
          {
            "group": "Core Features",
            "pages": [
              "cli/local-sandbox",
              "cli/proxy-server",
              "cli/redaction",
              "cli/observability",
              "cli/agent-support"
            ]
          },
          {
            "group": "Configuration",
            "pages": [
              "cli/configuration-files",
              "cli/environment-variables"
            ]
          }
        ]
      },
      {
        "tab": "SDK",
        "groups": [
          {
            "group": "Get Started",
            "pages": [
              "sdk/index",
              "sdk/quickstart",
              "sdk/ask-mode",
              "sdk/github-integration",
              "sdk/streaming",
              "sdk/session-management",
              "sdk/secrets"
            ]
          },
          {
            "group": "Agents",
            "pages": [
              "agents/codex",
              "agents/claude-code",
              "agents/gemini",
              "agents/grok",
              "agents/opencode"
            ]
          },
          {
            "group": "Supported Sandboxes",
            "pages": [
              "supported-sandboxes/dagger",
              "supported-sandboxes/cloudflare",
              "supported-sandboxes/daytona",
              "supported-sandboxes/e2b",
              "supported-sandboxes/flyio",
              "supported-sandboxes/modal",
              "supported-sandboxes/northflank"
            ]
          },
          {
            "group": "SDK Reference",
            "pages": [
              "api-reference/configuration",
              "api-reference/generate-code",
              "api-reference/execute-command",
              "api-reference/create-pull-request",
              "api-reference/push-to-branch",
              "api-reference/run-tests",
              "api-reference/kill-sandbox",
              "api-reference/get-host",
              "api-reference/pause-sandbox",
              "api-reference/resume-sandbox",
              "api-reference/get-session",
              "api-reference/set-session"
            ]
          }
        ]
      },
      {
        "tab": "Auth",
        "groups": [
          {
            "group": "Getting Started",
            "pages": [
              "auth/index",
              "auth/overview"
            ]
          },
          {
            "group": "Usage",
            "pages": [
              "auth/node",
              "auth/browser"
            ]
          },
          {
            "group": "Reference",
            "pages": [
              "auth/types"
            ]
          }
        ]
      }
    ],
    "global": {
      "anchors": [
        {
          "anchor": "GitHub",
          "href": "https://github.com/superagent-ai/vibekit",
          "icon": "github"
        },
        {
          "anchor": "Community",
          "href": "https://discord.gg/spZ7MnqFT4",
          "icon": "discord"
        },
        {
          "anchor": "Website",
          "href": "https://vibekit.sh",
          "icon": "globe"
        }
      ]
    }
  },
  "logo": {
    "light": "/logo/light.png",
    "dark": "/logo/dark.png"
  },
  "navbar": {
    "links": [
      {
        "label": "Support",
        "href": "mailto:ismail@superagent.sh"
      }
    ],
    "primary": {
      "type": "button",
      "label": "GitHub",
      "href": "https://github.com/superagent-ai/vibekit"
    }
  },
  "footer": {
    "socials": {
      "x": "https://x.com/superagent_ai",
      "github": "https://github.com/superagent-ai/vibekit",
      "linkedin": "https://www.linkedin.com/company/superagent-sh"
    }
  }
}


================================================
FILE: docs/eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;



================================================
FILE: docs/middleware.ts
================================================
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";

const isProtectedRoute = createRouteMatcher([
  "/",
  "/(projects|profile|billing)(.*)",
]);
const isSignInRoute = createRouteMatcher(["/sign-in"]);

export default clerkMiddleware(async (auth, req) => {
  const { userId } = await auth();
  if (isProtectedRoute(req)) await auth.protect();

  if (isSignInRoute(req) && userId) {
    return NextResponse.redirect(new URL("/", req.url));
  }
});

export const config = {
  matcher: [
    "/((?!.*\\..*|_next).*)",
    "/",
    "/.redwood(.*)",
    "/.netlify(.*)",
    "/(api|trpc)(.*)",
  ],
};



================================================
FILE: docs/next-env.d.ts
================================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.



================================================
FILE: docs/next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  experimental: {
    turbo: {
      resolveExtensions: [
        ".mdx",
        ".tsx",
        ".ts",
        ".jsx",
        ".js",
        ".mjs",
        ".json",
      ],
    },
  },
  devIndicators: false,
};

export default nextConfig;



================================================
FILE: docs/package.json
================================================
{
  "name": "vibekit-onboard",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.3.22",
    "@clerk/nextjs": "^6.21.0",
    "@hookform/resolvers": "^5.1.1",
    "@hugeicons/react": "^1.0.5",
    "@inngest/realtime": "^0.3.1",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-tabs": "^1.1.12",
    "@tanstack/react-table": "^8.21.3",
    "@vibe-kit/sdk": "^0.0.24",
    "ai": "^4.3.16",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "convex": "^1.24.8",
    "date-fns": "^4.1.0",
    "framer-motion": "^12.18.1",
    "inngest": "^3.39.2",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.514.0",
    "next": "15.3.3",
    "next-themes": "^0.4.6",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-dropzone": "^14.3.8",
    "react-hook-form": "^7.57.0",
    "react-icons": "^5.5.0",
    "shiki": "^3.6.0",
    "sonner": "^2.0.5",
    "stripe": "^18.2.1",
    "tailwind-merge": "^3.3.1",
    "usehooks-ts": "^3.1.1",
    "word-count": "^0.3.1",
    "zod": "^3.25.58"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.3",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.4",
    "typescript": "^5"
  }
}



================================================
FILE: docs/postcss.config.mjs
================================================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;



================================================
FILE: docs/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: docs/agents/claude-code.mdx
================================================
---
title: 'Claude Code'
description: 'Run Claude Code in a secure and private sandbox'
---

<img
  width="100%"
  height="415"
  src="https://cdn.prod.website-files.com/67ce28cfec624e2b733f8a52/6826a6227b1fbd47034d1936_claude-code.webp"
  alt="Claude Code"
></img>



## How it works

VibeKit runs Anthropic's Claude Code in headless mode, with the `--dangerously-skip-permissions` flag enabled. This means that the agent will automatically create, edit and delete files if it's in `code` mode.

The Claude Code CLI runs in the configured environment and has access to the network, which means it could be used to connect to the outside world. This is a powerful feature that can be used to build powerful applications and should be used with caution.

[Read more about Claude Code](https://docs.anthropic.com/en/docs/claude-code/overview)

## Authentication

Claude Code agent supports OAuth and API key authentication. Authentication is now handled by the separate `@vibe-kit/auth` package.

### Installation

```bash
# Install both packages
npm install @vibe-kit/sdk @vibe-kit/auth
```

### 1. OAuth Token Authentication (Recommended)

Authenticate with your Claude Pro/Max account for better rate limits.

> **Security Note**: OAuth tokens are stored locally at `~/.vibekit/claude-oauth-token.json` with restricted permissions (600). For production environments, consider using environment variables or a secrets manager.

#### Using OAuth in Code

Get an OAuth token and pass it as the API key:

```typescript
import { VibeKit } from '@vibe-kit/sdk';
import { ClaudeAuth } from '@vibe-kit/auth';

// Get OAuth token
const accessToken = await ClaudeAuth.getValidToken();
if (!accessToken) {
  await ClaudeAuth.authenticate();
  accessToken = await ClaudeAuth.getValidToken();
}

// Use token with VibeKit
const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    providerApiKey: accessToken, // Pass OAuth token as API key
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(sandboxProvider);
```

#### Using OAuth Token via Environment Variable

You can also provide the OAuth token directly via environment variable:

```typescript
import { ClaudeAuth } from '@vibe-kit/auth';

// Import token from environment
await ClaudeAuth.importToken({ fromEnv: true });
const accessToken = await ClaudeAuth.getValidToken();

// Use with VibeKit
const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    providerApiKey: accessToken,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(sandboxProvider);
```

#### Multi-Instance Usage

For using OAuth tokens across multiple instances (CI/CD, containers, etc.):

1. **Quick sharing**: Set `CLAUDE_CODE_OAUTH_TOKEN` environment variable
2. **With auto-refresh**: Copy `~/.vibekit/claude-oauth-token.json` between instances
3. **Production**: Use a secrets manager or API keys

#### Library API Usage

You can use OAuth authentication programmatically with the auth package:

```typescript
import { ClaudeAuth } from '@vibe-kit/auth';

// Authenticate and get token
const token = await ClaudeAuth.authenticate();

// Check if authenticated
const isAuthenticated = await ClaudeAuth.isAuthenticated();

// Get valid token (auto-refresh if needed)
const accessToken = await ClaudeAuth.getValidToken();

// Export token
const exportedToken = await ClaudeAuth.exportToken('full');

// Import token
await ClaudeAuth.importToken({ refreshToken: 'your-refresh-token' });

// Clear authentication
await ClaudeAuth.logout();
```

#### Web OAuth Usage

For web applications, OAuth authentication works the same way as CLI - users copy and paste the authentication code:

```typescript
import { ClaudeWebAuth, MemoryTokenStorage } from '@vibe-kit/auth';

// Frontend - Generate OAuth URL
const { url, state, codeVerifier } = ClaudeWebAuth.createAuthorizationUrl();

// Store for later use
sessionStorage.setItem('oauth_state', state);
sessionStorage.setItem('oauth_code_verifier', codeVerifier);

// Open Claude authentication in new tab
window.open(url, '_blank');

// After user copies the authentication code (format: code#state)
const authCode = "paste-authentication-code-here";

// Backend - Authenticate with the code
const storage = new MemoryTokenStorage(sessionId);
const auth = new ClaudeWebAuth(storage);
await auth.authenticate(authCode, codeVerifier, state);

// Use the token with VibeKit
const accessToken = await auth.getValidToken();

// Pass token as API key to VibeKit
const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    providerApiKey: accessToken, // Pass OAuth token as API key
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(sandboxProvider);
```

### 2. API Key Authentication

Use your Anthropic API key directly:

```typescript
const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    providerApiKey: process.env.ANTHROPIC_API_KEY, // Traditional API key
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(sandboxProvider);
```

Both OAuth tokens and API keys are passed the same way to VibeKit - as the `providerApiKey` parameter.


================================================
FILE: docs/agents/codex.mdx
================================================
---
title: 'OpenAI Codex'
description: 'Run OpenAI Codex in a secure and private sandbox'
---

<img
  src="/images/demo.gif"
  alt="Hero Light"
/>


## How it works

VibeKit runs OpenAI Codex in headless mode with the `auto-edit` flag enabled. This means that the agent will automatically create, edit and delete files if it's in `code`Â mode.

The Codex CLI runs in the configured environment and has access to the network, which means it could be used to connect to the outside world. This is a powerful feature that can be used to build powerful applications and should be used with caution.

[Read more about OpenAI Codex CLI](https://github.com/openai/codex)


================================================
FILE: docs/agents/gemini.mdx
================================================
---
title: 'Google Gemini'
description: 'Run Google Gemini CLI in a secure and private sandbox'
---

<img
  src="/images/gemini.jpeg"
  alt="Gemini"
/>


## How it works

VibeKit runs Gemini CLI in headless mode with the `--yolo` flag enabled. This means that the agent will automatically create, edit and delete files if it's in `code`Â mode.

The Gemini CLI runs in the configured environment and has access to the network, which means it could be used to connect to the outside world. This is a powerful feature that can be used to build powerful applications and should be used with caution.

[Read more about Gemini CLI](https://t.co/R2CsgNMA3A)


================================================
FILE: docs/agents/grok.mdx
================================================
---
title: 'Grok CLI'
description: 'Run Grok CLI in a secure and private sandbox'
---

<img
  src="/images/grok.png"
  alt="Grok"
/>

## How it works

VibeKit runs the Grok CLI in headless mode. This means that the agent will automatically create, edit and delete files if it's in `code` mode.

The Grok CLI runs in the configured environment and has access to the network, which means it could be used to connect to the outside world. This is a powerful feature that can be used to build powerful applications and should be used with caution.

[Read more about Grok CLI](https://github.com/superagent-ai/grok-cli)

## Authentication

Grok CLI requires an API key from xAI (X.AI). You can obtain one from the [xAI Console](https://console.x.ai/).

### Environment Variable Authentication

Set your xAI API key as an environment variable:

```bash
export GROK_API_KEY="your-xai-api-key-here"
# or alternatively
export XAI_API_KEY="your-xai-api-key-here"
```

### Using in Code

```typescript
const vibeKit = new VibeKit()
  .withAgent({
    type: "grok",
    provider: "xai",
    apiKey: process.env.GROK_API_KEY,
    model: "grok-beta", // or "grok-2-latest", "grok-2-mini"
  })
  .withSandbox(sandboxProvider);
```

## Configuration Options

### Available Models

- `grok-beta` - Latest Grok model (default)
- `grok-2-latest` - Grok-2 latest version
- `grok-2-mini` - Grok-2 mini version for faster responses

### Custom Base URL

If you're using a custom xAI API endpoint:

```typescript
const vibeKit = new VibeKit()
  .withAgent({
    type: "grok",
    provider: "xai",
    apiKey: process.env.GROK_API_KEY,
    model: "grok-beta",
    baseUrl: "https://your-custom-api-url.com", // optional
  })
  .withSandbox(sandboxProvider);
```

## Example Usage

### Basic Code Generation

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createE2BProvider } from "@vibe-kit/e2b";

const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY!,
  templateId: "vibekit-grok",
});

const vibeKit = new VibeKit()
  .withAgent({
    type: "grok",
    provider: "xai",
    apiKey: process.env.GROK_API_KEY!,
    model: "grok-beta",
  })
  .withSandbox(e2bProvider);

// Generate code
const result = await vibeKit.generateCode({
  prompt: "Create a simple React component that displays a hello world message",
  mode: "code"
});

console.log(result.stdout);
```

### Ask Mode (Research Only)

```typescript
// Ask questions without modifying files
const result = await vibeKit.generateCode({
  prompt: "What is the current project structure?",
  mode: "ask"
});

console.log(result.stdout);
```

## Environment Variables

The Grok agent supports the following environment variables:

- `GROK_API_KEY` - Your xAI API key (required)
- `XAI_API_KEY` - Alternative name for your xAI API key
- `GROK_BASE_URL` - Custom API base URL (optional)

## Security Considerations

- API keys are passed to the sandbox environment and should be treated as sensitive information
- The Grok CLI has network access and can make external API calls
- Always use proper secrets management in production environments
- Consider using environment-specific API keys with appropriate rate limits

## Troubleshooting

### Common Issues

1. **"grok command not found"**: Ensure the Grok CLI is installed in your sandbox template
2. **Authentication errors**: Verify your API key is correct and has sufficient credits
3. **Rate limiting**: xAI has rate limits; consider implementing retry logic for production use
4. **Model not available**: Check that the specified model is available in your xAI account

### Debug Mode

To see detailed output from the Grok CLI, you can enable streaming callbacks:

```typescript
vibeKit.on("update", (message) => {
  console.log("Grok output:", message);
});

vibeKit.on("error", (error) => {
  console.error("Grok error:", error);
});
```


================================================
FILE: docs/agents/opencode.mdx
================================================
---
title: 'Opencode'
description: 'Run Opencode in a secure and private sandbox'
---

<img
  src="/images/opencode.png"
  alt="Opencode"
/>


## How it works

VibeKit runs Opencode in headless mode. This means that the agent will automatically create, edit and delete files if it's in `code`Â mode.

The Opencode CLI runs in the configured environment and has access to the network, which means it could be used to connect to the outside world. This is a powerful feature that can be used to build powerful applications and should be used with caution.

[Read more about Opencode](https://github.com/sst/opencode)


================================================
FILE: docs/api-reference/configuration.mdx
================================================
---
title: 'Configuration'
description: 'VibeKit configuration reference'
---

## Overview

VibeKit provides a fluent interface for configuration. You can chain methods to configure the agent, sandbox provider, GitHub integration, and other options.

## Basic configuration

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createE2BProvider } from "@vibe-kit/e2b";

const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY\!,
  templateId: "vibekit-claude",
});

const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY\!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(e2bProvider)
  .withGithub({
    token: process.env.GITHUB_TOKEN\!,
    repository: "your-org/your-repo",
  });
```

## Configuration reference

### Agent Configuration

Use the `withAgent()` method to configure which AI model to use.

```typescript
.withAgent({
  type: "claude",
  provider: "anthropic",
  apiKey: "your-api-key",
  model: "claude-sonnet-4-20250514",
})
```

#### Agent Configuration Options

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `type` | `AgentType` | Yes | The type of AI agent to use |
| `provider` | `ModelProvider` | Yes | The AI provider service |
| `apiKey` | `string` | Yes | API key for the chosen agent provider |
| `model` | `string` | Yes | Specific model to use |

**Available agent types:**
- `"claude"` - Anthropic Claude agent
- `"codex"` - OpenAI Codex agent
- `"opencode"` - Opencode agent
- `"gemini"` - Google Gemini agent

**Available providers:**
- `"anthropic"` - Anthropic
- `"openai"` - OpenAI
- `"openrouter"` - OpenRouter
- `"azure"` - Azure
- `"gemini"` - Google Gemini
- `"ollama"` - Ollama
- `"mistral"` - Mistral AI
- `"deepseek"` - DeepSeek
- `"xai"` - xAI
- `"groq"` - Groq

### Sandbox Configuration

Use the `withSandbox()` method to configure the sandbox environment where code execution happens. You'll need to install and import the specific provider package.

#### E2B Configuration

```typescript
import { createE2BProvider } from "@vibe-kit/e2b";

const e2bProvider = createE2BProvider({
  apiKey: "e2b_****",
  templateId: "custom-template-id" // optional
});

.withSandbox(e2bProvider)
```

#### Northflank Configuration

```typescript
import { createNorthflankProvider } from "@vibe-kit/northflank";

const northflankProvider = createNorthflankProvider({
  apiKey: "nf_****",
  image: "your-custom-image", // optional
  projectId: "your-project-id", // optional
  billingPlan: "nf-compute-200", // optional
  persistentVolumeStorage: 10240 // optional
});

.withSandbox(northflankProvider)
```

#### Daytona Configuration

```typescript
import { createDaytonaProvider } from "@vibe-kit/daytona";

const daytonaProvider = createDaytonaProvider({
  apiKey: "daytona_****",
  image: "my-codex-image", // optional
  serverUrl: "https://app.daytona.io/api" // optional
});

.withSandbox(daytonaProvider)
```

#### Cloudflare Configuration

```typescript
import { createCloudflareProvider } from "@vibe-kit/cloudflare";

// Must be used within a Cloudflare Worker
const cloudflareProvider = createCloudflareProvider({
  env: env, // Worker env object with Sandbox binding
  hostname: "your-worker.domain.workers.dev"
});

.withSandbox(cloudflareProvider)
```

For detailed configuration options for each provider, see the [Supported Sandboxes](/supported-sandboxes) section.

### GitHub Integration

Use the `withGithub()` method to configure repository integration for pull request creation and code management.

```typescript
.withGithub({
  token: "ghp_****",
  repository: "superagent-ai/vibekit"
})
```

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `token` | `string` | Yes | GitHub personal access token with repository permissions |
| `repository` | `string` | Yes | Repository in the format "owner/repo-name" |

### Session Management (Optional)

Use the `withSession()` method to specify a sandbox session to reuse.

```typescript
.withSession("existing-sandbox-id")
```

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `sandboxId` | `string` | Yes | Existing sandbox ID to reuse |

### Working Directory

Use the `withWorkingDirectory()` method to specify the directory where the agent should execute commands and work with files.

```typescript
.withWorkingDirectory("/path/to/your/project")
```

| Property | Type | Required | Default | Description |
|----------|------|----------|---------|-------------|
| `path` | `string` | Yes | - | The directory path where the agent will execute commands and access files |

### Secrets Management

Use the `withSecrets()` method to provide environment variables and secrets to the sandbox.

```typescript
.withSecrets({
  "DATABASE_URL": "postgresql://...",
  "API_KEY": "secret-key",
  "NODE_ENV": "production"
})
```

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `secrets` | `Record<string, string>` | Yes | Key-value pairs of environment variables to set in the sandbox |

## Complete Example

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createE2BProvider } from "@vibe-kit/e2b";

const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY\!,
  templateId: "vibekit-claude",
});

const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY\!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(e2bProvider)
  .withGithub({
    token: process.env.GITHUB_TOKEN\!,
    repository: "your-org/your-repo",
  })
  .withWorkingDirectory("/app")
  .withSecrets({
    "DATABASE_URL": process.env.DATABASE_URL\!,
    "API_KEY": process.env.API_KEY\!,
  });

// Use the configured VibeKit instance
const result = await vibeKit.generateCode({
  prompt: "Create a web server",
  mode: "ask"
});
```
EOF < /dev/null


================================================
FILE: docs/api-reference/create-pull-request.mdx
================================================
---
title: "createPullRequest"
description: "Create a pull request after generating code changes."
---

## Method signature

```typescript
async createPullRequest(
  labelOptions?: LabelOptions,
  branchPrefix?: string
): Promise<PullRequestResponse>
```

## Description

The `createPullRequest` method allows you to create a GitHub pull request after code changes have been generated using any supported agent (Codex, Claude, OpenCode, or Gemini). This method streamlines the process of submitting code changes for review by automatically creating a pull request with the generated modifications.

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `labelOptions` | `LabelOptions` | No | Optional label configuration for the pull request |
| `branchPrefix` | `string` | No | Optional prefix for the branch name that will be created |

### LabelOptions Interface

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `name` | `string` | Yes | The name of the label to create/apply to the pull request |
| `color` | `string` | Yes | The color of the label in hex format (without #). Examples: "0e8a16" (green), "d73a49" (red), "0366d6" (blue) |
| `description` | `string` | Yes | A description of what this label represents |

## Return type

| Type | Description |
|------|-------------|
| `Promise<PullRequestResponse>` | Promise that resolves to a pull request response object |

### PullRequestResponse Interface

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `id` | `number` | Yes | The unique identifier of the pull request |
| `number` | `number` | Yes | The pull request number |
| `state` | `string` | Yes | The state of the pull request (e.g., "open", "closed") |
| `title` | `string` | Yes | The title of the pull request |
| `body` | `string` | Yes | The body/description of the pull request |
| `html_url` | `string` | Yes | The URL to view the pull request on GitHub |
| `head` | `object` | Yes | Information about the head branch of the PR |
| `base` | `object` | Yes | Information about the base branch of the PR |
| `user` | `object` | Yes | Information about the user who created the PR |
| `created_at` | `string` | Yes | ISO timestamp when the PR was created |
| `updated_at` | `string` | Yes | ISO timestamp when the PR was last updated |
| `merged` | `boolean` | Yes | Whether the pull request has been merged |
| `mergeable` | `boolean \| null` | Yes | Whether the pull request can be merged |
| `merge_commit_sha` | `string \| null` | Yes | The SHA of the merge commit if merged |
| `branchName` | `string` | Yes | The name of the branch created for the PR |
| `commitSha` | `string` | No | The SHA of the commit |

## Requirements

- **Agent Type**: This method is available for all supported agents (Codex, Claude, OpenCode, and Gemini)
- **Initialization**: The VibeKit instance must be properly initialized with valid agent configuration
- **Code Generation**: Code changes should be generated before creating a pull request
- **GitHub Integration**: A valid GitHub token and repository URL must be configured

## Error handling

The method throws errors in the following scenarios:

### Initialization Error
```typescript
throw new Error("Agent not initialized")
```
- **When**: The agent is not properly initialized
- **Resolution**: Verify your VibeKit configuration includes valid agent settings and GitHub configuration

## Usage examples

### Basic Usage

```typescript
import { VibeKit } from 'vibekit';

const vibekit = new VibeKit(config);

// Generate code first
await vibekit.generateCode({
  prompt: "Add a new user registration feature",
  mode: "code"
});

// Create pull request with default settings
try {
  const prResponse = await vibekit.createPullRequest();
  
  console.log(`Pull request created: ${prResponse.html_url}`);
  console.log(`PR ID: ${prResponse.id}`);
  console.log(`PR Number: ${prResponse.number}`);
  console.log(`Title: ${prResponse.title}`);
  console.log(`State: ${prResponse.state}`);
  console.log(`Branch: ${prResponse.branchName}`);
  console.log(`Commit SHA: ${prResponse.commitSha}`);
  console.log(`Created at: ${prResponse.created_at}`);
  console.log(`Mergeable: ${prResponse.mergeable}`);
} catch (error) {
  console.error("Failed to create pull request:", error.message);
}
```

### Advanced Usage with Parameters

```typescript
import { VibeKit, LabelOptions } from 'vibekit';

const vibekit = new VibeKit(config);

// Generate code first
await vibekit.generateCode({
  prompt: "Add authentication middleware",
  mode: "code"
});

// Create pull request with custom parameters
const labelOptions: LabelOptions = {
  name: "ai-generated",
  color: "0e8a16",
  description: "Code generated by AI agent"
};

try {
  const prResponse = await vibekit.createPullRequest(
    labelOptions,               // Custom label options
    "feature"                   // Branch prefix (will create feature/xyz branch)
  );
  
  console.log(`Pull request created: ${prResponse.html_url}`);
  console.log(`PR Number: ${prResponse.number}`);
  console.log(`Branch: ${prResponse.branchName}`);
  
  // Access additional GitHub API data
  console.log(`PR Title: ${prResponse.title}`);
  console.log(`PR Body: ${prResponse.body}`);
  console.log(`Author: ${prResponse.user.login}`);
  console.log(`Head branch: ${prResponse.head.ref}`);
  console.log(`Base branch: ${prResponse.base.ref}`);
} catch (error) {
  console.error("Failed to create pull request:", error.message);
}
```

### Additional Label Examples

```typescript
// Different label configurations
const bugfixLabel: LabelOptions = {
  name: "bug-fix",
  color: "d73a49",
  description: "Fixes a bug in the codebase"
};

const featureLabel: LabelOptions = {
  name: "new-feature",
  color: "0366d6", 
  description: "Adds new functionality"
};

const refactorLabel: LabelOptions = {
  name: "refactor",
  color: "f9d71c",
  description: "Code refactoring without functional changes"
};
```

### Using with Different Agents

```typescript
// Works with any agent type
const vibekitClaude = new VibeKit({
  agent: { type: "claude", model: { ... } },
  github: { token: "...", repository: "..." },
  // ... other config
});

const vibekitCodex = new VibeKit({
  agent: { type: "codex", model: { ... } },
  github: { token: "...", repository: "..." },
  // ... other config
});

// Both agents support createPullRequest
await vibekitClaude.createPullRequest();
await vibekitCodex.createPullRequest();
```

## Notes

- The pull request is automatically labeled with the agent type ('codex', 'claude', 'opencode', or 'gemini') to indicate which agent created it
- Ensure your GitHub token has the necessary permissions to create pull requests in the target repository
- The method creates a new branch for the pull request automatically
- Code changes must be generated before calling this method
- When using `branchPrefix`, the final branch name will be in the format `{branchPrefix}/{generated-suffix}`
- The `labelOptions` parameter creates a new label if it doesn't exist in the repository and applies it to the pull request
- The response includes the complete GitHub API pull request data, allowing access to detailed information like user details, branch information, timestamps, and merge status


================================================
FILE: docs/api-reference/execute-command.mdx
================================================
---
title: 'executeCommand'
description: 'Run arbitrary shell commands in the sandbox environment.'
---

## Method signature

```typescript
public async executeCommand(
  command: string,
  options: {
    timeoutMs?: number;
    background?: boolean;
    callbacks?: StreamCallbacks;
  } = {}
): Promise<AgentResponse>
```

## Parameters

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `command` | `string` | Yes | - | The shell command to execute in the sandbox environment |
| `options` | `object` | No | `{}` | Configuration options for command execution |

### Options Object

| Property | Type | Required | Default | Description |
|----------|------|----------|---------|-------------|
| `timeoutMs` | `number` | No | - | Maximum time in milliseconds to wait for command completion |
| `background` | `boolean` | No | `false` | Whether to run the command in the background (non-blocking) |
| `callbacks` | `StreamCallbacks` | No | - | Streaming callbacks for real-time command output |

### StreamCallbacks Interface

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `onUpdate` | `(message: string) => void` | No | Called with streaming updates from command output |
| `onError` | `(error: string) => void` | No | Called when errors occur during command execution |

## Return value

| Type | Description |
|------|-------------|
| `Promise<AgentResponse>` | Promise that resolves to the command execution results |

### AgentResponse Interface

| Property | Type | Description |
|----------|------|-------------|
| `sandboxId` | `string` | Unique identifier for the sandbox environment |
| `stdout` | `string` | Standard output from the command execution |
| `stderr` | `string` | Standard error from the command execution |
| `exitCode` | `number` | Exit code from the command execution (0 indicates success) |

## Examples

### Basic Command Execution

```typescript
import { VibeKit } from 'vibekit';

const vibekit = new VibeKit(config);

// Execute a simple command
const result = await vibekit.executeCommand('ls -la');

console.log('Command output:', result.stdout);
console.log('Exit code:', result.exitCode);
```

### Command with Timeout

```typescript
// Execute command with a timeout
const result = await vibekit.executeCommand('npm install', {
  timeoutMs: 30000 // 30 seconds timeout
});

if (result.exitCode === 0) {
  console.log('Installation completed successfully');
} else {
  console.log('Installation failed:', result.stderr);
}
```

### Background Command Execution

```typescript
// Run a long-running command in the background
const result = await vibekit.executeCommand('npm run dev', {
  background: true
});

console.log('Background process started with sandbox ID:', result.sandboxId);
```


### Streaming Command Output

```typescript
// Execute command with streaming output
const result = await vibekit.executeCommand('npm test', {
  callbacks: {
    onUpdate: (message) => {
      console.log('Test output:', message);
    },
    onError: (error) => {
      console.error('Test error:', error);
    }
  }
});

console.log('Final test result:', result.exitCode === 0 ? 'PASSED' : 'FAILED');
```

### Complex Command with All Options

```typescript
// Execute a complex command with multiple options
const result = await vibekit.executeCommand('python -m pytest tests/', {
  timeoutMs: 60000,
  background: false,
  callbacks: {
    onUpdate: (output) => {
      console.log('pytest:', output);
    },
    onError: (error) => {
      console.error('pytest error:', error);
    }
  }
});

console.log(`Tests completed with exit code: ${result.exitCode}`);
```

## Error handling

The method throws errors in the following cases:

- **Sandbox not available:** When no active sandbox environment exists
- **Command timeout:** When the command exceeds the specified timeout
- **Invalid command:** When the command syntax is invalid or command not found
- **Permission errors:** When the command requires elevated permissions not available in the sandbox
- **Resource limitations:** When the command exceeds sandbox resource limits

```typescript
try {
  const result = await vibekit.executeCommand('sudo rm -rf /', {
    timeoutMs: 5000
  });
} catch (error) {
  if (error.message.includes('timeout')) {
    console.error('Command timed out');
  } else if (error.message.includes('permission')) {
    console.error('Permission denied');
  } else {
    console.error('Command execution failed:', error.message);
  }
}
```

## Security considerations

- Commands are executed within a sandboxed environment for security
- Elevated privileges (sudo) may not be available depending on sandbox configuration
- File system access is limited to the sandbox environment
- Network access may be restricted based on sandbox configuration

## Notes

- **Sandbox Environment:** Commands are executed within the active sandbox environment
- **Working Directory:** Commands execute in the sandbox's default working directory
- **Environment Variables:** Sandbox environment variables are available to executed commands
- **Resource Limits:** Commands are subject to sandbox CPU, memory, and time limitations
- **Background Execution:** Background commands continue running after the method returns
- **Streaming Support:** Real-time output streaming is available through callbacks
- **Exit Codes:** Standard Unix exit codes apply (0 = success, non-zero = error)




================================================
FILE: docs/api-reference/generate-code.mdx
================================================
---
title: 'generateCode'
description: 'Generates code using the configured AI agent (Codex or Claude) with optional streaming callbacks and conversation history.'
---

## Method signature

```typescript
async generateCode({
  prompt,
  mode,
  branch,
  history,
  callbacks,
}: {
  prompt: string;
  mode: "ask" | "code";
  branch?: string;
  history?: Conversation[];
  callbacks?: VibeKitStreamCallbacks;
}): Promise<AgentResponse>
```

## Parameters

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `prompt` | `string` | Yes | - | The text prompt describing what code to generate or question to ask |
| `mode` | `"ask" \| "code"` | Yes | - | Interactive Q&A mode (`"ask"`) or code generation mode (`"code"`) |
| `branch` | `string` | No | - | Branch identifier for version control or environment context |
| `history` | `Conversation[]` | No | - | Previous conversation history to provide context for the generation |
| `callbacks` | `VibeKitStreamCallbacks` | No | - | Streaming callbacks for real-time updates |

### VibeKitStreamCallbacks Interface

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `onUpdate` | `(message: string) => void` | No | Called with streaming updates |
| `onError` | `(error: string) => void` | No | Called when errors occur |

## Return value

| Type | Description |
|------|-------------|
| `Promise<AgentResponse>` | Promise that resolves to either a CodexResponse or ClaudeResponse depending on the configured agent |

### CodexResponse (for Codex Agent)

| Property | Type | Description |
|----------|------|-------------|
| `sandboxId` | `string` | Unique identifier for the sandbox environment |
| `stdout` | `string` | Standard output from code execution |
| `stderr` | `string` | Standard error from code execution |
| `exitCode` | `number` | Exit code from code execution |

### ClaudeResponse (for Claude Agent)

| Property | Type | Description |
|----------|------|-------------|
| `code` | `string` | Generated code response |

## Agent-specific behavior

### Codex Agent
- **Streaming Support:** Full streaming support with real-time updates
- **Sandbox Environment:** Executes code in isolated E2B sandbox
- **Mode Support:** Both "ask" and "code" modes fully supported

### Claude Agent
- **Streaming Support:** Limited - provides start/end notifications only
- **Execution:** Direct API calls without sandbox environment
- **Mode Support:** Both modes supported with fallback behavior

## Examples

### Basic Code Generation

```typescript
const vibeKit = new VibeKit(config);

const response = await vibeKit.generateCode({
  prompt: "Create a React component for a todo list",
  mode: "code"
});

console.log(response);
```

### With Streaming Callbacks

```typescript
const response = await vibeKit.generateCode({
  prompt: "Explain how React hooks work",
  mode: "ask",
  callbacks: {
    onUpdate: (message) => {
      console.log("Update:", message);
    },
    onError: (error) => {
      console.error("Error:", error);
    }
  }
});
```

### With Conversation History and Branch

```typescript
const history = [
  {
    role: "user",
    content: "What is React?"
  },
  {
    role: "assistant", 
    content: "React is a JavaScript library..."
  }
];

const response = await vibeKit.generateCode({
  prompt: "Now show me a React component example",
  mode: "code",
  branch: "feature-react-components",
  history
});
```

## Error handling

The method throws errors in the following cases:

- **Agent not initialized:** When the configured agent type doesn't match the initialized agent
- **Agent-specific errors:** 
  - Codex: Sandbox creation/execution failures, API errors
  - Claude: API authentication issues, rate limits
- **Configuration errors:** Missing required API keys or invalid setup

```typescript
try {
  const response = await vibeKit.generateCode({
    prompt,
    mode: "code"
  });
} catch (error) {
  if (error.message.includes('not initialized')) {
    // Handle initialization error
  } else {
    // Handle generation error
  }
}
```




## Notes

- **Required Mode:** The `mode` parameter is now required and must be specified
- **Object Parameters:** All parameters are now passed as a destructured object for better API consistency
- **Branch Support:** The optional `branch` parameter allows for version control or environment context
- **Streaming Differences:** Codex provides real-time streaming, while Claude only provides start/end notifications
- **Environment Support:** Daytona environment is not yet supported and will throw an error
- **Conversation Context:** History is preserved across calls to maintain conversation context




================================================
FILE: docs/api-reference/get-host.mdx
================================================
---
title: 'getHost'
description: 'Get the host URL for a specific port in the sandbox environment.'
---

## Method signature

```typescript
public getHost(port: number): string
```

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `port` | `number` | Yes | The port number to get the host URL for |

## Return value

| Type | Description |
|------|-------------|
| `string` | The host URL that can be used to access the specified port in the sandbox |

## Examples

### Get Host for Web Server

```typescript
import { VibeKit } from 'vibekit';

const vibekit = new VibeKit(config);

// Start a web server on port 3000
await vibekit.executeCommand('npm run dev -- --port 3000', {
  background: true
});

// Get the host URL for the web server
const hostUrl = vibekit.getHost(3000);
console.log('Web server accessible at:', hostUrl);
// Output: https://3000-sandbox-id.e2b.dev
```

### Get Host for API Server

```typescript
// Start an API server
await vibekit.executeCommand('python -m http.server 8080', {
  background: true
});

// Get the host URL for the API
const apiUrl = vibekit.getHost(8080);
console.log('API server accessible at:', apiUrl);
// Output: https://8080-sandbox-id.e2b.dev
```

### Get Host for Database Connection

```typescript
// Start a database server
await vibekit.executeCommand('mongod --port 27017', {
  background: true
});

// Get the host URL for database access
const dbHost = vibekit.getHost(27017);
console.log('Database accessible at:', dbHost);
// Output: https://27017-sandbox-id.e2b.dev
```

## Error handling

The method throws errors in the following cases:

- **Sandbox not active:** When called without an active sandbox environment
- **Unsupported sandbox:** When called with unsupported sandbox environments (FlyIO, Modal)
- **Invalid port:** When the port number is invalid or out of range

```typescript
try {
  const hostUrl = vibekit.getHost(3000);
  console.log('Host URL:', hostUrl);
} catch (error) {
  if (error.message.includes('sandbox')) {
    console.error('Active sandbox required for getHost functionality');
  } else if (error.message.includes('port')) {
    console.error('Invalid port number provided');
  } else {
    console.error('Failed to get host URL:', error.message);
  }
}
```

## Sandbox compatibility

| Sandbox Type | Supported | Notes |
|--------------|-----------|-------|
| **E2B** | âœ… Yes | Full support with automatic URL generation |
| **Daytona** | âœ… Yes | Full support with automatic URL generation |
| **Cloudflare** | âœ… Yes | Full support with automatic URL generation |
| **Northflank** | âœ… Yes | Full support with automatic URL generation |
| **FlyIO** | âŒ No | Port forwarding not yet implemented |
| **Modal** | âŒ No | Port forwarding not yet implemented |

## Use cases

- **Web Development:** Access development servers running in the sandbox
- **API Testing:** Get URLs for API servers to test endpoints
- **Database Access:** Connect to databases running in the sandbox
- **Microservices:** Access multiple services running on different ports
- **Live Previews:** Generate URLs for real-time preview of web applications

## Notes

- **Multi-Sandbox Support:** This method is available for E2B, Daytona, Cloudflare and Northflank sandbox environments
- **Automatic URL Generation:** Supported sandboxes automatically generate secure HTTPS URLs for exposed ports
- **Real-time Access:** URLs are immediately accessible once the service starts on the specified port
- **Security:** All generated URLs use HTTPS and are scoped to the specific sandbox instance
- **Port Range:** Standard port ranges (1-65535) are supported
- **No Port Validation:** The method doesn't validate if a service is actually running on the specified port


================================================
FILE: docs/api-reference/get-session.mdx
================================================
---
title: 'getSession'
description: 'Retrieves the current session ID for the sandbox environment.'
---

## Method signature

```typescript
async getSession(): Promise<string | null>
```

## Parameters

This method takes no parameters.

## Return value

| Type | Description |
|------|-------------|
| `Promise<string \| null>` | The current session ID if one is set, or `null` if no session is active |

## Examples

### Basic Usage

```typescript
const vibeKit = new VibeKit({
  agent: {
    type: "codex", // or "claude"
    model: {
      apiKey: "sk-proj-****"
    },
    mode: "code"
  },
  environment: {
    e2b: {
      apiKey: "e2b_****"
    }
  }
});

// Get the current session ID
const sessionId = await vibeKit.getSession();

if (sessionId) {
  console.log("Current session:", sessionId);
} else {
  console.log("No active session");
}
```

### Session Management Workflow

```typescript
// Check if there's an existing session
let sessionId = await vibeKit.getSession();

if (!sessionId) {
  // No session exists, generate some code to create one
  await vibeKit.generateCode("console.log('Hello World')");
  
  // Now get the new session ID
  sessionId = await vibeKit.getSession();
  console.log("New session created:", sessionId);
}

// Store the session ID for later use
localStorage.setItem('vibekit-session', sessionId);
```

### Error handling

```typescript
try {
  const sessionId = await vibeKit.getSession();
  console.log("Session ID:", sessionId);
} catch (error) {
  if (error.message.includes('not initialized')) {
    console.error("Agent is not properly initialized");
  } else {
    console.error("Unexpected error:", error.message);
  }
}
```

## Error handling

The method throws errors in the following cases:

### Initialization Error  
- **Condition:** When the agent is not properly initialized
- **Error Message:** "Agent not initialized"
- **Solution:** Verify your configuration includes valid credentials and the agent is properly set up

```typescript
// Correct configuration for session management
const config = {
  agent: {
    type: "codex", // or "claude"
    model: {
      apiKey: "your-api-key"
    },
    mode: "code"
  },
  environment: {
    e2b: {
      apiKey: "your-e2b-api-key" // For Codex agent
    }
    // Claude agent may have different environment requirements
  }
};
```

## Use cases

### Session Persistence
Store and retrieve session IDs to maintain continuity across application restarts:

```typescript
// On app startup, try to restore previous session
const storedSessionId = localStorage.getItem('vibekit-session');
if (storedSessionId) {
  await vibeKit.setSession(storedSessionId);
}

// Verify the session is active
const currentSession = await vibeKit.getSession();
if (currentSession === storedSessionId) {
  console.log("Session restored successfully");
}
```

### Multi-User Applications
Track different user sessions in multi-user environments:

```typescript
async function getUserSession(userId: string) {
  const currentSession = await vibeKit.getSession();
  
  // Store session mapping
  if (currentSession) {
    await database.saveUserSession(userId, currentSession);
  }
  
  return currentSession;
}
```

## Related methods

- [`setSession`](./set-session) - Set a specific session ID for the sandbox
- [`generateCode`](./generate-code) - Generate code (creates a session if none exists)

## Notes

- **Session Auto-Creation:** Sessions are automatically created when you first use `generateCode()` with either agent
- **Session Persistence:** Sessions persist across multiple `generateCode()` calls until explicitly changed or the sandbox is terminated
- **Null Return:** Returns `null` when no session has been established yet
- **Cross-Agent Support:** This functionality works with both Codex and Claude agents



================================================
FILE: docs/api-reference/kill-sandbox.mdx
================================================
---
title: 'kill'
description: 'Terminates the active sandbox.'
---

## Method signature

```typescript
async kill(): Promise<void>
```

## Parameters

This method takes no parameters.

## Return value

| Type | Description |
|------|-------------|
| `Promise<void>` | The method completes successfully when the sandbox is terminated |

## Behavior

The `kill()` method performs the following actions:

1. **Agent Type Validation**: Verifies that the current agent is of type "codex"
2. **Initialization Check**: Ensures the CodexAgent instance is properly initialized
3. **Sandbox Termination**: Calls the underlying `killSandbox()` method to terminate the active sandbox

## Examples

### Basic Usage

```typescript
const vibeKit = new VibeKit({
  agent: {
    type: "codex",
    // ... other config
  }
});

// Generate some code first to create a sandbox
await vibeKit.generateCode("console.log('Hello World')", "code");

// Kill the sandbox when done
await vibeKit.kill();
console.log("Sandbox terminated successfully");
```

### With Error Handling

```typescript
try {
  await vibeKit.kill();
  console.log("Sandbox terminated");
} catch (error) {
  if (error.message.includes("only supported for the Codex agent")) {
    console.error("Kill operation requires Codex agent");
  } else if (error.message.includes("not initialized")) {
    console.error("CodexAgent not properly initialized");
  } else {
    console.error("Failed to kill sandbox:", error.message);
  }
}
```

### Cleanup Pattern

```typescript
class CodeGenerator {
  private vibeKit: VibeKit;

  constructor(config: VibeKitConfig) {
    this.vibeKit = new VibeKit(config);
  }

  async generateAndCleanup(prompt: string) {
    try {
      // Generate code
      const response = await this.vibeKit.generateCode(prompt, "code");
      
      // Process the response
      console.log("Generated code:", response);
      
      return response;
    } finally {
      // Always cleanup the sandbox
      await this.vibeKit.kill();
    }
  }
}
```

## Error handling

The method throws errors in the following cases:

### Agent Type Error
```typescript
// When using non-Codex agent
throw new Error("Sandbox management is only supported for the Codex agent");
```

### Initialization Error
```typescript
// When CodexAgent is not initialized
throw new Error("CodexAgent not initialized");
```

### Example Error Handling
```typescript
try {
  await vibeKit.kill();
} catch (error) {
  switch (true) {
    case error.message.includes("only supported for the Codex agent"):
      // Handle agent type mismatch
      console.error("This operation requires a Codex agent");
      break;
    
    case error.message.includes("not initialized"):
      // Handle initialization error
      console.error("Agent not properly initialized");
      break;
    
    default:
      // Handle other sandbox-related errors
      console.error("Sandbox termination failed:", error.message);
  }
}
```

## Use cases

### Resource Management
Perfect for cleaning up sandbox resources when your application is done with code generation:

```typescript
// After batch processing
const prompts = ["task1", "task2", "task3"];

for (const prompt of prompts) {
  await vibeKit.generateCode(prompt, "code");
}

// Cleanup when done
await vibeKit.kill();
```

### Error Recovery
Use in error handling to ensure sandbox cleanup:

```typescript
try {
  await vibeKit.generateCode(complexPrompt, "code");
} catch (generationError) {
  console.error("Generation failed:", generationError);
  
  // Cleanup potentially corrupted sandbox
  await vibeKit.kill();
  
  throw generationError;
}
```

## Notes

- **Resource Cleanup**: Always call `kill()` when you're done with sandbox operations to free up resources
- **State Reset**: Killing a sandbox destroys all its state and files
- **Irreversible**: Once killed, the sandbox cannot be resumed - you'll need to generate new code to create a fresh sandbox
- **Best Practice**: Use in cleanup routines and error handlers to prevent resource leaks 


================================================
FILE: docs/api-reference/openapi.json
================================================
{
  "openapi": "3.1.0",
  "info": {
    "title": "OpenAPI Plant Store",
    "description": "A sample API that uses a plant store as an example to demonstrate features in the OpenAPI specification",
    "license": {
      "name": "MIT"
    },
    "version": "1.0.0"
  },
  "servers": [
    {
      "url": "http://sandbox.mintlify.com"
    }
  ],
  "security": [
    {
      "bearerAuth": []
    }
  ],
  "paths": {
    "/plants": {
      "get": {
        "description": "Returns all plants from the system that the user has access to",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "The maximum number of results to return",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Plant response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Plant"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "post": {
        "description": "Creates a new plant in the store",
        "requestBody": {
          "description": "Plant to add to the store",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewPlant"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "plant response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Plant"
                }
              }
            }
          },
          "400": {
            "description": "unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/plants/{id}": {
      "delete": {
        "description": "Deletes a single plant based on the ID supplied",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of plant to delete",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Plant deleted",
            "content": {}
          },
          "400": {
            "description": "unexpected error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    }
  },
  "webhooks": {
    "/plant/webhook": {
      "post": {
        "description": "Information about a new plant added to the store",
        "requestBody": {
          "description": "Plant added to the store",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewPlant"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Return a 200 status to indicate that the data was received successfully"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "Plant": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "description": "The name of the plant",
            "type": "string"
          },
          "tag": {
            "description": "Tag to specify the type",
            "type": "string"
          }
        }
      },
      "NewPlant": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Plant"
          },
          {
            "required": [
              "id"
            ],
            "type": "object",
            "properties": {
              "id": {
                "description": "Identification number of the plant",
                "type": "integer",
                "format": "int64"
              }
            }
          }
        ]
      },
      "Error": {
        "required": [
          "error",
          "message"
        ],
        "type": "object",
        "properties": {
          "error": {
            "type": "integer",
            "format": "int32"
          },
          "message": {
            "type": "string"
          }
        }
      }
    },
    "securitySchemes": {
      "bearerAuth": {
        "type": "http",
        "scheme": "bearer"
      }
    }
  }
}


================================================
FILE: docs/api-reference/pause-sandbox.mdx
================================================
---
title: 'pause'
description: 'Pauses the active sandbox.'
---

## Method signature

```typescript
async pause(): Promise<void>
```

## Parameters

This method takes no parameters.

## Return value

| Type | Description |
|------|-------------|
| `Promise<void>` | The method completes successfully when the sandbox is paused |

## Behavior

The `pause()` method performs the following actions:

1. **Agent Type Validation**: Verifies that the current agent is of type "codex"
2. **Initialization Check**: Ensures the CodexAgent instance is properly initialized
3. **Sandbox Pausing**: Calls the underlying `pauseSandbox()` method to pause the active sandbox

## Examples

### Basic Usage

```typescript
const vibeKit = new VibeKit({
  agent: {
    type: "codex",
    // ... other config
  }
});

// Generate some code first to create a sandbox
await vibeKit.generateCode("console.log('Hello World')", "code");

// Pause the sandbox to save resources
await vibeKit.pause();
console.log("Sandbox paused successfully");

// Later, resume the sandbox
await vibeKit.resume();
```

### With Error Handling

```typescript
try {
  await vibeKit.pause();
  console.log("Sandbox paused");
} catch (error) {
  if (error.message.includes("only supported for the Codex agent")) {
    console.error("Pause operation requires Codex agent");
  } else if (error.message.includes("not initialized")) {
    console.error("CodexAgent not properly initialized");
  } else {
    console.error("Failed to pause sandbox:", error.message);
  }
}
```

### Resource Management Pattern

```typescript
class SandboxManager {
  private vibeKit: VibeKit;
  private isPaused: boolean = false;

  constructor(config: VibeKitConfig) {
    this.vibeKit = new VibeKit(config);
  }

  async pauseForBreak() {
    if (!this.isPaused) {
      await this.vibeKit.pause();
      this.isPaused = true;
      console.log("Sandbox paused for break");
    }
  }

  async resumeFromBreak() {
    if (this.isPaused) {
      await this.vibeKit.resume();
      this.isPaused = false;
      console.log("Sandbox resumed from break");
    }
  }

  async generateCode(prompt: string) {
    // Resume if paused
    if (this.isPaused) {
      await this.resumeFromBreak();
    }
    
    return await this.vibeKit.generateCode(prompt, "code");
  }
}
```

### Auto-Pause on Inactivity

```typescript
class AutoPausingSandbox {
  private vibeKit: VibeKit;
  private inactivityTimer: NodeJS.Timeout | null = null;
  private readonly INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 minutes

  constructor(config: VibeKitConfig) {
    this.vibeKit = new VibeKit(config);
  }

  async generateCode(prompt: string) {
    // Clear existing timer
    this.clearInactivityTimer();
    
    // Generate code
    const response = await this.vibeKit.generateCode(prompt, "code");
    
    // Start new inactivity timer
    this.startInactivityTimer();
    
    return response;
  }

  private startInactivityTimer() {
    this.inactivityTimer = setTimeout(async () => {
      try {
        await this.vibeKit.pause();
        console.log("Sandbox auto-paused due to inactivity");
      } catch (error) {
        console.error("Failed to auto-pause sandbox:", error);
      }
    }, this.INACTIVITY_TIMEOUT);
  }

  private clearInactivityTimer() {
    if (this.inactivityTimer) {
      clearTimeout(this.inactivityTimer);
      this.inactivityTimer = null;
    }
  }
}
```

## Error handling

The method throws errors in the following cases:

### Agent Type Error
```typescript
// When using non-Codex agent
throw new Error("Sandbox management is only supported for the Codex agent");
```

### Initialization Error
```typescript
// When CodexAgent is not initialized
throw new Error("CodexAgent not initialized");
```

### Example Error Handling
```typescript
try {
  await vibeKit.pause();
} catch (error) {
  switch (true) {
    case error.message.includes("only supported for the Codex agent"):
      // Handle agent type mismatch
      console.error("This operation requires a Codex agent");
      break;
    
    case error.message.includes("not initialized"):
      // Handle initialization error
      console.error("Agent not properly initialized");
      break;
    
    default:
      // Handle other sandbox-related errors
      console.error("Sandbox pause failed:", error.message);
  }
}
```

## Use cases

### Cost Optimization
Pause sandboxes during periods of inactivity to reduce resource costs:

```typescript
// During lunch break or after hours
await vibeKit.pause();
console.log("Sandbox paused - resources saved");
```

### Batch Processing with Breaks
Pause between processing batches to manage resource usage:

```typescript
const batches = [batch1, batch2, batch3];

for (let i = 0; i < batches.length; i++) {
  const batch = batches[i];
  
  // Process batch
  for (const prompt of batch) {
    await vibeKit.generateCode(prompt, "code");
  }
  
  // Pause between batches (except for the last one)
  if (i < batches.length - 1) {
    await vibeKit.pause();
    console.log(`Batch ${i + 1} completed. Sandbox paused.`);
    
    // Simulate break time
    await new Promise(resolve => setTimeout(resolve, 30000)); // 30 seconds
    
    await vibeKit.resume();
    console.log(`Resuming for batch ${i + 2}`);
  }
}
```

### Conditional Resource Management
Pause based on system conditions:

```typescript
class ResourceAwareSandbox {
  private vibeKit: VibeKit;

  constructor(config: VibeKitConfig) {
    this.vibeKit = new VibeKit(config);
  }

  async smartPause() {
    const memoryUsage = process.memoryUsage();
    const highMemoryUsage = memoryUsage.heapUsed > 100 * 1024 * 1024; // 100MB
    
    if (highMemoryUsage) {
      await this.vibeKit.pause();
      console.log("Sandbox paused due to high memory usage");
      
      // Force garbage collection if available
      if (global.gc) {
        global.gc();
      }
    }
  }
}
```

## State preservation

<Info>
When a sandbox is paused, its state is preserved including:
- File system contents
- Environment variables
- Running processes (suspended)
- Network connections (may timeout)
</Info>

## Notes

- **State Preservation**: Pausing preserves the sandbox state, unlike `kill()` which destroys it
- **Resource Savings**: Paused sandboxes consume significantly fewer resources
- **Resumable**: Use `resume()` to continue from exactly where you left off
- **Best Practice**: Pause during periods of inactivity to optimize resource usage and costs
- **Automatic Cleanup**: Consider implementing auto-pause mechanisms for long-running applications 


================================================
FILE: docs/api-reference/push-to-branch.mdx
================================================
---
title: "pushToBranch"
description: "Push code changes to a branch."
---

## Method signature

```typescript
async pushToBranch(branch?: string): Promise<void>
```

## Description

Pushes the current code changes from the sandbox environment to a specified Git branch. This method is useful when you want to save your generated code changes to a branch without creating a pull request.

## Parameters

<ParamField path="branch" type="string" optional>
  The name of the branch to push changes to. If not provided, pushes to the current active branch or the default branch configured in the agent.
</ParamField>

## Return value

Returns a `Promise<void>` that resolves when the push operation completes successfully.

## Usage example

```typescript
import { VibeKit } from "vibekit";

const vibekit = new VibeKit({
  agent: {
    type: "claude",
    model: {
      name: "claude-3-5-sonnet-20241022",
      provider: "anthropic",
      apiKey: process.env.ANTHROPIC_API_KEY,
    },
  },
  github: {
    token: process.env.GITHUB_TOKEN,
    repository: "https://github.com/your-org/your-repo",
  },
  environment: {
    e2b: {
      apiKey: process.env.E2B_API_KEY,
    },
  },
  sessionId: "unique-session-id",
});

// Generate some code changes
await vibekit.generateCode({
  prompt: "Add a new React component for user profiles",
  mode: "code",
  branch: "feature/user-profiles",
});

// Or push to the current/default branch
await vibekit.pushToBranch();
```

## Notes

- This method requires that the VibeKit instance is configured with GitHub credentials
- The branch must exist in the repository, or the agent must have permissions to create it
- Changes are pushed directly without creating a pull request - use `createPullRequest()` if you want to create a PR instead
- This operation is available for both Codex and Claude agents

## Related methods

- [`createPullRequest()`](/api-reference/create-pull-request) - Create a pull request with the current changes
- [`generateCode()`](/api-reference/generate-code) - Generate code changes before pushing


================================================
FILE: docs/api-reference/resume-sandbox.mdx
================================================
---
title: 'resume'
description: 'Resumes the paused sandbox.'
---

## Method signature

```typescript
async resume(): Promise<void>
```

## Parameters

This method takes no parameters.

## Return value

| Type | Description |
|------|-------------|
| `Promise<void>` | The method completes successfully when the sandbox is resumed |

## Behavior

The `resume()` method performs the following actions:

1. **Agent Type Validation**: Verifies that the current agent is of type "codex"
2. **Initialization Check**: Ensures the CodexAgent instance is properly initialized
3. **Sandbox Resumption**: Calls the underlying `resumeSandbox()` method to resume the paused sandbox

## Examples

### Basic Usage

```typescript
const vibeKit = new VibeKit({
  agent: {
    type: "codex",
    // ... other config
  }
});

// Generate some code first to create a sandbox
await vibeKit.generateCode("console.log('Hello World')", "code");

// Pause the sandbox
await vibeKit.pause();
console.log("Sandbox paused");

// Resume the sandbox
await vibeKit.resume();
console.log("Sandbox resumed - ready for more operations");

// Continue generating code
await vibeKit.generateCode("console.log('Back online!')", "code");
```

### With Error Handling

```typescript
try {
  await vibeKit.resume();
  console.log("Sandbox resumed successfully");
} catch (error) {
  if (error.message.includes("only supported for the Codex agent")) {
    console.error("Resume operation requires Codex agent");
  } else if (error.message.includes("not initialized")) {
    console.error("CodexAgent not properly initialized");
  } else {
    console.error("Failed to resume sandbox:", error.message);
  }
}
```

### State Management Pattern

```typescript
class SandboxStateManager {
  private vibeKit: VibeKit;
  private state: 'active' | 'paused' | 'killed' = 'active';

  constructor(config: VibeKitConfig) {
    this.vibeKit = new VibeKit(config);
  }

  async pause() {
    if (this.state === 'active') {
      await this.vibeKit.pause();
      this.state = 'paused';
      console.log("Sandbox paused");
    }
  }

  async resume() {
    if (this.state === 'paused') {
      await this.vibeKit.resume();
      this.state = 'active';
      console.log("Sandbox resumed");
    }
  }

  async generateCode(prompt: string) {
    // Auto-resume if paused
    if (this.state === 'paused') {
      await this.resume();
    }
    
    if (this.state === 'killed') {
      throw new Error("Cannot generate code: sandbox has been killed");
    }
    
    return await this.vibeKit.generateCode(prompt, "code");
  }

  getState() {
    return this.state;
  }
}
```

### Auto-Resume on Activity

```typescript
class SmartSandbox {
  private vibeKit: VibeKit;
  private isPaused: boolean = false;

  constructor(config: VibeKitConfig) {
    this.vibeKit = new VibeKit(config);
  }

  async ensureActive() {
    if (this.isPaused) {
      await this.vibeKit.resume();
      this.isPaused = false;
      console.log("Sandbox auto-resumed");
    }
  }

  async generateCode(prompt: string) {
    // Auto-resume before generating code
    await this.ensureActive();
    return await this.vibeKit.generateCode(prompt, "code");
  }

  async pauseManually() {
    if (!this.isPaused) {
      await this.vibeKit.pause();
      this.isPaused = true;
      console.log("Sandbox paused manually");
    }
  }
}
```

### Scheduled Resume

```typescript
class ScheduledSandbox {
  private vibeKit: VibeKit;
  private resumeTimer: NodeJS.Timeout | null = null;

  constructor(config: VibeKitConfig) {
    this.vibeKit = new VibeKit(config);
  }

  async pauseWithScheduledResume(resumeInMinutes: number) {
    // Pause sandbox
    await this.vibeKit.pause();
    console.log(`Sandbox paused. Will resume in ${resumeInMinutes} minutes.`);

    // Schedule resume
    this.resumeTimer = setTimeout(async () => {
      try {
        await this.vibeKit.resume();
        console.log("Sandbox automatically resumed");
      } catch (error) {
        console.error("Failed to auto-resume sandbox:", error);
      }
    }, resumeInMinutes * 60 * 1000);
  }

  async resumeNow() {
    // Clear scheduled resume
    if (this.resumeTimer) {
      clearTimeout(this.resumeTimer);
      this.resumeTimer = null;
    }

    // Resume immediately
    await this.vibeKit.resume();
    console.log("Sandbox resumed immediately");
  }

  async cleanup() {
    if (this.resumeTimer) {
      clearTimeout(this.resumeTimer);
    }
    await this.vibeKit.kill();
  }
}
```

## Error handling

The method throws errors in the following cases:

### Agent Type Error
```typescript
// When using non-Codex agent
throw new Error("Sandbox management is only supported for the Codex agent");
```

### Initialization Error
```typescript
// When CodexAgent is not initialized
throw new Error("CodexAgent not initialized");
```

### Example Error Handling
```typescript
try {
  await vibeKit.resume();
} catch (error) {
  switch (true) {
    case error.message.includes("only supported for the Codex agent"):
      // Handle agent type mismatch
      console.error("This operation requires a Codex agent");
      break;
    
    case error.message.includes("not initialized"):
      // Handle initialization error
      console.error("Agent not properly initialized");
      break;
    
    default:
      // Handle other sandbox-related errors
      console.error("Sandbox resume failed:", error.message);
  }
}
```

## Use Cases

### Morning Startup Routine
Resume sandboxes at the start of the workday:

```typescript
class DailySandboxManager {
  private vibeKit: VibeKit;

  constructor(config: VibeKitConfig) {
    this.vibeKit = new VibeKit(config);
  }

  async morningStartup() {
    console.log("Starting daily sandbox routine...");
    
    try {
      await this.vibeKit.resume();
      console.log("âœ… Sandbox resumed for the day");
      
      // Run any initialization code
      await this.vibeKit.generateCode("echo 'Good morning! Sandbox is ready.'", "code");
      
    } catch (error) {
      console.error("âŒ Failed to start sandbox:", error);
      throw error;
    }
  }

  async eveningShutdown() {
    console.log("Ending daily sandbox routine...");
    await this.vibeKit.pause();
    console.log("âœ… Sandbox paused for the night");
  }
}
```

### On-Demand Resumption
Resume only when needed to save resources:

```typescript
class OnDemandSandbox {
  private vibeKit: VibeKit;
  private isActive: boolean = false;

  constructor(config: VibeKitConfig) {
    this.vibeKit = new VibeKit(config);
  }

  async processRequest(prompt: string) {
    if (!this.isActive) {
      console.log("Resuming sandbox for request...");
      await this.vibeKit.resume();
      this.isActive = true;
    }

    const response = await this.vibeKit.generateCode(prompt, "code");
    
    // Auto-pause after 30 seconds of inactivity
    setTimeout(async () => {
      if (this.isActive) {
        await this.vibeKit.pause();
        this.isActive = false;
        console.log("Sandbox auto-paused after inactivity");
      }
    }, 30000);

    return response;
  }
}
```

### Recovery from Breaks
Resume after planned breaks or maintenance:

```typescript
class MaintenanceAwareSandbox {
  private vibeKit: VibeKit;
  
  constructor(config: VibeKitConfig) {
    this.vibeKit = new VibeKit(config);
  }

  async pauseForMaintenance(durationMinutes: number) {
    await this.vibeKit.pause();
    console.log(`Sandbox paused for ${durationMinutes} minute maintenance window`);
    
    return new Promise((resolve) => {
      setTimeout(async () => {
        await this.vibeKit.resume();
        console.log("Maintenance complete. Sandbox resumed.");
        resolve(void 0);
      }, durationMinutes * 60 * 1000);
    });
  }

  async emergencyResume() {
    console.log("Emergency resume initiated...");
    await this.vibeKit.resume();
    console.log("Sandbox resumed for emergency operation");
  }
}
```

## State Restoration

<Info>
When a sandbox is resumed, all previously saved state is restored including:
- File system contents (exactly as they were when paused)
- Environment variables
- Working directory
- Previously installed packages
</Info>

## Performance Considerations

### Resume Time
- **Cold Resume**: First resume after a long pause may take 10-30 seconds
- **Warm Resume**: Subsequent resumes are typically faster (5-15 seconds)
- **State Check**: The sandbox performs internal state validation during resume

### Resource Usage
```typescript
// Monitor resume performance
const startTime = Date.now();
await vibeKit.resume();
const resumeTime = Date.now() - startTime;
console.log(`Sandbox resumed in ${resumeTime}ms`);
```

## Notes

- **State Continuity**: All sandbox state is preserved and restored exactly as it was when paused
- **Process Restoration**: Running processes are resumed from their paused state
- **Network Connections**: Some network connections may need to be re-established
- **File System**: All files and directories remain exactly as they were
- **Best Practice**: Always resume before attempting to generate new code on a paused sandbox
- **Automatic Resume**: Consider implementing automatic resume logic in your application flow 


================================================
FILE: docs/api-reference/run-tests.mdx
================================================
---
title: "runTests"
description: "Execute tests in the sandbox environment with automatic test runner detection"
---

## Overview

The `runTests` method executes tests in the sandbox environment and automatically detects the appropriate test runner (e.g., npm test, pytest, cargo test, etc.). This method supports both streaming and non-streaming execution modes.

## Method Signature

```typescript
async runTests({
  branch,
  history,
  callbacks,
}: {
  branch?: string;
  history?: Conversation[];
  callbacks?: VibeKitStreamCallbacks;
}): Promise<AgentResponse>
```

## Parameters

<ParamField path="branch" type="string" optional>
  The Git branch to run tests on. If not specified, tests will run on the current branch.
</ParamField>

<ParamField path="history" type="Conversation[]" optional>
  Optional conversation history to provide context for the test execution. This can help the agent understand previous interactions and make more informed decisions about test execution.
</ParamField>

<ParamField path="callbacks" type="VibeKitStreamCallbacks" optional>
  Optional callbacks for streaming updates during test execution.
  
  <Expandable title="VibeKitStreamCallbacks">
    <ParamField path="onUpdate" type="(message: string) => void" optional>
      Callback function that receives streaming updates during test execution.
    </ParamField>
    
    <ParamField path="onError" type="(error: string) => void" optional>
      Callback function that receives error messages during test execution.
    </ParamField>
  </Expandable>
</ParamField>

## Return Value

Returns a `Promise<AgentResponse>` containing the test execution results:

<ResponseField name="sandboxId" type="string">
  The ID of the sandbox where tests were executed
</ResponseField>

<ResponseField name="stdout" type="string">
  Standard output from the test execution
</ResponseField>

<ResponseField name="stderr" type="string">
  Standard error output from the test execution
</ResponseField>

<ResponseField name="exitCode" type="number">
  Exit code from the test execution (0 indicates success)
</ResponseField>

## Examples

### Basic Test Execution

```typescript
import { VibeKit } from 'vibekit';

const vibekit = new VibeKit({
  agent: {
    type: 'codex',
    model: {
      provider: 'openai',
      name: 'gpt-4',
      apiKey: process.env.OPENAI_API_KEY
    }
  },
  environment: 'e2b',
  sessionId: 'test-session'
});

// Run tests on current branch
const result = await vibekit.runTests({});

console.log('Tests completed with exit code:', result.exitCode);
console.log('Test output:', result.stdout);
```

### Run Tests on Specific Branch

```typescript
// Run tests on a specific branch
const result = await vibekit.runTests({
  branch: 'feature/new-functionality'
});

if (result.exitCode === 0) {
  console.log('All tests passed!');
} else {
  console.log('Some tests failed:', result.stderr);
}
```

### Streaming Test Execution

```typescript
// Run tests with streaming updates
const result = await vibekit.runTests({
  callbacks: {
    onUpdate: (message) => {
      console.log('Test update:', message);
    },
    onError: (error) => {
      console.error('Test error:', error);
    }
  }
});
```

### Run Tests with Context

```typescript
// Run tests with conversation history for context
const history = [
  {
    role: 'user',
    content: 'I just added a new authentication feature'
  },
  {
    role: 'assistant', 
    content: 'I understand. Let me run the tests to ensure everything works correctly.'
  }
];

const result = await vibekit.runTests({
  branch: 'feature/auth',
  history: history,
  callbacks: {
    onUpdate: (message) => {
      console.log(message);
    }
  }
});
```

## Test Runner Detection

The `runTests` method automatically detects and uses the appropriate test runner based on the project structure:

- **Node.js**: Runs `npm test` or `yarn test`
- **Python**: Runs `pytest`, `python -m unittest`, or `python -m pytest`
- **Rust**: Runs `cargo test`
- **Go**: Runs `go test`
- **And more**: Supports various other testing frameworks

## Error Handling

```typescript
try {
  const result = await vibekit.runTests({
    branch: 'main'
  });
  
  if (result.exitCode !== 0) {
    console.log('Tests failed with errors:', result.stderr);
  }
} catch (error) {
  console.error('Failed to run tests:', error.message);
}
```

## Notes

- The method requires an active sandbox environment
- Test execution is performed within the sandbox, ensuring a clean and isolated environment
- The agent will attempt to install dependencies if they're missing
- Streaming callbacks provide real-time feedback during test execution
- The method works with both Codex and Claude agents 


================================================
FILE: docs/api-reference/set-session.mdx
================================================
---
title: 'setSession'
description: 'Sets the session ID for the sandbox environment. This method allows you to restore or switch between existing sandbox sessions.'
---

## Method signature

```typescript
async setSession(sessionId: string): Promise<void>
```

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `sessionId` | `string` | Yes | The session ID to set for the sandbox environment. Must be a valid session identifier from a previously created session. |

## Return value

| Type | Description |
|------|-------------|
| `Promise<void>` | This method doesn't return a value but resolves when the session is successfully set |

## Examples

### Basic Usage

```typescript
const vibeKit = new VibeKit({
  agent: {
    type: "codex", // or "claude"
    model: {
      apiKey: "sk-proj-****"
    },
    mode: "code"
  },
  environment: {
    e2b: {
      apiKey: "e2b_****"
    }
  }
});

// Set a specific session ID
await vibeKit.setSession("session-abc123");

// Verify the session was set
const currentSession = await vibeKit.getSession();
console.log("Active session:", currentSession); // "session-abc123"
```

### Session Switching

```typescript
// Get the current session
const originalSession = await vibeKit.getSession();
console.log("Original session:", originalSession);

// Switch to a different session
await vibeKit.setSession("session-xyz789");

// Work in the new session
await vibeKit.generateCode("print('Working in new session')");

// Switch back to the original session
if (originalSession) {
  await vibeKit.setSession(originalSession);
  console.log("Switched back to original session");
}
```

### Session Restoration

```typescript
// Restore a session from storage
const savedSessionId = localStorage.getItem('vibekit-session');

if (savedSessionId) {
  try {
    await vibeKit.setSession(savedSessionId);
    console.log("Session restored successfully");
    
    // Continue work in the restored session
    await vibeKit.generateCode("# Continuing previous work");
  } catch (error) {
    console.error("Failed to restore session:", error);
    // Handle invalid or expired session
  }
}
```

### Multi-Project Workflow

```typescript
// Define session IDs for different projects
const sessions = {
  projectA: "session-project-a-123",
  projectB: "session-project-b-456",
  projectC: "session-project-c-789"
};

// Switch between projects
async function switchToProject(projectName: keyof typeof sessions) {
  const sessionId = sessions[projectName];
  
  await vibeKit.setSession(sessionId);
  console.log(`Switched to ${projectName} (${sessionId})`);
  
  // Generate project-specific code
  await vibeKit.generateCode(`# Working on ${projectName}`);
}

// Usage
await switchToProject('projectA');
await switchToProject('projectB');
```

## Error handling

The method throws errors in the following cases:

### Initialization Error  
- **Condition:** When the agent is not properly initialized
- **Error Message:** "Agent not initialized"
- **Solution:** Verify your configuration includes valid credentials and the agent is properly set up

### Invalid Session Error
- **Condition:** When the provided session ID is invalid or expired
- **Behavior:** May throw sandbox-specific errors or fail silently depending on the underlying implementation

```typescript
try {
  await vibeKit.setSession("invalid-session-id");
} catch (error) {
  if (error.message.includes('not initialized')) {
    console.error("Agent is not properly initialized");
  } else {
    console.error("Failed to set session:", error.message);
    // Handle invalid session ID
  }
}
```

## Configuration requirements

```typescript
// Correct configuration for session management
const config = {
  agent: {
    type: "codex", // or "claude"
    model: {
      apiKey: "your-api-key"
    },
    mode: "code"
  },
  environment: {
    e2b: {
      apiKey: "your-e2b-api-key" // For Codex agent
    }
    // Claude agent may have different environment requirements
  }
};
```

## Use cases

### Session Persistence Across App Restarts

```typescript
class SessionManager {
  private vibeKit: VibeKit;
  
  constructor(vibeKit: VibeKit) {
    this.vibeKit = vibeKit;
  }
  
  async saveCurrentSession(): Promise<void> {
    const sessionId = await this.vibeKit.getSession();
    if (sessionId) {
      localStorage.setItem('vibekit-session', sessionId);
    }
  }
  
  async restoreSession(): Promise<boolean> {
    const savedSession = localStorage.getItem('vibekit-session');
    if (savedSession) {
      try {
        await this.vibeKit.setSession(savedSession);
        return true;
      } catch (error) {
        console.error('Failed to restore session:', error);
        // Clean up invalid session
        localStorage.removeItem('vibekit-session');
      }
    }
    return false;
  }
}
```

### Multi-User Session Management

```typescript
class MultiUserSessionManager {
  private vibeKit: VibeKit;
  private userSessions = new Map<string, string>();
  
  constructor(vibeKit: VibeKit) {
    this.vibeKit = vibeKit;
  }
  
  async switchUser(userId: string): Promise<void> {
    const userSessionId = this.userSessions.get(userId);
    
    if (userSessionId) {
      // User has an existing session
      await this.vibeKit.setSession(userSessionId);
    } else {
      // Create new session for user
      await this.vibeKit.generateCode("# Starting new session");
      const newSessionId = await this.vibeKit.getSession();
      if (newSessionId) {
        this.userSessions.set(userId, newSessionId);
      }
    }
  }
  
  async getCurrentUserSession(): Promise<string | null> {
    return await this.vibeKit.getSession();
  }
}
```

### Project-Based Session Isolation

```typescript
interface ProjectSession {
  id: string;
  name: string;
  sessionId: string;
  lastAccessed: Date;
}

class ProjectManager {
  private vibeKit: VibeKit;
  private projects: ProjectSession[] = [];
  
  constructor(vibeKit: VibeKit) {
    this.vibeKit = vibeKit;
  }
  
  async switchToProject(projectId: string): Promise<void> {
    const project = this.projects.find(p => p.id === projectId);
    
    if (project) {
      await this.vibeKit.setSession(project.sessionId);
      project.lastAccessed = new Date();
      console.log(`Switched to project: ${project.name}`);
    } else {
      throw new Error(`Project ${projectId} not found`);
    }
  }
  
  async createProject(name: string): Promise<string> {
    // Create a new session for the project
    await this.vibeKit.generateCode(`# Project: ${name}`);
    const sessionId = await this.vibeKit.getSession();
    
    if (!sessionId) {
      throw new Error("Failed to create session for project");
    }
    
    const project: ProjectSession = {
      id: crypto.randomUUID(),
      name,
      sessionId,
      lastAccessed: new Date()
    };
    
    this.projects.push(project);
    return project.id;
  }
}
```

## Related methods

- [`getSession`](./get-session) - Retrieve the current session ID
- [`generateCode`](./generate-code) - Generate code (creates a session if none exists)

## Notes

- **Session Validation:** The method doesn't validate if the session ID exists or is accessible until subsequent operations
- **Session Switching:** You can switch between sessions at any time using this method
- **State Isolation:** Each session maintains its own sandbox state and file system
- **Cross-Agent Support:** This functionality works with both Codex and Claude agents
- **No Return Value:** The method resolves with `void` when successful
- **Immediate Effect:** The session change takes effect immediately for subsequent operations 


================================================
FILE: docs/app/globals.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@keyframes border-pulse {
  0%, 100% {
    border-color: rgb(34 197 94);
    box-shadow: 0 10px 15px -3px rgba(34, 197, 94, 0.25);
  }
  50% {
    border-color: rgba(34, 197, 94, 0.6);
    box-shadow: 0 10px 15px -3px rgba(34, 197, 94, 0.1);
  }
}

.animate-border-pulse {
  animation: border-pulse 2s ease-in-out infinite;
}



================================================
FILE: docs/app/layout.tsx
================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { ClerkProvider, SignedIn, SignedOut } from "@clerk/nextjs";
import { Toaster } from "sonner";

import { ConvexClientProvider } from "@/providers/convex";
import ConditionalLayout from "@/components/conditional-layout";

import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "VibeKit | Turn complex integrations into one-click experiences",
  description:
    "VibeKit Onboard turns complex integrations into one-click experiences â€” using a coding agent embedded directly in your docs.",
  openGraph: {
    images: ["/og-onboard.png"],
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <link rel="icon" href="/favicon.svg" />
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ClerkProvider>
          <ConvexClientProvider>
            <SignedIn>
              <ConditionalLayout>{children}</ConditionalLayout>
            </SignedIn>
            <SignedOut>
              <div className="flex flex-col h-screen bg-muted">{children}</div>
            </SignedOut>
          </ConvexClientProvider>
        </ClerkProvider>
        <Toaster position="bottom-right" />
      </body>
    </html>
  );
}



================================================
FILE: docs/app/(app)/client-page.tsx
================================================
"use client";

import { useQuery, useMutation } from "convex/react";
import Image from "next/image";
import { useState } from "react";
import { useUser } from "@clerk/nextjs";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { toast } from "sonner";
import { api } from "@/convex/_generated/api";
import { Loader2, Plus, Zap, Search } from "lucide-react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { ColorPicker } from "@/components/ui/color-picker";
import { FileUpload } from "@/components/ui/file-upload";
import { cn } from "@/lib/utils";

import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { format } from "date-fns";
import Link from "next/link";
import { useSidebar } from "@/components/navbar";
import { Doc } from "@/convex/_generated/dataModel";

const projectSchema = z.object({
  name: z
    .string()
    .min(1, "Project name is required")
    .max(100, "Project name must be less than 100 characters"),
  logo: z.string().optional(),
  primaryColor: z.string().optional(),
});

type ProjectFormValues = z.infer<typeof projectSchema>;

interface ClientPageProps {
  userId: string;
}

function CreateProjectModal({
  open,
  onOpenChange,
  userId,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  userId: string;
}) {
  const createProject = useMutation(api.projects.createProject);

  const form = useForm<ProjectFormValues>({
    resolver: zodResolver(projectSchema),
    defaultValues: {
      name: "",
      logo: undefined,
      primaryColor: "#3b82f6",
    },
  });

  const onSubmit = async (values: ProjectFormValues) => {
    try {
      await createProject({
        name: values.name,
        createdBy: userId,
        logo: values.logo,
        primaryColor: values.primaryColor,
      });
      toast.success("Project created successfully!");
      form.reset();
      onOpenChange(false);
    } catch (error) {
      toast.error("Failed to create project. Please try again.");
      console.error("Error creating project:", error);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="rounded-xl">
        <DialogHeader>
          <DialogTitle>Create a new project</DialogTitle>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Project Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Enter project name..." {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="logo"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Logo</FormLabel>
                  <FormControl>
                    <FileUpload value={field.value} onChange={field.onChange} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="primaryColor"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Primary Color</FormLabel>
                  <FormControl>
                    <ColorPicker
                      value={field.value}
                      onChange={field.onChange}
                      placeholder="#3b82f6"
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <div className="flex justify-end gap-2 pt-4">
              <Button
                type="button"
                variant="outline"
                onClick={() => onOpenChange(false)}
              >
                Cancel
              </Button>
              <Button type="submit" disabled={form.formState.isSubmitting}>
                {form.formState.isSubmitting && (
                  <Loader2 className="w-4 h-4 animate-spin" />
                )}
                {form.formState.isSubmitting ? "Creating..." : "Create Project"}
              </Button>
            </div>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

function ProjectListItem({ project }: { project: Doc<"project"> }) {
  const agents = useQuery(api.agents.getAgentsByProjectId, {
    projectId: project._id,
  });

  return (
    <Link
      href={`/projects/${project._id}`}
      key={project._id}
      passHref
      prefetch={true}
      className="border rounded-lg bg-background hover:border-muted-foreground/50"
    >
      <div className="rounded-t-lg h-[130px] flex items-center justify-center bg-sidebar border-b">
        {project.logo ? (
          <Image
            src={project.logo}
            alt={`${project.name} logo`}
            width={48}
            height={48}
            className="object-contain"
            unoptimized={true}
          />
        ) : (
          <Image src="/projects.svg" alt="Project" width={30} height={30} />
        )}
      </div>
      <p className="px-4 font-medium mt-2">{project.name}</p>
      <div className="px-4 flex items-center justify-between gap-2 mt-2 mb-4">
        <div className="flex items-center gap-1 text-sm text-muted-foreground">
          <Zap className="w-4 h-4" />{" "}
          <p className="text-sm">{agents?.length || 0}</p>
        </div>
        <p className="text-sm text-muted-foreground">
          {format(new Date(project._creationTime), "MMMM d, hh:mm a")}
        </p>
      </div>
    </Link>
  );
}
export default function ClientPage({ userId }: ClientPageProps) {
  const { sidebarOpen } = useSidebar();
  const [open, setOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const { user } = useUser();
  const projects = useQuery(api.projects.getProjectsByUserId, {
    userId: userId,
  });

  // Filter projects based on search query
  const filteredProjects = projects?.filter((project) =>
    project.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  return (
    <div
      className={cn(
        "flex-1 transition-all duration-300 ease-in-out border bg-background mt-12 mb-4 mr-5 rounded-2xl",
        sidebarOpen ? "ml-42" : "ml-14.5"
      )}
    >
      <div className="w-full p-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <p className="text-lg font-medium ml-2">Projects</p>
            {!user && (
              <Loader2 className="size-5 animate-spin text-muted-foreground" />
            )}
          </div>
          <div className="flex items-center gap-3">
            <div className="relative hidden md:block">
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4" />
              <Input
                placeholder="Search projects..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-10 w-64"
              />
            </div>
            <Button
              onClick={() => setOpen(true)}
              variant="secondary"
              className="mr-2"
            >
              <Plus className="w-4 h-4" />
              New Project
            </Button>
          </div>
        </div>
        {filteredProjects && filteredProjects.length === 0 && (
          <div className="flex flex-col items-center justify-center mt-[15%] py-12">
            <Image
              src="/projects.svg"
              alt="No projects"
              width={64}
              height={64}
              className="opacity-50 mb-4"
            />
            <h3 className="text-lg font-medium text-muted-foreground mb-2">
              No projects yet
            </h3>
            <p className="text-sm text-muted-foreground mb-4">
              Get started by creating your first project.
            </p>
          </div>
        )}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-6 gap-4 mt-4 px-3">
          {filteredProjects?.map((project) => (
            <ProjectListItem key={project._id} project={project} />
          ))}
        </div>
      </div>
      <CreateProjectModal open={open} onOpenChange={setOpen} userId={userId} />
    </div>
  );
}



================================================
FILE: docs/app/(app)/loading.tsx
================================================
"use client";
import { Loader2 } from "lucide-react";
import { useSidebar } from "@/components/navbar";
import { Skeleton } from "@/components/ui/skeleton";
import { cn } from "@/lib/utils";

export default function Loading() {
  const { sidebarOpen } = useSidebar();
  return (
    <div
      className={cn(
        "flex-1 transition-all duration-300 ease-in-out border bg-background mt-12 mb-4 mr-5 rounded-2xl",
        sidebarOpen ? "ml-42" : "ml-14.5"
      )}
    >
      <div className="w-full p-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <p className="text-lg font-medium ml-2">
              <Skeleton className="w-24 h-6" />
            </p>
          </div>
          <div className="flex items-center gap-3"></div>
        </div>
      </div>
      <div className="flex justify-center items-center mt-[25%]">
        <Loader2 className="size-5 animate-spin text-muted-foreground" />
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(app)/page.tsx
================================================
import { auth } from "@clerk/nextjs/server";
import ClientPage from "./client-page";
import { notFound } from "next/navigation";

export default async function Home() {
  const { userId } = await auth();

  if (!userId) {
    return notFound();
  }
  return <ClientPage userId={userId} />;
}



================================================
FILE: docs/app/(app)/auth/success/page.tsx
================================================
"use client";

import { useEffect } from "react";

export default function AuthSuccessPage() {
  useEffect(() => {
    // Close the popup and notify the parent window
    if (window.opener) {
      window.opener.postMessage({ type: "GITHUB_AUTH_SUCCESS" }, "*");
      window.close();
    } else {
      // If not in a popup, redirect to home
      window.location.href = "/";
    }
  }, []);

  return (
    <div className="flex items-center justify-center min-h-screen">
      <div className="text-center">
        <h1 className="text-2xl font-bold mb-4">Authentication Successful!</h1>
        <p className="text-muted-foreground">
          This window will close automatically...
        </p>
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(app)/billing/client-page.tsx
================================================
"use client";
import Link from "next/link";

import { useSidebar } from "@/components/navbar";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { Badge } from "@/components/ui/badge";
import { Settings2, Download, ChevronLeft, ChevronRight } from "lucide-react";
import type Stripe from "stripe";
import { useRouter, useSearchParams } from "next/navigation";

export default function BillingClientPage({
  portalUrl,
  productName,
  invoices,
  pagination,
}: {
  portalUrl: string;
  productName: string;
  invoices: Stripe.Invoice[];
  pagination: {
    currentPage: number;
    hasMore: boolean;
    limit: number;
  };
}) {
  const { sidebarOpen } = useSidebar();
  const router = useRouter();
  const searchParams = useSearchParams();

  const handlePageChange = (newPage: number) => {
    const params = new URLSearchParams(searchParams.toString());
    params.set("page", newPage.toString());
    router.push(`?${params.toString()}`);
  };
  return (
    <div
      className={cn(
        "flex-1 transition-all duration-300 ease-in-out border bg-background mt-12 mb-4 mr-5 rounded-2xl",
        sidebarOpen ? "ml-42" : "ml-14.5"
      )}
    >
      <div className="w-full p-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <p className="text-lg font-medium ml-2">Billing</p>
          </div>
        </div>
      </div>
      <div className="mt-6 px-2 max-w-2xl mx-auto w-full">
        <h2 className="text-lg font-medium mb-4">Current plan</h2>
        <div className="border rounded-lg p-4 flex items-center justify-between">
          <div className="flex flex-col gap-y-2">
            <div className="flex items-center gap-x-2">
              <p className="font-medium">{productName}</p>
              <Badge
                variant="secondary"
                className="bg-green-100 text-green-600 border-green-500"
              >
                Active
              </Badge>
            </div>
            <p>You are currently on the Free plan. </p>
          </div>
          <Link href={portalUrl} target="_blank">
            <Button variant="secondary">
              <Settings2 />
              Manage Subscription
            </Button>
          </Link>
        </div>

        {/* Invoices Section */}
        <div className="mt-8">
          <h2 className="text-lg font-medium mb-4">Invoices</h2>
          <div className="space-y-3">
            {invoices.length === 0 ? (
              <p className="text-gray-500">No invoices found.</p>
            ) : (
              invoices.map((invoice) => (
                <div
                  key={invoice.id}
                  className="border rounded-lg p-4 flex items-center justify-between"
                >
                  <div className="flex flex-col gap-y-1">
                    <div className="flex items-center gap-x-2">
                      <p className="font-medium">
                        {new Date(invoice.created * 1000).toLocaleDateString()}
                      </p>
                      <Badge
                        variant={
                          invoice.status === "paid" ? "default" : "destructive"
                        }
                        className={
                          invoice.status === "paid"
                            ? "bg-green-100 text-green-600 border-green-500"
                            : ""
                        }
                      >
                        {invoice.status}
                      </Badge>
                    </div>
                    <p className="text-sm text-gray-600">
                      ${(invoice.amount_paid / 100).toFixed(2)} - Invoice #
                      {invoice.number}
                    </p>
                  </div>
                  {invoice.invoice_pdf && (
                    <Link href={invoice.invoice_pdf} target="_blank">
                      <Button variant="secondary">
                        <Download className="size-4" />
                        Download
                      </Button>
                    </Link>
                  )}
                </div>
              ))
            )}
          </div>

          {/* Pagination Controls */}
          {(pagination.currentPage > 1 || pagination.hasMore) && (
            <div className="flex items-center justify-between mt-6 pt-4 border-t">
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handlePageChange(pagination.currentPage - 1)}
                  disabled={pagination.currentPage === 1}
                >
                  <ChevronLeft className="w-4 h-4 mr-1" />
                  Previous
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handlePageChange(pagination.currentPage + 1)}
                  disabled={!pagination.hasMore}
                >
                  Next
                  <ChevronRight className="w-4 h-4 ml-1" />
                </Button>
              </div>
              <div className="text-sm text-gray-600">
                Page {pagination.currentPage} â€¢ {invoices.length} invoices
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(app)/billing/page.tsx
================================================
import { Metadata } from "next";
import { auth } from "@clerk/nextjs/server";
import { notFound } from "next/navigation";
import { fetchQuery } from "convex/nextjs";
import { api } from "@/convex/_generated/api";
import { stripe } from "@/lib/stripe";
import BillingClientPage from "./client-page";

interface Props {
  searchParams: Promise<{ page?: string }>;
}

export const metadata: Metadata = {
  title: "Billing | VibeKit Onboard",
  description: "Update your billing settings",
};

export default async function BillingPage({ searchParams }: Props) {
  const { userId } = await auth();
  const { page: _page } = await searchParams;
  const page = parseInt(_page || "1");
  const limit = 10; // Invoices per page
  const organization = await fetchQuery(
    api.organizations.getOrganizationByUserId,
    {
      userId: userId!,
    }
  );

  if (!organization) return notFound();

  const subscription = await stripe.subscriptions.retrieve(
    organization.stripeSubscriptionId!
  );
  const product = await stripe.products.retrieve(
    subscription.items.data[0].price.product as string
  );

  // For proper pagination, we need to fetch more invoices to determine if there are more pages
  const invoicesResponse = await stripe.invoices.list({
    customer: organization.stripeCustomerId!,
    limit: limit + 1, // Fetch one extra to check if there are more
  });

  // Calculate pagination
  const hasMore = invoicesResponse.data.length > limit;
  const invoices = {
    data: invoicesResponse.data.slice(0, limit), // Remove the extra invoice
    has_more: hasMore,
  };
  const currentPage = page;

  const session = await stripe.billingPortal.sessions.create({
    customer: organization.stripeCustomerId!,
  });

  return (
    <BillingClientPage
      portalUrl={session.url!}
      productName={product.name!}
      invoices={invoices.data}
      pagination={{
        currentPage,
        hasMore,
        limit,
      }}
    />
  );
}



================================================
FILE: docs/app/(app)/profile/client-page.tsx
================================================
"use client";
import { Loader2 } from "lucide-react";
import { useUser } from "@clerk/nextjs";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { toast } from "sonner";
import { FileUpload } from "@/components/ui/file-upload";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";

import { useSidebar } from "@/components/navbar";
import { cn } from "@/lib/utils";
import { useEffect } from "react";

const profileSchema = z.object({
  firstName: z.string().min(1, "First name is required"),
  lastName: z.string().min(1, "Last name is required"),
  profileImage: z.string().optional(),
  email: z.string().optional(),
});

type ProfileFormValues = z.infer<typeof profileSchema>;

export default function ProfileClientPage() {
  const { sidebarOpen } = useSidebar();
  const { user } = useUser();

  const form = useForm<ProfileFormValues>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      firstName: user?.firstName || "",
      lastName: user?.lastName || "",
      profileImage: user?.imageUrl || "",
      email: user?.primaryEmailAddress?.emailAddress || "",
    },
  });

  // Update form values when user data is loaded
  useEffect(() => {
    if (user) {
      form.reset({
        firstName: user.firstName || "",
        lastName: user.lastName || "",
        profileImage: user.imageUrl || "",
        email: user.primaryEmailAddress?.emailAddress || "",
      });
    }
  }, [user, form]);

  const onSubmit = async (values: ProfileFormValues) => {
    try {
      await user?.update({
        firstName: values.firstName,
        lastName: values.lastName,
      });
      if (values.profileImage && values.profileImage.startsWith("data:image")) {
        await user?.setProfileImage({ file: values.profileImage });
      }
      toast.success("Profile updated successfully!");
    } catch (error) {
      toast.error("Failed to update profile. Please try again.");
      console.error("Error updating profile:", error);
    }
  };

  return (
    <div
      className={cn(
        "flex-1 transition-all duration-300 ease-in-out border bg-background mt-12 mb-4 mr-5 rounded-2xl",
        sidebarOpen ? "ml-42" : "ml-14.5"
      )}
    >
      <div className="w-full p-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <p className="text-lg font-medium ml-2">Profile</p>
            {!user && (
              <Loader2 className="size-5 animate-spin text-muted-foreground" />
            )}
          </div>
          <Button
            variant="secondary"
            onClick={form.handleSubmit(onSubmit)}
            disabled={form.formState.isSubmitting}
          >
            {form.formState.isSubmitting && (
              <Loader2 className="w-4 h-4 animate-spin mr-2" />
            )}
            Save
          </Button>
        </div>
        <div className="mt-6 px-2 max-w-2xl mx-auto w-full">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="profileImage"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Profile Image</FormLabel>
                    <FormControl>
                      <FileUpload
                        value={field.value}
                        onChange={field.onChange}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="firstName"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>First Name</FormLabel>
                    <FormControl>
                      <Input
                        placeholder="Enter your first name..."
                        className="w-full"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="lastName"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Last Name</FormLabel>
                    <FormControl>
                      <Input
                        placeholder="Enter your last name..."
                        {...field}
                        className="w-full"
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email</FormLabel>
                    <FormControl>
                      <Input
                        {...field}
                        value={field.value || ""}
                        disabled
                        className="w-full"
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </form>
          </Form>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(app)/profile/page.tsx
================================================
import { Metadata } from "next";
import ProfileClientPage from "./client-page";

export const metadata: Metadata = {
  title: "Profile | VibeKit Onboard",
  description: "Update your profile",
};

export default function ProfilePage() {
  return <ProfileClientPage />;
}



================================================
FILE: docs/app/(app)/projects/[id]/client-page.tsx
================================================
"use client";
import { ArrowLeft, Plus, Loader2 } from "lucide-react";
import { useRouter } from "next/navigation";
import { useState, useCallback } from "react";
import Link from "next/link";
import Image from "next/image";
import { useMutation, useQuery } from "convex/react";
import { format } from "date-fns";

import { api } from "@/convex/_generated/api";
import { Button } from "@/components/ui/button";
import { Doc } from "@/convex/_generated/dataModel";
import { cn } from "@/lib/utils";
import { useSidebar } from "@/components/navbar";

export default function ProjectClientPage({
  project,
  userId,
}: {
  project: Doc<"project">;
  userId: string;
}) {
  const { sidebarOpen } = useSidebar();
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const router = useRouter();
  const createAgent = useMutation(api.agents.createAgent);
  const agents = useQuery(api.agents.getAgentsByProjectId, {
    projectId: project._id,
  });

  const createNewAgent = useCallback(async () => {
    setIsLoading(true);
    const agent = await createAgent({
      name: "Untitled Agent",
      status: "INACTIVE",
      projectId: project._id,
      createdBy: userId,
    });

    router.push(`/projects/${project._id}/${agent}`);
    setIsLoading(false);
  }, [createAgent, project._id, userId, router]);

  return (
    <div
      className={cn(
        "flex-1 transition-all duration-300 ease-in-out border bg-background mt-12 mb-4 mr-5 rounded-2xl",
        sidebarOpen ? "ml-42" : "ml-14.5"
      )}
    >
      <div className="w-full p-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Link passHref href="/">
              <Button variant="ghost" size="icon">
                <ArrowLeft />
              </Button>
            </Link>
            <div className="flex items-center gap-2">
              <div className="size-9 rounded-lg flex items-center justify-center bg-sidebar">
                {project.logo ? (
                  <Image
                    src={project.logo}
                    alt={`${project.name} logo`}
                    width={22}
                    height={22}
                    className="object-contain"
                    unoptimized={true}
                  />
                ) : (
                  <Image
                    src="/projects.svg"
                    alt="Project"
                    width={20}
                    height={20}
                  />
                )}
              </div>
              <p className="text-lg font-medium">{project.name}</p>
            </div>
          </div>
          <Button onClick={createNewAgent} variant="secondary" className="mr-2">
            {isLoading ? <Loader2 className="size-4 animate-spin" /> : <Plus />}{" "}
            New agent
          </Button>
        </div>

        {/* Agents Grid */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-6 gap-4 mt-6 px-3">
          {agents?.map((agent) => (
            <Link
              href={`/projects/${project._id}/${agent._id}`}
              key={agent._id}
              passHref
              prefetch={true}
              className="border rounded-lg bg-background hover:border-muted-foreground/50"
            >
              <div className="rounded-t-lg h-[130px] flex items-center justify-center bg-sidebar border-b">
                {agent.logo ? (
                  <Image
                    src={agent.logo}
                    alt={`${agent.name} logo`}
                    width={48}
                    height={48}
                    className="object-contain"
                    unoptimized={true}
                  />
                ) : (
                  <Image
                    src="/projects.svg"
                    alt="Agent"
                    width={30}
                    height={30}
                  />
                )}
              </div>
              <p className="px-4 font-medium mt-2">{agent.name}</p>
              <div className="px-4 flex items-center justify-between gap-2 mt-2 mb-4">
                {/* <div className="flex items-center gap-1 text-sm text-muted-foreground">
                  <div
                    className={cn(
                      "size-2    rounded-full",
                      agent.status === "ACTIVE" ? "bg-blue-500" : "bg-gray-500"
                    )}
                  />
                  <p className="text-sm">
                    {agent.status.charAt(0).toUpperCase() +
                      agent.status.slice(1).toLowerCase()}
                  </p>
                </div> */}
                <p className="text-sm text-muted-foreground">
                  {format(new Date(agent._creationTime), "MMM d, hh:mm a")}
                </p>
              </div>
            </Link>
          ))}
        </div>

        {/* Empty State */}
        {agents && agents.length === 0 && (
          <div className="flex flex-col items-center justify-center mt-[15%] py-12">
            <Image
              src="/projects.svg"
              alt="No agents"
              width={64}
              height={64}
              className="opacity-50 mb-4"
            />
            <h3 className="text-lg font-medium text-muted-foreground mb-2">
              No agents yet
            </h3>
            <p className="text-sm text-muted-foreground mb-4">
              Get started by creating your first agent for this project.
            </p>
          </div>
        )}
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(app)/projects/[id]/page.tsx
================================================
import { fetchQuery } from "convex/nextjs";
import { notFound } from "next/navigation";
import { Metadata } from "next";
import { auth } from "@clerk/nextjs/server";

import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";
import ProjectClientPage from "./client-page";

interface Props {
  params: Promise<{ id: string }>;
}

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  // read route params
  const id = (await params).id;

  const project = await fetchQuery(api.projects.getProject, {
    id: id as Id<"project">,
  });

  if (!project) {
    return {
      title: "Project Not Found | VibeKit",
      description: "The requested project could not be found",
    };
  }

  return {
    title: `${project.name || "Untitled Project"} | VibeKit`,
    description: project.name,
  };
}

export default async function ProjectPage({ params }: Props) {
  const { id } = await params;
  const { userId } = await auth();

  if (!id || !userId) {
    return notFound();
  }

  const project = await fetchQuery(api.projects.getProject, {
    id: id as Id<"project">,
  });

  if (!project) {
    return notFound();
  }

  return <ProjectClientPage project={project} userId={userId} />;
}



================================================
FILE: docs/app/(app)/projects/[id]/[agentId]/client-page.tsx
================================================
"use client";

import {
  ArrowLeft,
  ChevronRight,
  Edit3,
  Loader2,
  Trash2,
  Box,
  Link2,
} from "lucide-react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import Image from "next/image";
import { useState, useRef, useEffect, useCallback } from "react";
import { useMutation } from "convex/react";

import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { api } from "@/convex/_generated/api";
import AgentDetails from "./_components/agent-details";
import { Doc } from "@/convex/_generated/dataModel";
import { cn } from "@/lib/utils";
import { useSidebar } from "@/components/navbar";
import { Button } from "@/components/ui/button";
import Preview from "./_components/preview";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import SDK from "./_components/sdk";
import Mintlify from "./_components/mintlify";

interface Props {
  agent: Doc<"agent">;
  project: Doc<"project">;
}

export default function AgentClientPage({ agent, project }: Props) {
  const [unsavedChanges, setUnsavedChanges] = useState<boolean>(false);
  const router = useRouter();
  const { sidebarOpen } = useSidebar();
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [formFields, setFormFields] = useState<
    Record<string, string | boolean>
  >({});
  const [isEditingName, setIsEditingName] = useState(false);
  const [editedName, setEditedName] = useState(agent.name);
  const [isHovering, setIsHovering] = useState(false);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);
  const updateAgentName = useMutation(api.agents.updateAgentName);
  const updateAgent = useMutation(api.agents.updateAgent);
  const updateProject = useMutation(api.projects.updateProject);
  const deleteAgent = useMutation(api.agents.deleteAgent);

  useEffect(() => {
    if (isEditingName && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditingName]);

  const handleNameEdit = () => {
    setIsEditingName(true);
  };

  const handleNameSave = async () => {
    if (editedName.trim() && editedName !== agent.name) {
      try {
        await updateAgentName({
          id: agent._id,
          name: editedName.trim(),
        });
        // Refresh the page data to get the updated agent name
        router.refresh();
      } catch (error) {
        console.error("Failed to update agent name:", error);
        // Revert to original name on error
        setEditedName(agent.name);
      }
    }
    setIsEditingName(false);
    setIsHovering(false);
  };

  const handleNameCancel = () => {
    setEditedName(agent.name);
    setIsEditingName(false);
    setIsHovering(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      handleNameSave();
    } else if (e.key === "Escape") {
      handleNameCancel();
    }
  };

  const handleSave = useCallback(
    async (additionalFields?: Record<string, string | boolean>) => {
      setIsSaving(true);

      try {
        // Merge current formFields with any additional fields passed in
        const allFields = { ...formFields, ...additionalFields };

        // Separate GitHub fields for project vs agent fields
        const githubFields: Record<string, string> = {};
        const agentFields: Record<string, string | boolean> = {};

        Object.entries(allFields).forEach(([key, value]) => {
          if (key === "githubClientId" || key === "githubClientSecret") {
            githubFields[key] = value as string;
          } else {
            agentFields[key] =
              typeof value === "string" &&
              (value === "true" || value === "false")
                ? value === "true"
                : value;
          }
        });

        // Update project with GitHub fields if any exist
        if (Object.keys(githubFields).length > 0) {
          await updateProject({
            id: project._id,
            name: project.name,
            logo: project.logo,
            primaryColor: project.primaryColor,
            ...githubFields,
          });
        }

        // Update agent with remaining fields
        if (Object.keys(agentFields).length > 0) {
          await updateAgent({
            id: agent._id,
            name: editedName,
            ...agentFields,
          });
        }
      } finally {
        setIsSaving(false);
        setUnsavedChanges(false);
        router.refresh();
      }
    },
    [formFields, agent, project, updateAgent, updateProject, router, editedName]
  );

  const handleSaveClick = () => handleSave();

  const handleDelete = async () => {
    setIsDeleting(true);
    try {
      await deleteAgent({ id: agent._id });
      router.push(`/projects/${project._id}`);
    } catch (error) {
      console.error("Failed to delete agent:", error);
    } finally {
      setIsDeleting(false);
      setShowDeleteModal(false);
    }
  };

  return (
    <div
      className={cn(
        "flex-1 transition-all duration-300 ease-in-out grid grid-cols-1 md:grid-cols-4 mt-12 mb-4 mr-5 rounded-2xl",
        sidebarOpen ? "ml-42" : "ml-14.5"
      )}
    >
      <div className="flex flex-col col-span-2 rounded-xl border bg-background">
        <div className="w-full p-3">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Link passHref href={`/projects/${agent.projectId}`}>
                <Button variant="ghost" size="icon">
                  <ArrowLeft />
                </Button>
              </Link>
              <Link
                passHref
                href={`/projects/${agent.projectId}`}
                className="hover:opacity-50 transition-all duration-300"
              >
                <div className="flex items-center gap-2">
                  <div className="size-9 rounded-lg flex items-center justify-center bg-sidebar ">
                    {project.logo ? (
                      <Image
                        src={project.logo}
                        alt={`${project.name} logo`}
                        width={22}
                        height={22}
                        className="object-contain"
                        unoptimized={true}
                      />
                    ) : (
                      <Image
                        src="/projects.svg"
                        alt="Project"
                        width={20}
                        height={20}
                      />
                    )}
                  </div>
                  <p className="text-lg font-medium">{project.name}</p>
                </div>
              </Link>
              <ChevronRight className="text-muted-foreground/50" />
              <div className="flex items-center gap-2 -ml-2">
                {isEditingName ? (
                  <div className="flex items-center gap-1 rounded px-2 py-1">
                    <input
                      ref={inputRef}
                      type="text"
                      value={editedName}
                      onChange={(e) => setEditedName(e.target.value)}
                      onBlur={handleNameSave}
                      onKeyDown={handleKeyDown}
                      className="text-lg font-medium bg-transparent focus:outline-none border-none outline-none"
                    />
                  </div>
                ) : (
                  <div
                    className={cn(
                      "flex items-center gap-1 cursor-pointer rounded px-2 py-1 transition-all duration-200",
                      isHovering && "bg-muted"
                    )}
                    onMouseEnter={() => setIsHovering(true)}
                    onMouseLeave={() => setIsHovering(false)}
                    onClick={handleNameEdit}
                  >
                    <p className="text-lg font-medium">{editedName}</p>
                    {isHovering && (
                      <Edit3 className="h-4 w-4 text-muted-foreground" />
                    )}
                  </div>
                )}
              </div>
            </div>
            <div className="flex items-center gap-4 mr-2">
              {unsavedChanges && (
                <div className="flex items-center gap-2">
                  <div className="size-2 rounded-full bg-orange-300" />
                  <p className="text-sm text-muted-foreground">
                    Unsaved changes
                  </p>
                </div>
              )}
              <div className="flex items-center gap-2">
                <Button
                  variant="secondary"
                  size="icon"
                  onClick={() => setShowDeleteModal(true)}
                >
                  <Trash2 className="size-4" />
                </Button>
                <Button variant="secondary" onClick={handleSaveClick}>
                  {isSaving && <Loader2 className="size-4 animate-spin" />} Save
                </Button>
              </div>
            </div>
          </div>
        </div>
        <div className="px-6 flex-1">
          <AgentDetails
            agent={agent}
            project={project}
            onChange={(value) => {
              if (
                value.key === "systemPrompt" ||
                value.key === "githubClientId" ||
                value.key === "githubClientSecret" ||
                value.key === "privacyPolicy" ||
                value.key === "termsOfService"
              ) {
                setUnsavedChanges(true);
                setFormFields((prev) => ({
                  ...prev,
                  [value.key]: value.value,
                }));

                return;
              }

              setFormFields((prev) => ({
                ...prev,
                [value.key]: value.value,
              }));

              // Pass the new field directly to avoid race condition with state update
              handleSave({ [value.key]: value.value });
            }}
          />
        </div>
      </div>
      <div className="h-full col-span-2">
        <Tabs defaultValue="preview" className="w-full h-full">
          <TabsList className="mx-auto w-fit bg-sidebar">
            <TabsTrigger
              value="preview"
              className="text-md flex items-center gap-1 w-fit"
            >
              <Link2 className="h-4 w-4 text-muted-foreground" />
              Link
            </TabsTrigger>
            <TabsTrigger
              value="sdk"
              className="text-md flex items-center gap-1 w-fit"
            >
              <Box className="h-4 w-4 text-muted-foreground" />
              SDK
            </TabsTrigger>
            <TabsTrigger
              value="mintlify"
              className="text-md flex items-center gap-1 w-[140px]"
            >
              <Image
                src="/mintlify.svg"
                alt="Mintlify"
                width={15}
                height={15}
              />
              Mintlify
            </TabsTrigger>
          </TabsList>
          <TabsContent value="preview" className="w-full h-full">
            <Preview agent={agent} />
          </TabsContent>
          <TabsContent value="mintlify" className="w-full h-full">
            <Mintlify agent={agent} />
          </TabsContent>
          <TabsContent value="sdk" className="w-full h-full">
            <div className="max-w-3xl w-full mx-auto h-full flex items-center justify-center">
              <SDK agent={agent} />
            </div>
          </TabsContent>
        </Tabs>
      </div>

      {/* Delete Confirmation Modal */}
      <Dialog open={showDeleteModal} onOpenChange={setShowDeleteModal}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Delete Agent</DialogTitle>
            <DialogDescription>
              Are you sure you want to delete &ldquo;{agent.name}&rdquo;? This
              action cannot be undone.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setShowDeleteModal(false)}
              disabled={isDeleting}
            >
              Cancel
            </Button>
            <Button onClick={handleDelete} disabled={isDeleting}>
              {isDeleting && <Loader2 className="size-4 animate-spin mr-2" />}
              {isDeleting ? "Deleting..." : "Delete"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}



================================================
FILE: docs/app/(app)/projects/[id]/[agentId]/loading.tsx
================================================
"use client";
import { Loader2 } from "lucide-react";
import { useSidebar } from "@/components/navbar";
import { Skeleton } from "@/components/ui/skeleton";
import { cn } from "@/lib/utils";

export default function Loading() {
  const { sidebarOpen } = useSidebar();
  return (
    <div
      className={cn(
        "flex-1 transition-all duration-300 ease-in-out border bg-background mt-12 mb-4 mr-5 rounded-2xl",
        sidebarOpen ? "ml-42" : "ml-14.5"
      )}
    >
      <div className="w-full p-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Skeleton className="w-24 h-6 ml-2" />
          </div>
          <div className="flex items-center gap-3"></div>
        </div>
      </div>
      <div className="flex justify-center items-center mt-[25%]">
        <Loader2 className="size-5 animate-spin text-muted-foreground" />
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(app)/projects/[id]/[agentId]/page.tsx
================================================
import { fetchQuery } from "convex/nextjs";
import { notFound } from "next/navigation";
import { Metadata } from "next";
import { auth } from "@clerk/nextjs/server";

import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";
import AgentClientPage from "./client-page";

interface Props {
  params: Promise<{ agentId: string }>;
}

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  // read route params
  const id = (await params).agentId;

  const agent = await fetchQuery(api.agents.getAgent, {
    id: id as Id<"agent">,
  });

  if (!agent) {
    return {
      title: "Agent Not Found | VibeKit",
      description: "The requested agent could not be found",
    };
  }

  return {
    title: `${agent.name || "Untitled Agent"} | VibeKit`,
    description: agent.name,
  };
}

export default async function ProjectPage({ params }: Props) {
  const { agentId } = await params;
  const { userId } = await auth();

  if (!agentId || !userId) {
    return notFound();
  }

  const agent = await fetchQuery(api.agents.getAgent, {
    id: agentId as Id<"agent">,
  });

  if (!agent) {
    return notFound();
  }

  const project = await fetchQuery(api.projects.getProject, {
    id: agent.projectId as Id<"project">,
  });

  return <AgentClientPage agent={agent} project={project!} />;
}



================================================
FILE: docs/app/(app)/projects/[id]/[agentId]/_components/agent-details.tsx
================================================
"use client";
import { useState } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Palette, Settings2, Sparkles } from "lucide-react";
import Prompt from "./prompt";
import { Doc } from "@/convex/_generated/dataModel";
import Appearance from "./appearance";
import Settings from "./settings";
import { ScrollArea } from "@/components/ui/scroll-area";
import { generatePromptFromUrl } from "@/app/actions/prompt";

interface Props {
  agent: Doc<"agent">;
  project: Doc<"project">;
  onChange: ({ key, value }: { key: string; value: string | boolean }) => void;
}

export default function AgentDetails({ agent, project, onChange }: Props) {
  const [isImporting, setIsImporting] = useState(false);
  const [promptValue, setPromptValue] = useState(
    (agent.systemPrompt as string) || ""
  );

  const handleImportFromUrl = async (url: string) => {
    setIsImporting(true);
    try {
      const content = await generatePromptFromUrl(url);
      setPromptValue(content);
      onChange({ key: "systemPrompt", value: content });
    } catch (error) {
      console.error("Failed to import from URL:", error);
      // TODO: Add proper error handling/toast notification
    } finally {
      setIsImporting(false);
    }
  };

  const handlePromptChange = (value: string) => {
    setPromptValue(value);
    onChange({ key: "systemPrompt", value });
  };

  return (
    <Tabs defaultValue="prompt" className="w-full h-full">
      <TabsList>
        <TabsTrigger value="prompt" className="text-md flex items-center gap-1">
          <Sparkles className="w-4 h-4 text-muted-foreground" />
          Prompt
        </TabsTrigger>
        <TabsTrigger
          value="appearance"
          className="text-md flex items-center gap-1"
        >
          <Palette className="w-4 h-4 text-muted-foreground" />
          Appearance
        </TabsTrigger>
        <TabsTrigger value="github" className="text-md flex items-center gap-1">
          <Settings2 className="w-4 h-4 text-muted-foreground" />
          Settings
        </TabsTrigger>
      </TabsList>
      <TabsContent value="prompt" className="w-full h-full">
        <Prompt
          agent={agent}
          onChange={handlePromptChange}
          onImportFromUrl={handleImportFromUrl}
          isImporting={isImporting}
          promptValue={promptValue}
        />
      </TabsContent>
      <TabsContent value="appearance" className="w-full overflow-hidden">
        <ScrollArea className="h-full">
          <div className="h-[calc(100vh-250px)]">
            <Appearance agent={agent} project={project} onChange={onChange} />
          </div>
        </ScrollArea>
      </TabsContent>
      <TabsContent value="github" className="w-full h-full">
        <Settings agent={agent} project={project} onChange={onChange} />
      </TabsContent>
    </Tabs>
  );
}



================================================
FILE: docs/app/(app)/projects/[id]/[agentId]/_components/appearance.tsx
================================================
"use client";
import { Doc } from "@/convex/_generated/dataModel";
import { Input } from "@/components/ui/input";
import { FileUpload } from "@/components/ui/file-upload";
import { ColorPicker } from "@/components/ui/color-picker";
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from "@/components/ui/form";
import { useForm } from "react-hook-form";
import { Textarea } from "@/components/ui/textarea";
import { siteConfig } from "@/config";
import { Switch } from "@/components/ui/switch";

interface Props {
  agent: Doc<"agent">;
  project: Doc<"project">;
  onChange: ({ key, value }: { key: string; value: string | boolean }) => void;
}

interface AppearanceFormValues {
  logo?: string;
  buttonText?: string;
  headlineText?: string;
  primaryColor?: string;
  buttonColor?: string;
  descriptionText?: string;
  showButtonLogo?: boolean;
}

export default function Appearance({ agent, project, onChange }: Props) {
  const form = useForm<AppearanceFormValues>({
    defaultValues: {
      logo: agent.logo || project.logo || "",
      buttonText: agent.buttonText || siteConfig.defaultWidgetValues.buttonText,
      headlineText:
        agent.headlineText || siteConfig.defaultWidgetValues.headlineText,
      primaryColor: agent.primaryColor || project.primaryColor,

      buttonColor: agent.buttonColor || "#3b82f6",
      descriptionText:
        agent.descriptionText || siteConfig.defaultWidgetValues.descriptionText,
      showButtonLogo: agent.showButtonLogo ?? true,
    },
  });

  // Pass changes up via onChange
  const handleFieldChange = (
    key: keyof AppearanceFormValues,
    value: string | boolean
  ) => {
    form.setValue(key, value);
    onChange({
      key,
      value: typeof value === "boolean" ? value : String(value),
    });
  };

  const description = form.watch("descriptionText") || "";

  return (
    <Form {...form}>
      <form className="mt-5 flex flex-col gap-6 w-full">
        <FormField
          control={form.control}
          name="logo"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Logo</FormLabel>
              <FormControl>
                <FileUpload
                  value={field.value}
                  onChange={(val) => handleFieldChange("logo", val || "")}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="headlineText"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Headline Text</FormLabel>
              <FormControl>
                <Input
                  className="w-1/2"
                  placeholder="Enter headline..."
                  {...field}
                  onChange={(e) =>
                    handleFieldChange("headlineText", e.target.value)
                  }
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="buttonText"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Button Text</FormLabel>
              <FormControl>
                <Input
                  placeholder="Enter button text..."
                  {...field}
                  className="w-1/2 placeholder:text-md"
                  onChange={(e) =>
                    handleFieldChange("buttonText", e.target.value)
                  }
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="showButtonLogo"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <div className="flex items-center gap-2">
                  <FormLabel>Button Logo</FormLabel>
                  <Switch
                    checked={field.value}
                    onCheckedChange={(checked: boolean) =>
                      handleFieldChange("showButtonLogo", checked)
                    }
                  />
                </div>
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="buttonColor"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Button Color</FormLabel>
              <FormControl>
                <ColorPicker
                  value={field.value}
                  onChange={(val) => handleFieldChange("buttonColor", val)}
                  placeholder="#3b82f6"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="primaryColor"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Background Color</FormLabel>
              <FormControl>
                <ColorPicker
                  value={field.value}
                  onChange={(val) => handleFieldChange("primaryColor", val)}
                  placeholder="#3b82f6"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="descriptionText"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Textarea
                  maxLength={200}
                  className="w-full min-h-[80px] rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-xs outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] resize-none"
                  placeholder="Enter a description (max 200 characters)"
                  value={field.value}
                  onChange={(e) => {
                    handleFieldChange("descriptionText", e.target.value);
                    field.onChange(e);
                  }}
                />
              </FormControl>
              <div className="flex justify-end mt-1">
                <span className="text-xs text-muted-foreground">
                  {description.length}/200
                </span>
              </div>
              <FormMessage />
            </FormItem>
          )}
        />
      </form>
    </Form>
  );
}



================================================
FILE: docs/app/(app)/projects/[id]/[agentId]/_components/mintlify.tsx
================================================
"use client";
import { Check, Copy, Download } from "lucide-react";
import { useCopyToClipboard } from "usehooks-ts";
import { useState } from "react";

import { Doc } from "@/convex/_generated/dataModel";
import {
  CodeBlock,
  CodeBlockGroup,
  CodeBlockCode,
} from "@/components/code-block";
import { Button } from "@/components/ui/button";

export default function Mintlify({ agent }: { agent: Doc<"agent"> }) {
  const [, copy] = useCopyToClipboard();
  const [copiedText, setCopiedText] = useState<boolean>(false);

  const copyToClipboard = (text: string) => {
    copy(text);
    setCopiedText(true);
    setTimeout(() => setCopiedText(false), 2000);
  };

  const handleDownload = () => {
    const link = document.createElement("a");
    link.href = "/vibekit.js";
    link.download = "vibekit.js";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const code = `// use className prop to style the button with tailwindcss

<div className="text-center flex justify-center">
  <button 
    id="vibekit-button" 
    data-vibekit-token="${agent._id}"
    className="bg-black text-white"
  >
    Add To My App
  </button>
</div>`;

  return (
    <div className="max-w-xl w-full mx-auto flex flex-col items-center justify-center h-full">
      <div className="max-w-lg w-full bg-background border rounded-2xl p-4 pb-4 mb-4 relative">
        <div>
          <h4 className="font-medium mb-2">Step 1.</h4>
          <p className="text-sm text-muted-foreground mb-3">
            Download and add vibekit.js in the root of your mintlify docs.
          </p>

          <Button variant="outline" onClick={handleDownload} className="w-full">
            <Download className="w-4 h-4" />
            Download vibekit.js
          </Button>
        </div>
      </div>

      <div className="max-w-lg w-full bg-background border rounded-2xl p-4 pb-4 mb-4 relative">
        <div>
          <h4 className="font-medium mb-2">Step 2.</h4>
          <p className="text-sm text-muted-foreground mb-3">
            Add the following code:
          </p>
          <CodeBlock>
            <CodeBlockGroup className="border-border border-b py-2 pr-2 pl-4">
              <div className="flex items-center gap-2">index.mdx</div>
              <Button
                variant="ghost"
                size="icon"
                className="h-8 w-8"
                onClick={() => copyToClipboard(code)}
              >
                {copiedText ? (
                  <Check className="h-4 w-4 text-green-500" />
                ) : (
                  <Copy className="h-4 w-4" />
                )}
              </Button>
            </CodeBlockGroup>
            <CodeBlockCode code={code} language="html" />
          </CodeBlock>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(app)/projects/[id]/[agentId]/_components/preview.tsx
================================================
"use client";
import { Info, Copy, Check } from "lucide-react";
import { useCopyToClipboard } from "usehooks-ts";
import { useState } from "react";

import { Button } from "@/components/ui/button";
import { Doc } from "@/convex/_generated/dataModel";
import { siteConfig } from "@/config";

interface Props {
  agent: Doc<"agent">;
}

export default function Preview({ agent }: Props) {
  const [, copy] = useCopyToClipboard();
  const [isCopied, setIsCopied] = useState(false);

  const agentUrl = `${siteConfig.baseUrl}/embed/${agent._id}`;

  const handleCopy = async () => {
    try {
      await copy(agentUrl);
      setIsCopied(true);
      setTimeout(() => setIsCopied(false), 2000); // Reset after 2 seconds
    } catch (error) {
      console.error("Failed to copy:", error);
    }
  };

  return (
    <div className=" w-full mx-auto flex flex-col items-center justify-center h-full">
      <div className="w-full bg-background overflow-hidden mb-4 relative">
        <iframe
          src={agentUrl}
          className="w-full h-[800px] border-0"
          title="Widget Preview"
          sandbox="allow-scripts allow-same-origin allow-forms"
        />
      </div>
      <div className="w-full max-w-lg bg-background border rounded-lg py-3 px-3 mb-4 relative flex items-center justify-between">
        <p className="text-muted-foreground text-sm">{agentUrl}</p>
        <Button
          variant="outline"
          size="icon"
          onClick={handleCopy}
          className="ml-2 absolute right-1"
        >
          {isCopied ? (
            <Check className="w-4 h-4 text-green-500" />
          ) : (
            <Copy className="w-4 h-4" />
          )}
        </Button>
      </div>
      <div className="flex items-center gap-2 mt-10">
        <Info className="w-4 h-4 text-muted-foreground" />
        <p className="text-center text-sm text-muted-foreground">
          Embed this url into an iframe or use the direct link.
        </p>
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(app)/projects/[id]/[agentId]/_components/prompt.tsx
================================================
"use client";
import { useState, useEffect } from "react";
import { InfoIcon, Loader2, Sparkles } from "lucide-react";

import { MarkdownEditor } from "@/components/markdown-editor";
import { Doc } from "@/convex/_generated/dataModel";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

interface Props {
  agent: Doc<"agent">;
  onChange: (value: string) => void;
  onImportFromUrl: (url: string) => Promise<void>;
  isImporting: boolean;
  promptValue: string;
}

export default function Prompt({
  agent,
  onChange,
  onImportFromUrl,
  isImporting,
  promptValue,
}: Props) {
  const [systemPrompt, setSystemPrompt] = useState(
    promptValue ||
      (agent.systemPrompt as string) ||
      `## ADD YOUR DOCUMENTATION AND OTHER INSTRUCTIONS HERE`
  );
  const [importUrl, setImportUrl] = useState("");

  useEffect(() => {
    if (promptValue) {
      setSystemPrompt(promptValue);
    } else if (agent.systemPrompt) {
      setSystemPrompt(agent.systemPrompt as string);
    }
  }, [agent.systemPrompt, promptValue]);

  const handleImportClick = async () => {
    if (!importUrl.trim()) return;

    await onImportFromUrl(importUrl);
    setImportUrl("");
  };

  return (
    <div className="flex flex-col h-full space-between space-y-4 pb-8 pt-4 max-h-[calc(100vh-290px)]">
      <div className="bg-muted border rounded-lg p-4 flex-shrink-0">
        <div className="flex items-start space-x-3">
          <InfoIcon className="size-4 mt-0.5 text-blue-600 flex-shrink-0" />
          <div>
            <p className="text-sm">
              Include comprehensive SDK/API documentation, authentication
              details, and usage examples.
            </p>
          </div>
        </div>
      </div>

      <div className="flex gap-2 flex-shrink-0">
        <Input
          placeholder="Import from URL..."
          value={importUrl}
          onChange={(e) => setImportUrl(e.target.value)}
          className="flex-1"
        />
        <Button
          onClick={handleImportClick}
          disabled={!importUrl.trim() || isImporting}
          variant="outline"
          size="default"
        >
          {isImporting ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Sparkles className="h-4 w-4" />
          )}
          Generate
        </Button>
      </div>

      <div className="flex flex-col flex-1 items-center rounded-lg border justify-between overflow-hidden">
        <MarkdownEditor
          value={systemPrompt}
          onChange={(value) => {
            setSystemPrompt(value);
            onChange(value);
          }}
          className="h-w-full h-full" // TODO: Implement system prompt update functionality
        />
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(app)/projects/[id]/[agentId]/_components/sdk.tsx
================================================
"use client";
import { Check, Copy } from "lucide-react";
import { useCopyToClipboard } from "usehooks-ts";
import { useState } from "react";

import { Doc } from "@/convex/_generated/dataModel";
import {
  CodeBlock,
  CodeBlockGroup,
  CodeBlockCode,
} from "@/components/code-block";
import { Button } from "@/components/ui/button";

export default function SDK({ agent }: { agent: Doc<"agent"> }) {
  const [, copy] = useCopyToClipboard();
  const [copiedText, setCopiedText] = useState<boolean>(false);

  const copyToClipboard = (text: string) => {
    copy(text);
    setCopiedText(true);
    setTimeout(() => setCopiedText(false), 2000);
  };

  const code = `// npm i @vibe-kit/onboard

import { VibeKitButton } from "@vibe-kit/onboard";

export default function App() {
  return (
    <div>
      <h1>Welcome to My App</h1>
      <VibeKitButton token="${agent._id}" />
    </div>
  );
}`;

  return (
    <div className="flex flex-col gap-y-4">
      <CodeBlock>
        <CodeBlockGroup className="border-border border-b py-2 pr-2 pl-4">
          <div className="flex items-center gap-2">app.tsx</div>
          <Button
            variant="ghost"
            size="icon"
            className="h-8 w-8"
            onClick={() => copyToClipboard(code)}
          >
            {copiedText ? (
              <Check className="h-4 w-4 text-green-500" />
            ) : (
              <Copy className="h-4 w-4" />
            )}
          </Button>
        </CodeBlockGroup>
        <CodeBlockCode code={code} language="tsx" />
      </CodeBlock>
    </div>
  );
}



================================================
FILE: docs/app/(app)/projects/[id]/[agentId]/_components/settings.tsx
================================================
"use client";
import { useForm } from "react-hook-form";
import { InfoIcon, Copy, Check } from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";
import { useCopyToClipboard } from "usehooks-ts";

import { Doc } from "@/convex/_generated/dataModel";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from "@/components/ui/form";
import { siteConfig } from "@/config";

interface Props {
  agent: Doc<"agent">;
  project: Doc<"project">;
  onChange: ({ key, value }: { key: string; value: string | boolean }) => void;
}

interface SettingsFormValues {
  githubClientId?: string;
  githubClientSecret?: string;
  githubCallback?: string;
  privacyPolicy?: string;
  termsOfService?: string;
}

export default function Settings({ agent, project, onChange }: Props) {
  const [copied, setCopied] = useState(false);
  const [, copy] = useCopyToClipboard();

  const form = useForm<SettingsFormValues>({
    defaultValues: {
      githubClientId: project.githubClientId,
      githubClientSecret: project.githubClientSecret,
      githubCallback: siteConfig.githubCallbackUrl,
      privacyPolicy: agent.privacyPolicy || siteConfig.privacyPolicyUrl,
      termsOfService: agent.termsOfService || siteConfig.termsOfServiceUrl,
    },
  });

  // Pass changes up via onChange
  const handleFieldChange = (key: keyof SettingsFormValues, value: string) => {
    form.setValue(key, value);
    onChange({
      key,
      value: String(value),
    });
  };

  const copyToClipboard = async () => {
    const success = await copy(siteConfig.githubCallbackUrl);
    if (success) {
      setCopied(true);
      toast.success("Callback URL copied to clipboard!");
      setTimeout(() => setCopied(false), 2000);
    } else {
      toast.error("Failed to copy callback URL");
    }
  };

  return (
    <Form {...form}>
      <div className="bg-muted border rounded-lg p-4 flex-shrink-0 mt-4">
        <div className="flex items-start space-x-3">
          <InfoIcon className="size-4 text-blue-600 mt-0.5 flex-shrink-0" />
          <div>
            <p className="text-sm">
              Setting up an Github OAuth app is optional, if no credentials are
              provided, the default VibeKit Github App will be used.
            </p>
          </div>
        </div>
      </div>
      <form className="mt-5 flex flex-col gap-6 w-full">
        <FormField
          control={form.control}
          name="githubClientId"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Client ID</FormLabel>
              <FormControl>
                <Input
                  placeholder="Enter GitHub Client ID..."
                  {...field}
                  onChange={(e) =>
                    handleFieldChange("githubClientId", e.target.value)
                  }
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="githubClientSecret"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Client Secret</FormLabel>
              <FormControl>
                <Input
                  type="password"
                  placeholder="Enter GitHub Client Secret..."
                  {...field}
                  onChange={(e) =>
                    handleFieldChange("githubClientSecret", e.target.value)
                  }
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="githubCallback"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Callback URL</FormLabel>
              <FormControl>
                <div className="flex items-center gap-2">
                  <Input disabled {...field} className="flex-1" />
                  <Button
                    type="button"
                    variant="outline"
                    size="icon"
                    onClick={copyToClipboard}
                  >
                    {copied ? (
                      <Check className="size-4" />
                    ) : (
                      <Copy className="size-4" />
                    )}
                  </Button>
                </div>
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="privacyPolicy"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Privacy Policy URL</FormLabel>
              <FormControl>
                <Input
                  className="w-full"
                  placeholder="https://example.com/privacy"
                  {...field}
                  onChange={(e) =>
                    handleFieldChange("privacyPolicy", e.target.value)
                  }
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="termsOfService"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Terms of Service URL</FormLabel>
              <FormControl>
                <Input
                  className="w-full"
                  placeholder="https://example.com/terms"
                  {...field}
                  onChange={(e) =>
                    handleFieldChange("termsOfService", e.target.value)
                  }
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </form>
    </Form>
  );
}



================================================
FILE: docs/app/(auth)/(routes)/sign-in/[[...sign-in]]/client-page.tsx
================================================
"use client";

import React from "react";
import Image from "next/image";

import Link from "next/link";
import { Dot, CheckCircle, Loader2 } from "lucide-react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { useSignIn } from "@clerk/nextjs";
import { isClerkAPIResponseError } from "@clerk/clerk-react/errors";
import { EmailCodeFactor, SignInFirstFactor } from "@clerk/types";
import { toast } from "sonner";
import { siteConfig } from "@/config";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
} from "@/components/ui/form";
import {
  InputOTP,
  InputOTPGroup,
  InputOTPSlot,
} from "@/components/ui/input-otp";

const signUpSchema = z.object({
  email: z.string().email({ message: "Invalid email address" }),
});

type SignUpValues = z.infer<typeof signUpSchema>;

export default function SignInPage() {
  const { isLoaded, signIn, setActive } = useSignIn();
  const [isVerifying, setIsVerifying] = React.useState(false);
  const [hasVerified, setHasVerified] = React.useState(false);
  const form = useForm<SignUpValues>({
    resolver: zodResolver(signUpSchema),
    defaultValues: {
      email: "",
    },
  });

  async function onSubmit(data: SignUpValues) {
    if (!isLoaded) {
      return;
    }

    try {
      const { supportedFirstFactors } = await signIn.create({
        identifier: data.email,
      });

      const isEmailCodeFactor = (
        factor: SignInFirstFactor
      ): factor is EmailCodeFactor => {
        return factor.strategy === "email_code";
      };

      const emailCodeFactor = supportedFirstFactors?.find(isEmailCodeFactor);

      if (emailCodeFactor) {
        const { emailAddressId } = emailCodeFactor;

        await signIn.prepareFirstFactor({
          strategy: "email_code",
          emailAddressId,
        });

        setIsVerifying(true);
      }
    } catch (err: unknown) {
      if (isClerkAPIResponseError(err)) {
        toast.error(err.errors[0].message);
      } else {
        toast.error("Something went wrong, please contact support");
      }

      form.reset();
    }
  }

  async function handleVerification(code: string) {
    if (!isLoaded) {
      return;
    }
    const signInAttempt = await signIn.attemptFirstFactor({
      strategy: "email_code",
      code,
    });

    if (signInAttempt.status === "complete") {
      await setActive({
        session: signInAttempt.createdSessionId,
      });

      setHasVerified(true);

      window.location.href = "/";
    } else {
      toast.error("Something went wrong, please try again");
    }
  }

  const signInWithGoogle = () => {
    if (!isLoaded) return;

    return signIn.authenticateWithRedirect({
      strategy: "oauth_google",
      redirectUrl: siteConfig.clerkOauthUrl,
      redirectUrlComplete: "/",
    });
  };

  return (
    <div className="min-h-screen flex items-center justify-center max-w-md mx-auto">
      <div className="flex flex-col items-center justify-center w-full">
        <div className="flex items-center space-x-4 mb-10">
          <Image
            src="/mark.png"
            alt="VibeKit Onboard Logo"
            width={80}
            height={14}
          />
        </div>
        {isVerifying ? (
          <div className="w-full max-w-sm space-y-8">
            <div className="space-y-2 text-center">
              <h1 className="text-2xl font-bold">Verify email</h1>
              <p>Enter the code sent to your email below</p>
            </div>
            <div className="flex justify-center">
              <InputOTP
                autoFocus
                maxLength={6}
                name="code"
                onChangeCapture={async (event) => {
                  const code = (event.target as HTMLInputElement).value;
                  if (code.length === 6) {
                    await handleVerification(code);
                  }
                }}
              >
                <InputOTPGroup>
                  <InputOTPSlot index={0} className="bg-background" />
                  <InputOTPSlot index={1} className="bg-background" />
                  <InputOTPSlot index={2} className="bg-background" />
                  <InputOTPSlot index={3} className="bg-background" />
                  <InputOTPSlot index={4} className="bg-background" />
                  <InputOTPSlot index={5} className="bg-background" />
                </InputOTPGroup>
              </InputOTP>
            </div>
            {hasVerified ? (
              <div className="flex space-x-2 items-center justify-center">
                <CheckCircle className="mr-2 h-4 w-4 text-green-500" />
                <p className="text-muted-foreground">Verification successful</p>
              </div>
            ) : (
              <div className="flex items-center justify-center">
                <Loader2 className="mr-2 h-4 w-4 animate-spin text-muted-foreground" />
                <p className="text-muted-foreground">
                  Waiting for verification...
                </p>
              </div>
            )}
          </div>
        ) : (
          <div className="w-full max-w-sm space-y-8">
            <div className="space-y-2 text-center">
              <h1 className="text-2xl font-bold">Sign in to your account</h1>
              <p>
                Don&apos;t have an account?{" "}
                <Link passHref href="/sign-up" className="underline">
                  Sign up
                </Link>
              </p>
            </div>
            <Form {...form}>
              <form
                onSubmit={form.handleSubmit(onSubmit)}
                className="space-y-4"
              >
                <FormField
                  control={form.control}
                  name="email"
                  render={({ field }) => (
                    <FormItem>
                      <FormControl>
                        <Input
                          className="bg-background"
                          type="email"
                          placeholder="name@example.com"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <Button
                  disabled={form.formState.isSubmitting}
                  type="submit"
                  className="w-full"
                >
                  {form.formState.isSubmitting && (
                    <Loader2 className="animate-spin" />
                  )}
                  {form.formState.isSubmitting
                    ? "Signing in..."
                    : "Sign in to your account"}
                </Button>
              </form>
            </Form>
            <div className="relative">
              <div className="absolute inset-0 flex items-center">
                <div className="w-full border-t" />
              </div>
              <div className="relative flex justify-center text-xs uppercase">
                <span className="bg-sidebar px-2 text-muted-foreground rounded-full border">
                  OR
                </span>
              </div>
            </div>
            <Button
              variant="outline"
              className="w-full"
              onClick={() => {
                signInWithGoogle();
              }}
            >
              <Image
                src="./google.svg"
                width="20"
                height="20"
                alt="Sign up with google"
              />
              Sign in with Google
            </Button>
          </div>
        )}
        <div className="max-w-sm flex flex-col space-y-0 items-center mt-12 text-sm">
          <div className="flex items-center space-x-0">
            <Link passHref href={siteConfig.termsOfServiceUrl}>
              <p className="hover:text-muted-foreground">Terms</p>
            </Link>
            <Dot className="text-muted-foreground" />
            <Link passHref href={siteConfig.privacyPolicyUrl}>
              <p className="hover:text-muted-foreground">Privacy</p>
            </Link>
            <Dot className="text-muted-foreground" />
            <Link passHref href={siteConfig.cookiePolicyUrl}>
              <p className="hover:text-muted-foreground">Cookies</p>
            </Link>
            <Dot className="text-muted-foreground" />
            <Link passHref href={siteConfig.supportUrl}>
              <p className="hover:text-muted-foreground">Support</p>
            </Link>
          </div>
          <p className="text-muted-foreground">{siteConfig.copyrightText}</p>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(auth)/(routes)/sign-in/[[...sign-in]]/page.tsx
================================================
import { Metadata } from "next";
import { auth } from "@clerk/nextjs/server";

import ClientPage from "./client-page";

export const metadata: Metadata = {
  title: "Log in | VibeKit Onboard",
  description: "Log in to your account",
};

export default async function SignInPage() {
  const { userId } = await auth();

  console.log("userId", userId);
  return <ClientPage />;
}



================================================
FILE: docs/app/(auth)/(routes)/sign-up/[[...sign-up]]/client-page.tsx
================================================
"use client";

import React from "react";
import Image from "next/image";
import { useSearchParams, useRouter } from "next/navigation";
import Link from "next/link";
import { Dot, CheckCircle, Loader2 } from "lucide-react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { useSignUp, useClerk } from "@clerk/nextjs";
import { isClerkAPIResponseError } from "@clerk/clerk-react/errors";
import { toast } from "sonner";

import { siteConfig } from "@/config";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
} from "@/components/ui/form";
import {
  InputOTP,
  InputOTPGroup,
  InputOTPSlot,
} from "@/components/ui/input-otp";

const signUpSchema = z.object({
  email: z.string().email({ message: "Invalid email address" }),
});

type SignUpValues = z.infer<typeof signUpSchema>;

export default function SignUpPage() {
  const router = useRouter();
  const { setActive } = useClerk();
  const { isLoaded, signUp } = useSignUp();
  const [isVerifying, setIsVerifying] = React.useState(false);
  const [hasVerified] = React.useState(false);
  const token = useSearchParams().get("__clerk_ticket");
  const form = useForm<SignUpValues>({
    resolver: zodResolver(signUpSchema),
    defaultValues: {
      email: "",
    },
  });

  const acceptForm = useForm();

  async function onConfirm() {
    if (!isLoaded || !token) {
      return;
    }

    const signUpAttempt = await signUp.create({
      strategy: "ticket",
      ticket: token,
    });

    if (signUpAttempt.status === "complete") {
      // Set up interval to refresh every second
      const refreshInterval = setInterval(() => {
        router.push("/sign-in");
      }, 1000);

      // Clean up interval when component unmounts
      return () => clearInterval(refreshInterval);
    } else {
      toast.error("Something went wrong, please try again.");
    }
  }

  async function onSubmit(data: SignUpValues) {
    if (!isLoaded) {
      return;
    }

    try {
      await signUp.create({
        emailAddress: data.email,
      });

      //posthog.identify(data.email);

      await signUp.prepareEmailAddressVerification();

      setIsVerifying(true);
    } catch (err: unknown) {
      if (isClerkAPIResponseError(err)) {
        toast.error(err.errors[0].message);
      } else {
        toast.error("Something went wrong, please contact support");
      }

      form.reset();
    }
  }

  async function handleVerification(code: string) {
    if (!isLoaded) {
      return;
    }

    const signUpAttempt = await signUp.attemptEmailAddressVerification({
      code,
    });

    if (signUpAttempt.status === "complete") {
      await setActive({ session: signUpAttempt.createdSessionId });
      // Set up interval to refresh every second
      const refreshInterval = setInterval(() => {
        router.refresh();
      }, 1000);

      // Clean up interval when component unmounts
      return () => clearInterval(refreshInterval);
    } else {
      console.log(signUpAttempt);
      toast.error("Something went wrong, please try again.");
    }
  }

  const signUpWithGoogle = () => {
    if (!isLoaded) return;

    return signUp.authenticateWithRedirect({
      strategy: "oauth_google",
      redirectUrl: siteConfig.clerkOauthUrl,
      redirectUrlComplete: "/",
    });
  };

  return (
    <div className="min-h-screen flex items-center justify-center max-w-lg mx-auto">
      <div className="flex flex-col items-center justify-center w-full">
        <div className="flex items-center space-x-4 mb-10">
          <Image
            src="/mark.png"
            alt="VibeKit Onboard Logo"
            width={80}
            height={14}
          />
        </div>
        {isVerifying ? (
          <div className="w-full max-w-sm space-y-8">
            <div className="space-y-2 text-center">
              <h1 className="text-3xl font-bold">Verify email</h1>
              <p className="text-sm">Enter the code sent to your email below</p>
            </div>
            <div className="flex justify-center">
              <InputOTP
                autoFocus
                maxLength={6}
                name="code"
                onChangeCapture={async (event) => {
                  const code = (event.target as HTMLInputElement).value;
                  if (code.length === 6) {
                    await handleVerification(code);
                  }
                }}
              >
                <InputOTPGroup>
                  <InputOTPSlot index={0} className="bg-background" />
                  <InputOTPSlot index={1} className="bg-background" />
                  <InputOTPSlot index={2} className="bg-background" />
                  <InputOTPSlot index={3} className="bg-background" />
                  <InputOTPSlot index={4} className="bg-background" />
                  <InputOTPSlot index={5} className="bg-background" />
                </InputOTPGroup>
              </InputOTP>
            </div>
            {hasVerified ? (
              <div className="flex space-x-2 items-center justify-center">
                <CheckCircle className="mr-2 h-4 w-4 text-green-500" />
                <p className="text-muted-foreground">Verification successful</p>
              </div>
            ) : (
              <div className="flex items-center justify-center">
                <Loader2 className="mr-2 h-4 w-4 animate-spin text-muted-foreground" />
                <p className="text-muted-foreground">
                  Waiting for verification...
                </p>
              </div>
            )}
          </div>
        ) : (
          <div className="flex flex-col space-y-10 w-full">
            {token ? (
              <div className="w-full max-w-sm mx-auto space-y-8">
                <div className="space-y-2 text-center">
                  <h1 className="text-2xl font-bold">Accept invitation</h1>
                  <p>Click the button below to accept the invitation</p>
                </div>
                <Form {...acceptForm}>
                  <form
                    onSubmit={acceptForm.handleSubmit(onConfirm)}
                    className="space-y-4"
                  >
                    <Button
                      disabled={acceptForm.formState.isSubmitting}
                      type="submit"
                      className="w-full"
                    >
                      {acceptForm.formState.isSubmitting && (
                        <Loader2 className="animate-spin" />
                      )}
                      {acceptForm.formState.isSubmitting
                        ? "Creating account..."
                        : "Accept invitiation"}
                    </Button>
                  </form>
                </Form>
              </div>
            ) : (
              <div className="w-full max-w-sm mx-auto space-y-8">
                <div className="space-y-2 text-center">
                  <h1 className="text-2xl font-bold">Create an account</h1>
                  <p>
                    Already have an account?{" "}
                    <Link passHref href="/sign-in" className="underline">
                      Sign in
                    </Link>
                  </p>
                </div>
                <Form {...form}>
                  <form
                    onSubmit={form.handleSubmit(onSubmit)}
                    className="space-y-4"
                  >
                    <FormField
                      control={form.control}
                      name="email"
                      render={({ field }) => (
                        <FormItem>
                          <FormControl>
                            <Input
                              className="bg-background"
                              type="email"
                              placeholder="name@example.com"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <Button
                      disabled={form.formState.isSubmitting}
                      type="submit"
                      className="w-full"
                    >
                      {form.formState.isSubmitting && (
                        <Loader2 className="animate-spin" />
                      )}
                      {form.formState.isSubmitting
                        ? "Creating account..."
                        : "Create an account"}
                    </Button>
                  </form>
                </Form>
                <div className="relative">
                  <div className="absolute inset-0 flex items-center">
                    <div className="w-full border-t" />
                  </div>
                  <div className="relative flex justify-center text-xs uppercase">
                    <span className="px-2 bg-sidebar text-muted-foreground rounded-full border">
                      OR
                    </span>
                  </div>
                </div>
                <Button
                  variant="outline"
                  className="w-full border border-muted-foreground/20"
                  onClick={() => {
                    signUpWithGoogle();
                  }}
                >
                  <Image
                    src="./google.svg"
                    width="20"
                    height="20"
                    alt="Sign up with google"
                  />
                  Sign up with Google
                </Button>
              </div>
            )}
          </div>
        )}
        <div className="max-w-sm flex flex-col space-y-0 items-center mt-12 text-sm">
          <div className="flex items-center space-x-0">
            <Link passHref href={siteConfig.termsOfServiceUrl}>
              <p className="hover:text-muted-foreground">Terms</p>
            </Link>
            <Dot className="text-muted-foreground" />
            <Link passHref href={siteConfig.privacyPolicyUrl}>
              <p className="hover:text-muted-foreground">Privacy</p>
            </Link>
            <Dot className="text-muted-foreground" />
            <Link passHref href={siteConfig.cookiePolicyUrl}>
              <p className="hover:text-muted-foreground">Cookies</p>
            </Link>
            <Dot className="text-muted-foreground" />
            <Link passHref href={siteConfig.supportUrl}>
              <p className="hover:text-muted-foreground">Support</p>
            </Link>
          </div>
          <p className="text-muted-foreground">{siteConfig.copyrightText}</p>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(auth)/(routes)/sign-up/[[...sign-up]]/page.tsx
================================================
import { Metadata } from "next";
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

import ClientPage from "./client-page";

export const metadata: Metadata = {
  title: "Sign Up | VibeKit Onboard",
  description: "Sign up to your account",
};

export default async function SignUpPage() {
  const { userId } = await auth();

  if (userId) {
    redirect("/");
  }

  return <ClientPage />;
}



================================================
FILE: docs/app/(auth)/(routes)/waitlist/page.tsx
================================================
"use client";

import React from "react";
import Image from "next/image";
import Link from "next/link";
import { Dot, Loader2 } from "lucide-react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { toast } from "sonner";

import { siteConfig } from "@/config";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
} from "@/components/ui/form";
import { addToWaitlistAction } from "@/app/actions/waitlist";
const waitlistSchema = z.object({
  email: z.string().email({ message: "Invalid email address" }),
});

type WaitlistValues = z.infer<typeof waitlistSchema>;

export default function WaitlistPage() {
  const [isSubmitting, setIsSubmitting] = React.useState(false);
  const [isAddedToWaitlist, setIsAddedToWaitlist] = React.useState(false);
  const form = useForm<WaitlistValues>({
    resolver: zodResolver(waitlistSchema),
    defaultValues: {
      email: "",
    },
  });

  async function onSubmit(data: WaitlistValues) {
    setIsSubmitting(true);
    try {
      await addToWaitlistAction(data.email);
      setIsAddedToWaitlist(true);
      form.reset();
    } catch {
      toast.error("Something went wrong. Please try again.");
      setIsSubmitting(false);
    } finally {
      setIsSubmitting(false);
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center max-w-md mx-auto">
      <div className="flex flex-col items-center justify-center w-full">
        <div className="flex items-center space-x-4 mb-10">
          <Image
            src="/mark.png"
            alt="VibeKit Onboard Logo"
            width={80}
            height={14}
          />
        </div>
        {isAddedToWaitlist ? (
          <div className="w-full max-w-lg space-y-8">
            <div className="space-y-2 text-center">
              <h1 className="text-2xl font-bold">You&apos;ve been added!</h1>
              <p>
                You will receive an invite to {siteConfig.appName} when
                it&apos;s your turn.
              </p>
            </div>
          </div>
        ) : (
          <div className="w-full max-w-sm space-y-8">
            <div className="space-y-2 text-center">
              <h1 className="text-2xl font-bold">Join the waitlist</h1>
              <p>Be among the first to experience {siteConfig.appName}.</p>
            </div>
            <Form {...form}>
              <form
                onSubmit={form.handleSubmit(onSubmit)}
                className="space-y-4"
              >
                <FormField
                  control={form.control}
                  name="email"
                  render={({ field }) => (
                    <FormItem>
                      <FormControl>
                        <Input
                          className="bg-background"
                          type="email"
                          placeholder="name@example.com"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <Button
                  disabled={isSubmitting}
                  type="submit"
                  className="w-full"
                >
                  {isSubmitting && (
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  )}
                  {isSubmitting ? "Joining waitlist..." : "Join the waitlist"}
                </Button>
              </form>
            </Form>
          </div>
        )}
        <div className="max-w-sm flex flex-col space-y-0 items-center mt-12 text-sm">
          <div className="flex items-center space-x-0">
            <Link passHref href={siteConfig.termsOfServiceUrl}>
              <p className="hover:text-muted-foreground">Terms</p>
            </Link>
            <Dot className="text-muted-foreground" />
            <Link passHref href={siteConfig.privacyPolicyUrl}>
              <p className="hover:text-muted-foreground">Privacy</p>
            </Link>
            <Dot className="text-muted-foreground" />
            <Link passHref href={siteConfig.cookiePolicyUrl}>
              <p className="hover:text-muted-foreground">Cookies</p>
            </Link>
            <Dot className="text-muted-foreground" />
            <Link passHref href={siteConfig.supportUrl}>
              <p className="hover:text-muted-foreground">Support</p>
            </Link>
          </div>
          <p className="text-muted-foreground">{siteConfig.copyrightText}</p>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(embed)/embed/[id]/client-page.tsx
================================================
"use client";
import { useEffect, useState, useRef } from "react";
import { useInngestSubscription } from "@inngest/realtime/hooks";
import Image from "next/image";
import { useQuery } from "convex/react";
import {
  Check,
  Copy,
  ArrowRight,
  LucideGithub,
  Info,
  Loader2,
  ChevronsUpDown,
} from "lucide-react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { useMutation } from "convex/react";

import { siteConfig } from "@/config";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormMessage,
} from "@/components/ui/form";
import { Avatar, AvatarImage } from "@/components/ui/avatar";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Id } from "@/convex/_generated/dataModel";
import { cn, getContrastTextColor } from "@/lib/utils";
import { useGitHubAuth, type GitHubRepository } from "@/hooks/use-github";
import { createAgent } from "@/app/actions/agent";
import { fetchRealtimeSubscriptionToken } from "@/app/actions/inngest";
import { TextShimmer } from "@/components/ui/text-shimmer";
import { api } from "@/convex/_generated/api";
import { getGithubAuth } from "@/lib/github";

interface Props {
  agentId: Id<"agent">;
  isEmbedded?: boolean;
}

const formSchema = z.object({
  repository: z.string().min(1, "Please select a repository"),
  instructions: z
    .string()
    .min(10, "Instructions must be at least 10 characters"),
});

type FormValues = z.infer<typeof formSchema>;

const statusLabels = {
  INITIALIZING: "Setting up environment",
  CLONING_REPO: "Cloning repository",
  IMPLEMENTING_CODE: "Writing code",
  CREATING_PR: "Creating pull request",
  DONE: "Pull Request created in your repository",
};

const allStatuses: Array<keyof typeof statusLabels> = [
  "INITIALIZING",
  "CLONING_REPO",
  "IMPLEMENTING_CODE",
  "CREATING_PR",
  "DONE",
];

export default function EmbedClientPage({ agentId, isEmbedded }: Props) {
  const agent = useQuery(api.agents.getAgent, { id: agentId });
  const project = useQuery(
    api.projects.getProject,
    agent?.projectId ? { id: agent.projectId } : "skip"
  );
  const [step, setStep] = useState(1);
  const [logId, setLogId] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const [activeTab, setActiveTab] = useState("integration");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [status, setStatus] = useState<
    | "INITIALIZING"
    | "CLONING_REPO"
    | "IMPLEMENTING_CODE"
    | "CREATING_PR"
    | "DONE"
    | null
  >(null);
  const [statusTimeline, setStatusTimeline] = useState<
    Array<{
      status:
        | "INITIALIZING"
        | "CLONING_REPO"
        | "IMPLEMENTING_CODE"
        | "CREATING_PR"
        | "DONE";
      timestamp: Date;
    }>
  >([]);
  const [copied, setCopied] = useState(false);
  const [repositorySelectOpen, setRepositorySelectOpen] = useState(false);
  const createActionLog = useMutation(api.actionLogs.createActionLog);
  const cardRef = useRef<HTMLDivElement>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);
  const { latestData } = useInngestSubscription({
    refreshToken: fetchRealtimeSubscriptionToken,
    bufferInterval: 0,
    enabled: true,
  });

  if (latestData?.channel === "agents" && latestData.topic === "status") {
    if (status !== latestData.data.status && latestData.data.logId === logId) {
      const newStatus = latestData.data.status;
      setStatus(newStatus);

      // Add to timeline only if it's a new unique status
      setStatusTimeline((prev) => {
        const statusExists = prev.some((item) => item.status === newStatus);
        if (!statusExists) {
          return [...prev, { status: newStatus, timestamp: new Date() }];
        }
        return prev;
      });
    }
  }

  const {
    isAuthenticated,
    repositories,
    token,
    login,
    fetchRepositories,
    isLoading,
  } = useGitHubAuth(agent?._id as Id<"agent">);

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      repository: "",
      instructions: "",
    },
  });

  // Function to send Card height to parent iframe
  const sendHeightToParent = () => {
    if (
      !isEmbedded ||
      !window.parent ||
      window.parent === window ||
      !cardRef.current
    )
      return;

    const cardHeight = cardRef.current.offsetHeight;

    window.parent.postMessage(
      {
        type: "VIBEKIT_RESIZE",
        height: cardHeight,
      },
      "*"
    );
  };

  // Send height when component mounts and content loads
  useEffect(() => {
    if (isEmbedded) {
      const timer = setTimeout(sendHeightToParent, 100);
      return () => clearTimeout(timer);
    }
  }, [isEmbedded]);

  // Send height when content-affecting state changes
  useEffect(() => {
    if (isEmbedded) {
      const timer = setTimeout(sendHeightToParent, 100);
      return () => clearTimeout(timer);
    }
  }, [
    step,
    success,
    activeTab,
    isAuthenticated,
    repositories.length,
    isEmbedded,
  ]);

  // Send height on window resize
  useEffect(() => {
    if (!isEmbedded) return;

    const handleResize = () => {
      sendHeightToParent();
    };

    window.addEventListener("resize", handleResize);
    window.addEventListener("load", sendHeightToParent);

    return () => {
      window.removeEventListener("resize", handleResize);
      window.removeEventListener("load", sendHeightToParent);
    };
  }, [isEmbedded]);

  useEffect(() => {
    if (isAuthenticated) {
      fetchRepositories(agentId);
    }
  }, [isAuthenticated]);

  // Focus search input when repository dropdown opens
  useEffect(() => {
    if (repositorySelectOpen && searchInputRef.current) {
      const timer = setTimeout(() => {
        searchInputRef.current?.focus();
      }, 100);
      return () => clearTimeout(timer);
    }
  }, [repositorySelectOpen]);

  const handleGitHubAuth = async () => {
    await login(agent?._id as Id<"agent">);
  };

  const copyToClipboard = async () => {
    if (!agent?.systemPrompt) return;

    // Safely check if we're in a cross-origin iframe
    let isInCrossOriginIframe = false;
    try {
      // Try to access parent location - this will throw if cross-origin
      if (window.parent && window.parent !== window) {
        const parentOrigin = window.parent.location.origin;
        isInCrossOriginIframe = window.location.origin !== parentOrigin;
      }
    } catch {
      // If we can't access parent.location, we're definitely in a cross-origin iframe
      isInCrossOriginIframe = window.parent && window.parent !== window;
    }

    try {
      // If we're in a cross-origin iframe, skip clipboard API and use postMessage
      if (isInCrossOriginIframe) {
        throw new Error("Clipboard API blocked in cross-origin iframe");
      }

      await navigator.clipboard.writeText(agent?.systemPrompt || "");
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);

      // Log the copy action after successful clipboard operation
      await createActionLog({
        action: "COPY_PROMPT",
        agentId: agent?._id as Id<"agent">,
        projectId: agent?.projectId as Id<"project">,
      });
    } catch {
      console.log("Clipboard API not available, using fallback method");

      // Fallback: Use postMessage to notify parent window
      if (window.parent && window.parent !== window) {
        console.log("Sending message to parent window");
        window.parent.postMessage(
          {
            type: "VIBEKIT_COPY",
            content: agent?.systemPrompt,
            format: "text",
            timestamp: Date.now(),
          },
          "*"
        );

        setCopied(true);
        setTimeout(() => setCopied(false), 2000);

        // Log the copy action after successful fallback operation
        await createActionLog({
          action: "COPY_PROMPT",
          agentId: agent?._id as Id<"agent">,
          projectId: agent?.projectId as Id<"project">,
        });
      }
    }
  };

  const onSubmit = async (values: FormValues) => {
    try {
      setIsSubmitting(true);
      const githubAuth = getGithubAuth();
      const githuUser = await githubAuth.getUser(token!);
      const _logId = await createActionLog({
        action: "CREATE_AGENT",
        agentId: agent?._id as Id<"agent">,
        projectId: agent?.projectId as Id<"project">,
        metadata: {
          githubUserProfile: {
            name: githuUser.name,
            avatar: githuUser.avatar_url,
            profileUrl: `https://github.com/${githuUser.login}`,
          },
          repository: values.repository,
          instructions: values.instructions,
        },
      });
      setLogId(_logId);

      await createAgent({
        repository: values.repository,
        instructions: values.instructions,
        prompt: agent?.systemPrompt || "",
        githubToken: token || "",
        logId: _logId,
      });

      setSuccess(true);
    } catch (error) {
      console.error("Error creating agent:", error);
      // You might want to show an error message to the user here
    } finally {
      setIsSubmitting(false);
    }
  };

  if (!agent || !project) {
    return (
      <div className="h-screen flex items-center justify-center">
        <Loader2 className="size-4 animate-spin" />
      </div>
    );
  }

  return (
    <div className="bg-muted flex min-h-svh flex-col items-center justify-center">
      <div
        className={cn(
          "w-full max-w-sm md:max-w-[800px]",
          isEmbedded && "max-w-full md:max-w-full"
        )}
      >
        <div className={cn("flex flex-col gap-6")}>
          <Card
            ref={cardRef}
            className={cn(
              "p-0 shadow-none overflow-hidden relative",
              isEmbedded && "border-none rounded-none"
            )}
          >
            <CardContent
              className={cn(
                "grid p-0 md:grid-cols-5 h-[620px]",
                isEmbedded && "h-[620px]"
              )}
            >
              <div
                className="bg-muted relative hidden md:block col-span-2 overflow-hidden min-h-full p-6 border-r"
                style={{
                  backgroundColor: agent.primaryColor || project.primaryColor,
                }}
              >
                <div className="size-10 flex items-center justify-center rounded-md overflow-hidden">
                  <Image
                    src={agent.logo || project.logo || ""}
                    alt={agent.name}
                    width="48"
                    height="48"
                  />
                </div>
                <p
                  className="font-semibold text-3xl mt-4"
                  style={{
                    color: getContrastTextColor(
                      agent.primaryColor || project.primaryColor || "#000"
                    ),
                  }}
                >
                  {agent.name}
                </p>
                <p
                  className="mt-5"
                  style={{
                    color: getContrastTextColor(
                      agent.primaryColor || project.primaryColor || "#000"
                    ),
                  }}
                >
                  {agent.descriptionText}
                </p>
                <svg
                  className="absolute inset-0 h-full w-full opacity-20"
                  viewBox="0 0 400 800"
                  preserveAspectRatio="xMidYMid slice"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <defs>
                    <pattern
                      id="grid"
                      width="40"
                      height="40"
                      patternUnits="userSpaceOnUse"
                    >
                      <path
                        d="M 40 0 L 0 0 0 40"
                        fill="none"
                        stroke={getContrastTextColor(
                          agent.primaryColor || project.primaryColor || "#000"
                        )}
                        strokeWidth="1"
                        opacity="0.3"
                      />
                    </pattern>
                  </defs>
                  <rect width="100%" height="100%" fill="url(#grid)" />
                  <g
                    fill={getContrastTextColor(
                      agent.primaryColor || project.primaryColor || "#000"
                    )}
                    opacity="0.1"
                  >
                    <rect x="80" y="120" width="40" height="40" />
                    <rect x="240" y="200" width="40" height="40" />
                    <rect x="160" y="320" width="40" height="40" />
                    <rect x="320" y="280" width="40" height="40" />
                    <rect x="40" y="440" width="40" height="40" />
                    <rect x="280" y="480" width="40" height="40" />
                    <rect x="120" y="560" width="40" height="40" />
                    <rect x="200" y="640" width="40" height="40" />
                    <rect x="320" y="600" width="40" height="40" />
                    <rect x="80" y="720" width="40" height="40" />
                  </g>
                </svg>
              </div>
              <div className="px-6 md:px-8 pb-8 col-span-3">
                <div className="flex flex-col h-full gap-y-6">
                  <div className="flex flex-col items-center pt-6 w-full">
                    <Image
                      src={agent.logo || project.logo || ""}
                      alt={agent.name}
                      width="48"
                      height="48"
                      className="md:hidden"
                    />
                    <h1 className="text-xl font-bold mt-5">
                      {agent.headlineText}
                    </h1>
                  </div>
                  {success ? (
                    <div className="flex flex-col items-center justify-start space-y-6 flex-1">
                      <div className="w-full max-w-md space-y-4 relative flex-1 flex flex-col">
                        <div className="space-y-3 flex-1">
                          {allStatuses.map((statusKey) => {
                            const completedItem = statusTimeline.find(
                              (item) => item.status === statusKey
                            );
                            const isCompleted = !!completedItem;
                            const isCurrentStatus =
                              status === statusKey && statusKey !== "DONE";

                            // Show INITIALIZING with spinner if no status has been received yet
                            const isInitializing =
                              statusKey === "INITIALIZING" &&
                              !status &&
                              statusTimeline.length === 0;
                            const isUpcoming =
                              !isCompleted &&
                              !isCurrentStatus &&
                              !isInitializing &&
                              !(status === "DONE" && statusKey === "DONE");

                            return (
                              <div
                                key={statusKey}
                                className={`flex items-center space-x-3 p-3 bg-muted rounded-lg ${isUpcoming ? "opacity-50" : ""} ${
                                  isCurrentStatus || isInitializing
                                    ? "relative border-2 border-green-500 shadow-lg shadow-green-500/25 animate-border-pulse"
                                    : ""
                                }`}
                              >
                                <div className="flex-shrink-0">
                                  {isCurrentStatus || isInitializing ? (
                                    <Loader2 className="w-3 h-3 animate-spin" />
                                  ) : isCompleted ||
                                    (status === "DONE" &&
                                      statusKey === "DONE") ? (
                                    <div className="w-3 h-3 bg-green-500 rounded-full"></div>
                                  ) : (
                                    <div className="w-3 h-3 bg-gray-300 rounded-full"></div>
                                  )}
                                </div>
                                <div className="flex-1">
                                  <div className="flex items-center justify-between">
                                    <div
                                      className={`text-sm font-medium ${isUpcoming ? "text-muted-foreground" : ""}`}
                                    >
                                      {isCurrentStatus ? (
                                        <TextShimmer>
                                          {`${statusLabels[statusKey]}...`}
                                        </TextShimmer>
                                      ) : (
                                        <p className="text-sm">
                                          {statusLabels[statusKey]}
                                        </p>
                                      )}
                                    </div>
                                    <div className="text-xs text-muted-foreground">
                                      {isCompleted
                                        ? completedItem.timestamp.toLocaleTimeString()
                                        : status === "DONE" &&
                                            statusKey === "DONE"
                                          ? "Completed"
                                          : isCurrentStatus || isInitializing
                                            ? "In progress..."
                                            : "Pending"}
                                    </div>
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                        <p className="text-sm text-muted-foreground text-center mt-auto">
                          You may close this modal at any time
                        </p>
                      </div>
                    </div>
                  ) : (
                    <Tabs
                      value={activeTab}
                      onValueChange={setActiveTab}
                      className="w-full h-full"
                    >
                      {step !== 2 && (
                        <TabsList className="w-full">
                          <TabsTrigger value="integration" className="w-full">
                            <LucideGithub className="size-4 mr-2" />
                            Make a PR
                          </TabsTrigger>
                          <TabsTrigger value="cursor" className="w-full">
                            <div className="*:data-[slot=avatar]:ring-background flex -space-x-1.5 *:data-[slot=avatar]:ring-2 ">
                              <Avatar className="size-4 bg-background">
                                <AvatarImage src="/devin.svg" alt="Devin" />
                              </Avatar>
                              <Avatar className="size-4 bg-background">
                                <AvatarImage src="/cursor.png" alt="Cursor" />
                              </Avatar>
                              <Avatar className="size-4 bg-background">
                                <AvatarImage
                                  src="/windsurf.svg"
                                  alt="Windsurf"
                                />
                              </Avatar>
                            </div>
                            Copy prompt
                          </TabsTrigger>
                        </TabsList>
                      )}
                      <TabsContent value="integration" className="mt-4 h-full">
                        <Form {...form}>
                          <form
                            onSubmit={form.handleSubmit(onSubmit)}
                            className="flex flex-col gap-y-6 h-full"
                          >
                            {step === 1 && (
                              <div className="space-y-6 flex flex-col h-full">
                                <div className="flex flex-col gap-y-6 flex-1">
                                  <div>
                                    <div className="text-left">
                                      <h3 className="text-sm font-semibold">
                                        Select Repository
                                      </h3>
                                      <p className="text-sm text-muted-foreground mb-2">
                                        Connect your GitHub account to select a
                                        repository
                                      </p>
                                    </div>
                                    {!isAuthenticated ? (
                                      <div className="flex flex-col items-center space-y-4">
                                        <Button
                                          type="button"
                                          onClick={handleGitHubAuth}
                                          className="w-full"
                                          disabled={isLoading}
                                        >
                                          <LucideGithub className="w-4 h-4 mr-2" />
                                          {isLoading
                                            ? "Authenticating..."
                                            : "Authenticate with GitHub"}
                                        </Button>
                                      </div>
                                    ) : (
                                      <FormField
                                        control={form.control}
                                        name="repository"
                                        render={({ field }) => (
                                          <FormItem>
                                            <div className="relative">
                                              <FormControl>
                                                <Button
                                                  type="button"
                                                  variant="outline"
                                                  className="w-full justify-between"
                                                  onClick={() =>
                                                    setRepositorySelectOpen(
                                                      !repositorySelectOpen
                                                    )
                                                  }
                                                >
                                                  {field.value ? (
                                                    <span className="text-sm font-normal">
                                                      {field.value}
                                                    </span>
                                                  ) : (
                                                    <span className="text-sm font-normal">
                                                      Select repository...
                                                    </span>
                                                  )}
                                                  <ChevronsUpDown className="h-4 w-4 opacity-50" />
                                                </Button>
                                              </FormControl>
                                              {repositorySelectOpen && (
                                                <div className="absolute z-50 w-full mt-1 bg-popover border rounded-md shadow-md">
                                                  <Command>
                                                    <CommandInput
                                                      ref={searchInputRef}
                                                      placeholder="Search repository..."
                                                    />
                                                    <CommandList className="max-h-[250px] overflow-y-auto">
                                                      <CommandEmpty>
                                                        No repositories found.
                                                      </CommandEmpty>
                                                      <CommandGroup>
                                                        {repositories.map(
                                                          (
                                                            repo: GitHubRepository
                                                          ) => (
                                                            <CommandItem
                                                              key={repo.id}
                                                              value={
                                                                repo.full_name
                                                              }
                                                              onSelect={(
                                                                value
                                                              ) => {
                                                                field.onChange(
                                                                  value
                                                                );
                                                                setRepositorySelectOpen(
                                                                  false
                                                                );
                                                              }}
                                                            >
                                                              <span>
                                                                {repo.full_name}
                                                              </span>
                                                            </CommandItem>
                                                          )
                                                        )}
                                                      </CommandGroup>
                                                    </CommandList>
                                                  </Command>
                                                </div>
                                              )}
                                            </div>
                                            <FormMessage />
                                          </FormItem>
                                        )}
                                      />
                                    )}
                                  </div>
                                  <div>
                                    <div className="text-left">
                                      <h3 className="text-sm font-semibold">
                                        Add Instructions
                                      </h3>
                                      <p className="text-sm text-muted-foreground mb-2">
                                        Provide specific instructions for
                                        integrating {agent.name}
                                      </p>
                                    </div>
                                    <FormField
                                      control={form.control}
                                      name="instructions"
                                      render={({ field }) => (
                                        <FormItem>
                                          <FormControl>
                                            <Textarea
                                              placeholder={`Describe how you want ${
                                                agent.name
                                              } integrated into your app.`}
                                              className="min-h-[120px]"
                                              {...field}
                                            />
                                          </FormControl>
                                          <FormMessage />
                                        </FormItem>
                                      )}
                                    />
                                  </div>
                                </div>
                                <div className="flex flex-col gap-3">
                                  <div className="flex gap-3">
                                    {/* No back button on first step */}
                                    <Button
                                      type="button"
                                      onClick={() => {
                                        // Validate before going to confirmation
                                        const repo =
                                          form.getValues("repository");
                                        const instructions =
                                          form.getValues("instructions");
                                        if (!isAuthenticated) return;
                                        if (!repo) {
                                          form.setError("repository", {
                                            message:
                                              "Please select a repository",
                                          });
                                          return;
                                        }
                                        if (
                                          !instructions ||
                                          instructions.length < 10
                                        ) {
                                          form.setError("instructions", {
                                            message:
                                              "Instructions must be at least 10 characters",
                                          });
                                          return;
                                        }
                                        setStep(2);
                                      }}
                                      disabled={!isAuthenticated}
                                      variant="outline"
                                      className="w-full mt-auto"
                                      style={{
                                        backgroundColor:
                                          agent.buttonColor ||
                                          agent.primaryColor ||
                                          project.primaryColor,
                                        color: getContrastTextColor(
                                          agent.buttonColor ||
                                            agent.primaryColor ||
                                            project.primaryColor ||
                                            "#000"
                                        ),
                                      }}
                                    >
                                      {agent.showButtonLogo && (
                                        <Image
                                          src={agent.logo || project.logo || ""}
                                          alt={agent.name}
                                          width="18"
                                          height="18"
                                          style={{
                                            filter: `brightness(0) saturate(100%) invert(${
                                              getContrastTextColor(
                                                agent.buttonColor ||
                                                  agent.primaryColor ||
                                                  project.primaryColor ||
                                                  "#000"
                                              ) === "#fff"
                                                ? "1"
                                                : "0"
                                            })`,
                                          }}
                                        />
                                      )}
                                      {agent.buttonText ||
                                        siteConfig.defaultWidgetValues
                                          .buttonText}
                                      <ArrowRight className="w-4 h-4 ml-2" />
                                    </Button>
                                  </div>
                                </div>
                              </div>
                            )}
                            {step === 2 && (
                              <div className="space-y-4 flex flex-col h-full">
                                <div className="bg-muted p-4 rounded-lg space-y-2">
                                  <div className="flex flex-col">
                                    <span className="font-medium text-sm">
                                      Repository:
                                    </span>{" "}
                                    <span className="text-muted-foreground text-sm">
                                      {form.getValues("repository")}
                                    </span>
                                  </div>
                                  <div>
                                    <span className="font-medium text-sm">
                                      Instructions:
                                    </span>
                                    <p className="text-sm text-muted-foreground mt-1">
                                      {form.getValues("instructions")}
                                    </p>
                                  </div>
                                </div>

                                <div className="bg-blue-50 dark:bg-blue-950 p-4 rounded-lg">
                                  <div className="flex items-start space-x-3">
                                    <div className="flex-shrink-0">
                                      <LucideGithub className="w-5 h-5 text-blue-600 mt-1" />
                                    </div>
                                    <div>
                                      <h4 className="font-medium text-sm">
                                        Pull Request will be created
                                      </h4>
                                      <p className="text-sm text-muted-foreground mt-1">
                                        A pull request will be automatically
                                        created in the repository you selected
                                        based on your instructions.
                                      </p>
                                    </div>
                                  </div>
                                </div>
                                <div className="flex flex-col gap-3 pt-6 mt-auto">
                                  <div className="flex gap-3">
                                    <Button
                                      type="button"
                                      variant="outline"
                                      onClick={() => setStep(1)}
                                      className="flex-1"
                                    >
                                      <ArrowRight className="w-4 h-4 mr-2 rotate-180" />
                                      Back
                                    </Button>
                                    <Button
                                      type="submit"
                                      className="flex-1"
                                      disabled={isSubmitting}
                                      style={{
                                        backgroundColor:
                                          agent.buttonColor ||
                                          agent.primaryColor ||
                                          project.primaryColor,
                                        color: getContrastTextColor(
                                          agent.buttonColor ||
                                            agent.primaryColor ||
                                            project.primaryColor ||
                                            "#000"
                                        ),
                                      }}
                                    >
                                      {isSubmitting ? (
                                        <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                                      ) : (
                                        <LucideGithub className="w-4 h-4 mr-2" />
                                      )}
                                      Create Pull Request
                                    </Button>
                                  </div>
                                </div>
                              </div>
                            )}
                          </form>
                        </Form>
                      </TabsContent>
                      <TabsContent value="cursor" className="space-y-4">
                        <div className="bg-muted p-4 rounded-lg space-y-4">
                          <ScrollArea className="text-sm whitespace-pre-wrap font-mono">
                            <div className="max-h-[200px]">
                              {agent.systemPrompt}
                            </div>
                          </ScrollArea>
                          <Button
                            onClick={copyToClipboard}
                            className="w-full"
                            variant="outline"
                          >
                            {copied ? (
                              <>
                                <Check className="w-4 h-4 text-green-500" />
                                Copied!
                              </>
                            ) : (
                              <>
                                <Copy className="w-4 h-4" />
                                Copy Prompt
                              </>
                            )}
                          </Button>
                        </div>

                        <div className="bg-blue-50 dark:bg-blue-950 p-4 rounded-lg">
                          <div className="flex items-start space-x-3">
                            <div className="flex-shrink-0">
                              <Info className="size-4 text-blue-600 mt-1" />
                            </div>
                            <div>
                              <p className="text-sm text-blue-700 dark:text-blue-200">
                                Copy the prompt above and paste it into
                                Cursor&apos;s, Windsurf, Devin, VSCode etc.
                              </p>
                            </div>
                          </div>
                        </div>
                      </TabsContent>
                    </Tabs>
                  )}
                </div>
              </div>
            </CardContent>
          </Card>
          {!isEmbedded && (
            <div className="text-muted-foreground *:[a]:hover:text-primary text-center text-xs text-balance *:[a]:underline *:[a]:underline-offset-4">
              By clicking continue, you agree to our{" "}
              <a href={agent.termsOfService || siteConfig.termsOfServiceUrl}>
                Terms of Service
              </a>{" "}
              and{" "}
              <a href={agent.privacyPolicy || siteConfig.privacyPolicyUrl}>
                Privacy Policy
              </a>
              .
            </div>
          )}
        </div>
      </div>
    </div>
  );
}



================================================
FILE: docs/app/(embed)/embed/[id]/page.tsx
================================================
import { notFound } from "next/navigation";
import { Metadata } from "next";
import { fetchQuery } from "convex/nextjs";

import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";
import EmbedClientPage from "./client-page";

interface Props {
  params: Promise<{ id: string }>;
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  // read route params
  const id = (await params).id;

  const agent = await fetchQuery(api.agents.getAgent, {
    id: id as Id<"agent">,
  });

  if (!agent) {
    return {
      title: "Link not found | VibeKit",
      description: "The requested link could not be found",
    };
  }

  return {
    title: `${agent.headlineText} | VibeKit`,
    description: agent.descriptionText,
  };
}

export default async function ProjectPage({ params, searchParams }: Props) {
  const { id } = await params;
  const resolvedSearchParams = await searchParams;

  // Check if embed mode is enabled via search params
  const isEmbedded =
    resolvedSearchParams?.embed === "true" ||
    resolvedSearchParams?.embed === "1";

  if (!id) {
    return notFound();
  }

  // Just validate that the agent exists, but let client fetch the data
  const agent = await fetchQuery(api.agents.getAgent, {
    id: id as Id<"agent">,
  });

  if (!agent) {
    return notFound();
  }

  return (
    <EmbedClientPage agentId={id as Id<"agent">} isEmbedded={isEmbedded} />
  );
}



================================================
FILE: docs/app/actions/agent.ts
================================================
"use server";

import { inngest } from "@/lib/inngest";

export const createAgent = async ({
  repository,
  instructions,
  prompt,
  githubToken,
  logId,
}: {
  repository: string;
  instructions: string;
  prompt: string;
  githubToken: string;
  logId: string;
}) => {
  await inngest.send({
    name: "app/run.agent",
    data: {
      repository,
      instructions,
      prompt,
      githubToken,
      logId,
    },
  });
};



================================================
FILE: docs/app/actions/inngest.ts
================================================
"use server";
import { getSubscriptionToken, Realtime } from "@inngest/realtime";

import { getInngestApp, agentChannel } from "@/lib/inngest";

export type AgentChannelToken = Realtime.Token<typeof agentChannel, ["status"]>;

export async function fetchRealtimeSubscriptionToken(): Promise<AgentChannelToken> {
  const token = await getSubscriptionToken(getInngestApp(), {
    channel: agentChannel(),
    topics: ["status"],
  });

  return token;
}



================================================
FILE: docs/app/actions/prompt.ts
================================================
"use server";
import { generateText, Output } from "ai";
import { openai } from "@ai-sdk/openai";
import { z } from "zod";

export async function generatePromptFromUrl(url: string): Promise<string> {
  console.log("Generating prompt for URL:", url);
  const data = await generateText({
    model: openai.responses("gpt-4.1"),
    prompt:
      `# GOAL\nYour goal is to create a prompt for an AI Agent to implement the following service: ${url}\n` +
      "Include step by step instructions for the agent to follow.\n" +
      "Always use web search to get the latest information based on the URL provided.\n" +
      "Include code examples and other valuable instructions.",
    tools: {
      web_search_preview: openai.tools.webSearchPreview(),
    },
    toolChoice: "required",
    experimental_output: Output.object({
      schema: z.object({
        markdown: z.string(),
      }),
    }),
  });

  return data.experimental_output.markdown;
}



================================================
FILE: docs/app/actions/waitlist.ts
================================================
"use server";
import { clerkClient } from "@/lib/clerk";

export async function addToWaitlistAction(email: string) {
  await clerkClient.waitlistEntries.create({
    emailAddress: email,
  });
}



================================================
FILE: docs/app/api/clerk/webhooks/route.ts
================================================
import { verifyWebhook } from "@clerk/nextjs/webhooks";
import { NextRequest } from "next/server";
import { fetchMutation, fetchQuery } from "convex/nextjs";

import { api } from "@/convex/_generated/api";
import { stripe } from "@/lib/stripe";

export async function POST(req: NextRequest) {
  try {
    const evt = await verifyWebhook(req);
    const { id } = evt.data;
    const eventType = evt.type;

    switch (eventType) {
      case "user.created":
        const stripeCustomer = await stripe.customers.create({
          email: evt.data.email_addresses[0].email_address,
        });

        const stripeSubscription = await stripe.subscriptions.create({
          customer: stripeCustomer.id,
          items: [
            {
              price: process.env.NEXT_PUBLIC_STRIPE_FREE_PLAN_PRICE_ID,
            },
          ],
        });

        const newOrganization = await fetchMutation(
          api.organizations.createOrganization,
          {
            name: "Default",
            createdBy: id!,
            stripeCustomerId: stripeCustomer.id,
            stripeSubscriptionId: stripeSubscription.id,
          }
        );

        await fetchMutation(api.userProfiles.createUserProfile, {
          userId: id!,
          organizationId: newOrganization,
        });
        break;
      case "user.deleted":
        const existingOrganization = await fetchQuery(
          api.organizations.getOrganizationByUserId,
          {
            userId: id!,
          }
        );

        if (!existingOrganization) {
          throw new Error("User does not have an organization");
        }

        const org = existingOrganization as {
          stripeSubscriptionId: string;
          stripeCustomerId: string;
        };

        await stripe.subscriptions.cancel(org.stripeSubscriptionId);
        await stripe.customers.del(org.stripeCustomerId);
        // TODO: Purge account
        break;
    }

    return new Response("Webhook received", { status: 200 });
  } catch (err) {
    console.error("Error verifying webhook:", err);
    return new Response("Error verifying webhook", { status: 400 });
  }
}



================================================
FILE: docs/app/api/embed/route.ts
================================================
import { fetchQuery } from "convex/nextjs";
import { NextRequest, NextResponse } from "next/server";

import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";

// CORS headers for embed endpoint
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
};

// Handle preflight requests
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: corsHeaders,
  });
}

export async function GET(request: NextRequest) {
  // Get the agent ID from query parameters
  const { searchParams } = new URL(request.url);
  const agentId = searchParams.get("agentId");

  // Validate that agentId is provided
  if (!agentId) {
    return NextResponse.json(
      { error: "Agent ID is required" },
      { status: 400, headers: corsHeaders }
    );
  }

  // Fetch the agent by ID
  const agent = await fetchQuery(api.agents.getAgent, {
    id: agentId as Id<"agent">,
  });

  // Check if agent exists
  if (!agent) {
    return NextResponse.json(
      { error: "Agent not found" },
      { status: 404, headers: corsHeaders }
    );
  }

  // Fetch the associated project using the agent's projectId
  const project = await fetchQuery(api.projects.getProject, {
    id: agent.projectId,
  });

  // Check if project exists
  if (!project) {
    return NextResponse.json(
      { error: "Project not found" },
      { status: 404, headers: corsHeaders }
    );
  }

  // Return both agent and project with CORS headers
  return NextResponse.json(
    {
      agent,
      project,
    },
    { headers: corsHeaders }
  );
}



================================================
FILE: docs/app/api/github/auth/callback/route.ts
================================================
import { NextRequest, NextResponse } from "next/server";
import { getGithubAuth } from "@/lib/github";
import { fetchQuery } from "convex/nextjs";
import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";

// CORS headers
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
  "Access-Control-Allow-Credentials": "true",
};

// Handle preflight OPTIONS requests
export async function OPTIONS() {
  return new NextResponse(null, { status: 200, headers: corsHeaders });
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const code = searchParams.get("code");
  const agentId = searchParams.get("state");
  const agent = await fetchQuery(api.agents.getAgent, {
    id: agentId as Id<"agent">,
  });
  const project = await fetchQuery(api.projects.getProject, {
    id: agent?.projectId as Id<"project">,
  });

  const error = searchParams.get("error");

  // Handle OAuth errors
  if (error) {
    const response = NextResponse.redirect(
      new URL(`/?error=${error}`, request.url)
    );
    // Add CORS headers to error response
    Object.entries(corsHeaders).forEach(([key, value]) => {
      response.headers.set(key, value);
    });
    return response;
  }

  if (!code) {
    const response = NextResponse.redirect(
      new URL("/?error=missing_code", request.url)
    );
    // Add CORS headers to error response
    Object.entries(corsHeaders).forEach(([key, value]) => {
      response.headers.set(key, value);
    });
    return response;
  }

  try {
    // Exchange code for access token
    const accessToken = await getGithubAuth(
      project?.githubClientId,
      project?.githubClientSecret
    ).exchangeCodeForToken(code);

    // Get user info
    const user = await getGithubAuth(
      project?.githubClientId,
      project?.githubClientSecret
    ).getUser(accessToken);

    // Create the response with a redirect to close the popup
    const response = NextResponse.redirect(
      new URL("/auth/success", request.url)
    );

    // Add CORS headers
    Object.entries(corsHeaders).forEach(([key, value]) => {
      response.headers.set(key, value);
    });

    // Set the access token in an httpOnly cookie (secure)
    response.cookies.set("github_access_token", accessToken, {
      httpOnly: false,
      secure: true, // Required for sameSite: "none"
      sameSite: "none", // Allow cross-origin access for npm packages
      maxAge: 60 * 60 * 24 * 7, // 7 days
    });

    // Set user info in a readable cookie for the frontend
    response.cookies.set(
      "github_user",
      JSON.stringify({
        id: user.id,
        login: user.login,
        avatar_url: user.avatar_url,
        name: user.name,
      }),
      {
        httpOnly: false,
        secure: true, // Required for sameSite: "none"
        sameSite: "none", // Allow cross-origin access for npm packages
        maxAge: 60 * 60 * 24 * 7, // 7 days
      }
    );

    return response;
  } catch (error) {
    console.error("GitHub OAuth error:", error);
    const response = NextResponse.redirect(
      new URL("/?error=oauth_failed", request.url)
    );
    // Add CORS headers to error response
    Object.entries(corsHeaders).forEach(([key, value]) => {
      response.headers.set(key, value);
    });
    return response;
  }
}



================================================
FILE: docs/app/api/github/auth/url/route.ts
================================================
import { NextResponse } from "next/server";
import { fetchQuery } from "convex/nextjs";

import { getGithubAuth } from "@/lib/github";
import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";

// CORS headers for GitHub auth endpoint
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
};

// Handle preflight requests
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: corsHeaders,
  });
}

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const agentId = searchParams.get("agentId");
    const agent = await fetchQuery(api.agents.getAgent, {
      id: agentId as Id<"agent">,
    });

    if (!agentId) {
      return NextResponse.json(
        { error: "agentId is required" },
        { status: 400, headers: corsHeaders }
      );
    }

    const project = await fetchQuery(api.projects.getProject, {
      id: agent?.projectId as Id<"project">,
    });

    const authUrl = getGithubAuth(
      project?.githubClientId,
      project?.githubClientSecret
    ).getAuthUrl(agentId);

    return NextResponse.json({ url: authUrl }, { headers: corsHeaders });
  } catch (error) {
    console.error("Error generating auth URL:", error);
    return NextResponse.json(
      { error: "Failed to generate auth URL" },
      { status: 500, headers: corsHeaders }
    );
  }
}



================================================
FILE: docs/app/api/github/repositories/route.ts
================================================
import { NextRequest, NextResponse } from "next/server";
import { fetchQuery } from "convex/nextjs";
import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";
import { getGithubAuth } from "@/lib/github";

// CORS headers for GitHub repositories endpoint
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
};

export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: corsHeaders,
  });
}

export async function GET(request: NextRequest) {
  try {
    // Get the access token from the search parameters
    const searchParams = request.nextUrl.searchParams;
    const accessToken = searchParams.get("token");
    const agentId = searchParams.get("agentId");
    const agent = await fetchQuery(api.agents.getAgent, {
      id: agentId as Id<"agent">,
    });
    const project = await fetchQuery(api.projects.getProject, {
      id: agent?.projectId as Id<"project">,
    });

    if (!accessToken) {
      return NextResponse.json(
        { error: "Not authenticated" },
        { status: 401, headers: corsHeaders }
      );
    }

    // Fetch repositories
    const repositories = await getGithubAuth(
      project?.githubClientId,
      project?.githubClientSecret
    ).getUserRepositories(accessToken);

    // Filter to only include repositories the user has push access to
    const userRepos = repositories.filter(
      (repo) =>
        !repo.fork && // Exclude forks
        repo.permissions?.push !== false // Only repos with push access
    );

    return NextResponse.json(
      {
        repositories: userRepos.map((repo) => ({
          id: repo.id,
          name: repo.name,
          full_name: repo.full_name,
          private: repo.private,
          description: repo.description,
          html_url: repo.html_url,
          default_branch: repo.default_branch,
        })),
      },
      { headers: corsHeaders }
    );
  } catch (error) {
    console.error("Error fetching repositories:", error);
    return NextResponse.json(
      { error: "Failed to fetch repositories" },
      { status: 500, headers: corsHeaders }
    );
  }
}



================================================
FILE: docs/app/api/inngest/route.ts
================================================
import { serve } from "inngest/next";
import { inngest, createAgent } from "@/lib/inngest";

export const maxDuration = 800;

// Create an API that serves zero functions
export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [createAgent],
});



================================================
FILE: docs/app/api/vibekit/route.ts
================================================
import { NextRequest, NextResponse } from "next/server";
import { generateClient } from "@/lib/vibekit";

export const maxDuration = 800;

// Add CORS headers to the response
function corsHeaders() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization",
  };
}

// Handle OPTIONS request for CORS preflight
export async function OPTIONS() {
  return NextResponse.json({}, { headers: corsHeaders() });
}

export async function POST(req: NextRequest) {
  try {
    const { repository, instructions, prompt, githubToken } = await req.json();

    if (!githubToken) {
      return NextResponse.json(
        {
          success: false,
          message: "No GitHub token found. Please authenticate first.",
        },
        {
          status: 401,
          headers: corsHeaders(),
        }
      );
    }

    const client = generateClient(githubToken, repository);

    await client.generateCode({
      prompt:
        `## GOAL\nYour goal is to implement the below instructions into the users project.\n` +
        "The user's instructions are based on the provided documentation." +
        " Always reference and follow the documentation when implementing these instructions.\n\n" +
        `#DOCUMENTATION\n${prompt}\n\n#USER INSTRUCTIONS\n${instructions}`,
      mode: "code",
      callbacks: {
        onUpdate(message) {
          console.log(message);
        },
        onError(error) {
          console.error(error);
        },
      },
    });

    await client.createPullRequest();

    return NextResponse.json(
      {
        success: true,
        message: "Integration request submitted successfully!",
      },
      {
        headers: corsHeaders(),
      }
    );
  } catch (error) {
    console.error("Error in /api/vibekit:", error);
    return NextResponse.json(
      {
        success: false,
        message: error instanceof Error ? error.message : "Integration failed",
      },
      {
        status: 500,
        headers: corsHeaders(),
      }
    );
  }
}



================================================
FILE: docs/auth/browser.mdx
================================================
# Browser Usage

For browser/web applications, use the browser-safe import that works without Node.js-specific features like file system access.

## Basic Setup

```typescript
import { ClaudeWebAuth, LocalStorageTokenStorage } from '@vibe-kit/auth/browser';
// OR use the default import which is browser-safe:
// import { ClaudeAuth, LocalStorageTokenStorage } from '@vibe-kit/auth';

// Create storage
const storage = new LocalStorageTokenStorage();
const auth = new ClaudeWebAuth(storage);
```

## Authentication Flow

```typescript
// Create authorization URL
const { url, state, codeVerifier } = ClaudeWebAuth.createAuthorizationUrl();

// Open URL in browser for user authentication
window.open(url, '_blank');

// After user authorizes and provides the code#state string:
const authCode = 'code123#state456'; // From user input
const token = await auth.authenticate(authCode, codeVerifier, state);
```

## Token Management

```typescript
// Check authentication status
const isAuthenticated = await auth.isAuthenticated();

// Get valid token (auto-refresh if needed)
const accessToken = await auth.getValidToken();

// Use token with AI provider APIs
if (!accessToken) {
  // Handle authentication flow...
}
```

## Using with AI Provider APIs

### Claude AI (Available Now)

```typescript
import { ClaudeWebAuth, LocalStorageTokenStorage } from '@vibe-kit/auth/browser';

const storage = new LocalStorageTokenStorage();
const auth = new ClaudeWebAuth(storage);

// Get token (assumes user is already authenticated)
const accessToken = await auth.getValidToken();
if (!accessToken) {
  // Handle authentication flow...
}

// Use with Claude Code CLI
// First, export the token as an environment variable:
// export CLAUDE_CODE_OAUTH_TOKEN=${accessToken}
// claude -p 'Hello!'
```

## Storage Options

Browser environments support multiple storage options:

- **LocalStorageTokenStorage**: Browser localStorage (client-side only)
- **CookieTokenStorage**: Cookie-based storage for SSR applications

```typescript
import { ClaudeWebAuth, LocalStorageTokenStorage, CookieTokenStorage } from '@vibe-kit/auth/browser';

// Using localStorage (most common)
const localAuth = new ClaudeWebAuth(new LocalStorageTokenStorage());

// Using cookies (for SSR)
const cookieAuth = new ClaudeWebAuth(new CookieTokenStorage());
```


================================================
FILE: docs/auth/index.mdx
================================================
---
title: Introduction
description: "Universal OAuth authentication library for AI providers' MAX subscriptions. Currently supports Claude AI with Gemini, Grok, and ChatGPT Max coming soon."
---

The @vibe-kit/auth package provides secure OAuth authentication for AI providers' MAX subscriptions, allowing you to leverage your existing subscriptions programmatically instead of paying per API call.

## Key Features

<CardGroup cols={2}>
  <Card title="MAX Subscription Access" icon="credit-card" color="#888">
    Use your existing AI provider MAX subscriptions instead of pay-per-use APIs
  </Card>
  <Card title="Multiple Providers" icon="network" color="#888">
    Claude AI available now, with Gemini, Grok, and ChatGPT Max coming soon
  </Card>
  <Card title="Secure OAuth 2.0 + PKCE" icon="shield-check" color="#888">
    Industry-standard security with automatic token refresh and secure storage
  </Card>
  <Card title="Universal Compatibility" icon="globe" color="#888">
    Works in both Node.js and browser environments with appropriate builds
  </Card>
</CardGroup>

## Getting Started

<CardGroup cols={2}>
  <Card
    title="Node.js Usage"
    icon="server"
    href="/auth/node"
    color="#888"
  >
    Server-side authentication with automatic browser launching
  </Card>
  <Card
    title="Browser Usage"
    icon="monitor"
    href="/auth/browser"
    color="#888"
  >
    Client-side authentication for web applications
  </Card>
</CardGroup>

## Try It Out

Experience the authentication flow with our interactive demo template:

<Card
  title="Auth Demo Template"
  href="https://github.com/superagent-ai/vibekit/tree/main/templates/auth"
  color="#888"
>
  Complete Next.js application demonstrating OAuth flow with Claude AI
</Card>

## Why Use MAX Subscriptions?

Instead of paying per API call, leverage the subscriptions you already have:

- **Cost Effective**: Use your existing MAX subscriptions instead of pay-per-use APIs
- **Higher Limits**: MAX subscriptions often have higher rate limits and priority access  
- **Latest Models**: Access to the newest and most capable models in each provider's lineup
- **Consistent Experience**: Same interface across different AI providers

Whether you're building a CLI tool, web application, or any project that needs AI capabilities, @vibe-kit/auth provides a secure, scalable authentication foundation that works with your existing subscriptions.


================================================
FILE: docs/auth/node.mdx
================================================
# Node.js Usage

For Node.js applications (CLI tools, servers, etc.), use the Node.js-specific import for full functionality including file system access and automatic browser launching.

## Basic Usage

```typescript
import { ClaudeAuth } from '@vibe-kit/auth/node';

// Start OAuth flow (opens browser automatically)
const token = await ClaudeAuth.authenticate();

// Check if authenticated
const isAuthenticated = await ClaudeAuth.isAuthenticated();

// Get valid token (auto-refresh if needed)
const accessToken = await ClaudeAuth.getValidToken();

// Verify authentication
const isValid = await ClaudeAuth.verify();

// Get authentication status
const status = await ClaudeAuth.getStatus();

// Logout
await ClaudeAuth.logout();
```

## Token Import/Export

Node.js environments support importing and exporting tokens in various formats:

```typescript
import { ClaudeAuth } from '@vibe-kit/auth/node';

// Export token in different formats
const envToken = await ClaudeAuth.exportToken('env');
const jsonToken = await ClaudeAuth.exportToken('json');
const fullToken = await ClaudeAuth.exportToken('full');

// Import from various sources
await ClaudeAuth.importToken({ fromEnv: true });
await ClaudeAuth.importToken({ fromFile: './token.json' });
await ClaudeAuth.importToken({ refreshToken: 'your-refresh-token' });
```

## Using with AI Provider APIs

### Claude AI (Available Now)

```typescript
import { ClaudeAuth } from '@vibe-kit/auth/node';

// Authenticate and get token
let accessToken = await ClaudeAuth.getValidToken();
if (!accessToken) {
  await ClaudeAuth.authenticate();
  accessToken = await ClaudeAuth.getValidToken();
}

// Use with Claude Code CLI
// First, export the token as an environment variable:
// export CLAUDE_CODE_OAUTH_TOKEN=${accessToken}
// claude -p 'Hello, Claude!'
```

### With Official SDKs

```typescript
// Claude AI with Anthropic SDK
import Anthropic from '@anthropic-ai/sdk';
import { ClaudeAuth } from '@vibe-kit/auth/node';

const accessToken = await ClaudeAuth.getValidToken();
const anthropic = new Anthropic({
  apiKey: '', // Leave empty for OAuth
  authToken: accessToken, // Use your MAX subscription token
});

const message = await anthropic.messages.create({
  model: 'claude-sonnet-4-20250514',
  max_tokens: 1000,
  messages: [{ role: 'user', content: 'Hello!' }]
});
```

## Storage Options

Node.js environments use **MemoryTokenStorage** by default, providing in-memory storage for server-side applications with secure file system token persistence.


================================================
FILE: docs/auth/overview.mdx
================================================
Universal OAuth authentication library for AI providers' MAX subscriptions. Currently supports Claude AI with Gemini, Grok, and ChatGPT Max coming soon.

## Features

- **MAX Subscription Access**: Leverage your existing AI provider MAX subscriptions programmatically
- **Multiple Providers**: Claude AI (available), Gemini, Grok, ChatGPT Max (coming soon)
- **Environment-Specific Builds**: Separate Node.js and browser-compatible builds
- **OAuth 2.0 + PKCE**: Secure authentication with industry standards
- **Token Management**: Automatic token refresh and secure storage
- **Browser & Node.js**: Works in both web applications and server environments

## Why Use MAX Subscriptions?

Instead of paying per API call, leverage the subscriptions you already have:

- **Cost Effective**: Use your existing MAX subscriptions instead of pay-per-use APIs
- **Higher Limits**: MAX subscriptions often have higher rate limits and priority access
- **Latest Models**: Access to the newest and most capable models in each provider's lineup
- **Consistent Experience**: Same interface across different AI providers

## Installation

```bash
npm install @vibe-kit/auth
```

## Environment Compatibility

- **Node.js**: Use `@vibe-kit/auth/node` for full functionality including file system access and browser launching
- **Browser**: Use `@vibe-kit/auth/browser` or default import for browser-safe functionality
- **Universal**: The default import provides browser-safe functionality that works everywhere

## Security

- Tokens are stored with restricted file permissions (CLI)
- Automatic token refresh prevents expired token usage
- PKCE (Proof Key for Code Exchange) for secure OAuth flows
- State parameter validation prevents CSRF attacks


================================================
FILE: docs/auth/types.mdx
================================================
# Types & API Reference

## Core Types

### OAuthToken

The main token interface used throughout the authentication library:

```typescript
interface OAuthToken {
  access_token: string;
  token_type: string;
  expires_in?: number;
  refresh_token?: string;
  scope?: string;
  created_at: number;
}
```

## Authentication Methods

### ClaudeAuth (Node.js)

Static methods available when using `@vibe-kit/auth/node`:

```typescript
class ClaudeAuth {
  // Start OAuth flow (opens browser automatically)
  static authenticate(): Promise<OAuthToken>;
  
  // Check if user is authenticated
  static isAuthenticated(): Promise<boolean>;
  
  // Get valid token (auto-refresh if needed)
  static getValidToken(): Promise<string | null>;
  
  // Verify current authentication
  static verify(): Promise<boolean>;
  
  // Get authentication status
  static getStatus(): Promise<any>;
  
  // Logout and clear tokens
  static logout(): Promise<void>;
  
  // Export token in different formats
  static exportToken(format: 'env' | 'json' | 'full'): Promise<string>;
  
  // Import token from various sources
  static importToken(options: {
    fromEnv?: boolean;
    fromFile?: string;
    refreshToken?: string;
  }): Promise<void>;
}
```

### ClaudeWebAuth (Browser)

Instance-based authentication for browser environments:

```typescript
class ClaudeWebAuth {
  constructor(storage: TokenStorage);
  
  // Create authorization URL with PKCE
  static createAuthorizationUrl(): {
    url: string;
    state: string;
    codeVerifier: string;
  };
  
  // Complete authentication with auth code
  authenticate(
    authCode: string, 
    codeVerifier: string, 
    state: string
  ): Promise<OAuthToken>;
  
  // Check if authenticated
  isAuthenticated(): Promise<boolean>;
  
  // Get valid token (auto-refresh if needed)
  getValidToken(): Promise<string | null>;
}
```

## Storage Interfaces

### TokenStorage

Base interface for token storage implementations:

```typescript
interface TokenStorage {
  store(token: OAuthToken): Promise<void>;
  retrieve(): Promise<OAuthToken | null>;
  clear(): Promise<void>;
}
```

### Available Implementations

- **MemoryTokenStorage**: In-memory storage for server-side use
- **LocalStorageTokenStorage**: Browser localStorage (client-side only)  
- **CookieTokenStorage**: Cookie-based storage for SSR applications

## Coming Soon

Additional provider support with similar interfaces:

- **Gemini Max**: Access Google's most advanced AI models
- **Grok Max**: Leverage xAI's premium models  
- **ChatGPT Max**: Use OpenAI's latest models


================================================
FILE: docs/cli/agent-support.mdx
================================================
---
title: Universal Agent Support
description: "Works with Claude Code, Gemini, Codex, Cursor Agent, and OpenCode - providing consistent security and observability across all coding agents."
---

VibeKit CLI provides universal support for popular coding agents, giving you consistent security, observability, and management features regardless of which AI coding assistant you use.

## Supported Agents

### Claude Code
Anthropic's Claude Code CLI with enhanced security:
```bash
# Run Claude Code through VibeKit
vibekit claude "Help me refactor this React component"

# With sandbox enabled
vibekit claude --sandbox "Debug this API issue"

# Pass arguments directly to Claude CLI
vibekit claude --help
```

### Gemini
Google's Gemini with VibeKit protection:
```bash
# Run Gemini with VibeKit features
vibekit gemini "Generate a Python data analysis script"

# With sandbox isolation
vibekit gemini --sandbox-type docker "Write comprehensive tests"
```

### Codex
OpenAI's Codex with monitoring:
```bash
# Run Codex through VibeKit
vibekit codex "Convert this JavaScript to TypeScript"

# All VibeKit features apply to Codex
vibekit codex --sandbox "Generate production-ready code"
```

### Cursor Agent
Cursor's AI agent with VibeKit wrapper:
```bash
# Run Cursor Agent through VibeKit
vibekit cursor-agent "Help me implement this feature"

# With logging and proxy features
vibekit cursor-agent --sandbox-type podman "Review this code"
```

### OpenCode
Open-source coding agent integration:
```bash
# OpenCode with VibeKit features
vibekit opencode "Help with Rust memory management"

# Full VibeKit feature support
vibekit opencode --sandbox "Optimize this algorithm"
```

## Universal Features

### Consistent Security
Every agent gets the same security protections:
- **Proxy Server**: All agent traffic routed through redaction proxy
- **Sandbox Support**: Optional Docker/Podman isolation for all agents
- **Redaction**: Sensitive data removal across all agents
- **Logging**: Structured logging for all agent interactions

### Common Options
All agents support the same VibeKit options:
```bash
# Sandbox options work with any agent
vibekit [agent] --sandbox
vibekit [agent] --sandbox-type docker

# Global proxy configuration applies to all
vibekit [agent] --proxy http://localhost:8080
```

### Unified Logging
Same observability features for all agents:
```bash
# View logs from any agent
vibekit logs --agent claude
vibekit logs --agent gemini
vibekit logs --agent codex

# Analytics for specific agents
vibekit analytics --agent cursor-agent
```

### Cross-Agent Analytics
Compare and analyze different agents:
```bash
# View analytics across all agents
vibekit analytics

# Multi-agent breakdown shows performance comparison
# Output includes per-agent session counts, success rates, etc.
```

## Configuration

### Global Settings
VibeKit settings apply to all agents:
```json
{
  "sandbox": {
    "enabled": false,
    "type": "docker"
  },
  "proxy": {
    "enabled": true,
    "redactionEnabled": true
  },
  "analytics": {
    "enabled": true
  }
}
```

### Environment Variables
```bash
# Agent-specific API keys (set by underlying CLIs)
export ANTHROPIC_API_KEY="your-claude-key"
export GEMINI_API_KEY="your-gemini-key" 
export OPENAI_API_KEY="your-openai-key"

# VibeKit global settings
export VIBEKIT_SANDBOX=true
export VIBEKIT_DEBUG=true
```

### Settings Management
```bash
# Open settings interface (works for all agents)
vibekit

# Settings affect all agents uniformly
```

## How Agent Wrapping Works

### Command Forwarding
VibeKit acts as a wrapper around existing agent CLIs:
- Forwards all unknown options to the underlying agent
- Adds VibeKit-specific options (`--sandbox`, `--sandbox-type`)
- Applies consistent logging, proxy, and analytics features

### Example Flow
```bash
vibekit claude "help me code" --some-claude-option

# 1. VibeKit processes its own options (--sandbox, etc.)
# 2. Starts proxy server if needed
# 3. Forwards "help me code" and "--some-claude-option" to claude CLI
# 4. Logs the session and captures analytics
```

### Agent Requirements
VibeKit assumes the underlying agent CLIs are installed:
- `claude` command for Claude Code CLI
- `gemini` command for Gemini CLI
- `codex` command for Codex CLI
- `cursor-agent` command for Cursor Agent
- `opencode` command for OpenCode

## Current Implementation

### What's Implemented
- **Command Wrapping**: All agents get proxy, logging, analytics
- **Consistent Options**: Same sandbox and proxy options for all
- **Unified Analytics**: Cross-agent session tracking and comparison
- **Settings Integration**: Global settings affect all agents

### Agent Status
All supported agents use the same architecture:
- Proxy server for redaction (when enabled)
- Structured logging to `~/.vibekit/logs/`
- Analytics tracking in `~/.vibekit/analytics/`
- Optional sandbox execution

## Best Practices

### Agent Selection
Choose agents based on their strengths:
- **Claude**: Complex reasoning, detailed analysis
- **Gemini**: Multimodal capabilities, diverse tasks
- **Codex**: Code completion and generation
- **Cursor Agent**: IDE-integrated workflows
- **OpenCode**: Open-source flexibility

### Consistent Workflow
- Use same VibeKit options across agents for consistency
- Monitor analytics to compare agent effectiveness
- Apply same security settings (sandbox, redaction) to all agents
- Regular log review for all agent activities

### Security
- Enable redaction for all agents handling sensitive code
- Use sandbox mode when working with untrusted operations
- Monitor proxy logs for unexpected data patterns
- Keep all agent CLIs updated for security

Universal agent support provides a consistent security and observability layer across different AI coding assistants, letting you choose the best tool for each task while maintaining unified monitoring and protection.


================================================
FILE: docs/cli/configuration-files.mdx
================================================
---
title: Configuration Files
description: "Understanding and managing VibeKit CLI configuration files"
---

## Overview

VibeKit CLI stores configuration and data in the `~/.vibekit/` directory. These files control sandbox behavior, proxy settings, analytics, and logging preferences.

## File Locations

### User Configuration Directory

All VibeKit CLI files are stored in `~/.vibekit/`:

| File | Location | Purpose |
|------|----------|---------|
| `settings.json` | `~/.vibekit/settings.json` | User preferences and feature toggles |
| `logs/` | `~/.vibekit/logs/` | Agent interaction logs by date |
| `analytics/` | `~/.vibekit/analytics/` | Usage statistics and performance data |

### Project Files

| File | Location | Purpose |
|------|----------|---------|
| `.env` | Project root | Environment variables (API keys) |

## Settings Configuration

### ~/.vibekit/settings.json

Controls VibeKit CLI behavior and features:

```json
{
  "sandbox": {
    "enabled": false
  },
  "proxy": {
    "enabled": true,
    "redactionEnabled": true
  },
  "analytics": {
    "enabled": true
  },
  "aliases": {
    "enabled": false
  }
}
```

### Settings Options

#### Sandbox Settings

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `sandbox.enabled` | `boolean` | `false` | Enable Docker sandbox by default |

When enabled, agents run in Docker containers instead of directly on your system.

#### Proxy Settings

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `proxy.enabled` | `boolean` | `true` | Enable proxy server for request logging |
| `proxy.redactionEnabled` | `boolean` | `true` | Redact PII from logged requests |

The proxy server logs all API requests/responses and can redact sensitive information.

#### Analytics Settings

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `analytics.enabled` | `boolean` | `true` | Track usage statistics and performance |

Analytics track session duration, success rates, and error patterns.

#### Aliases Settings

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `aliases.enabled` | `boolean` | `false` | Enable global command aliases |

When enabled, you can use `claude` instead of `vibekit claude`.

## Managing Settings

### Interactive Settings

Use the interactive settings interface:

```bash
vibekit
```

This provides a TUI for toggling options:
- Navigate with arrow keys
- Toggle with space bar
- Save with enter

### Manual Editing

Edit settings directly:

```bash
# Open in editor
vi ~/.vibekit/settings.json

# Validate JSON
cat ~/.vibekit/settings.json | jq '.'
```

## Environment Variables

### API Keys

Set API keys for your agents:

```bash
# Claude Code CLI
export ANTHROPIC_API_KEY="sk-ant-..."

# Gemini CLI (when available)
export GOOGLE_API_KEY="..."

# Add to shell profile for persistence
echo 'export ANTHROPIC_API_KEY="sk-ant-..."' >> ~/.zshrc
source ~/.zshrc
```

### Proxy Configuration

Configure proxy settings:

```bash
# Use external proxy
export HTTP_PROXY="http://proxy.example.com:8080"
export HTTPS_PROXY="http://proxy.example.com:8080"

# Enable debug logging
export VIBEKIT_DEBUG="1"
```

### Project-Level Environment

Create `.env` file in your project:

```bash
# .env
ANTHROPIC_API_KEY=sk-ant-...
GOOGLE_API_KEY=...

# Custom environment variables for your project
DATABASE_URL=postgresql://...
API_BASE_URL=https://api.example.com
```

## Data Storage

### Log Files

Logs are organized by date in `~/.vibekit/logs/`:

```
~/.vibekit/logs/
â”œâ”€â”€ 2024-01-15/
â”‚   â”œâ”€â”€ claude-10-30-00.log
â”‚   â”œâ”€â”€ claude-14-45-12.log
â”‚   â””â”€â”€ gemini-16-20-35.log
â”œâ”€â”€ 2024-01-16/
â”‚   â””â”€â”€ claude-09-15-42.log
```

Each log file contains:
- Agent commands and arguments
- Execution output and errors
- Performance timings
- File changes made

### Analytics Data

Analytics are stored in `~/.vibekit/analytics/`:

```
~/.vibekit/analytics/
â”œâ”€â”€ sessions/
â”‚   â”œâ”€â”€ claude-2024-01-15.json
â”‚   â””â”€â”€ gemini-2024-01-15.json
â””â”€â”€ summary.json
```

Data includes:
- Session duration and outcome
- Commands executed
- Files modified
- Error messages and warnings

## Global Aliases

### Setting Up Aliases

Enable global aliases to use `claude` directly:

```bash
# Enable in settings
vibekit  # Toggle aliases to enabled

# Install aliases to shell
vibekit setup-aliases

# Restart terminal or reload shell
source ~/.zshrc
```

### Using Aliases

After setup, use commands directly:

```bash
# Instead of: vibekit claude "Generate code"
claude "Generate code"

# Instead of: vibekit gemini "Ask question"
gemini "Ask question"
```

### Diagnosing Alias Issues

Check alias setup:

```bash
vibekit diagnose-aliases
```

This shows:
- Settings status
- VibeKit command availability
- Shell alias functionality
- Current active aliases

## Configuration Precedence

Settings are applied in this order (later overrides earlier):

1. Built-in defaults
2. Settings file (`~/.vibekit/settings.json`)
3. Environment variables
4. Command line options

Example:
```bash
# Settings: sandbox.enabled = false
# Environment: (none)
# Command line wins:
vibekit claude --sandbox docker "Generate code"
```

## Backup and Restore

### Manual Backup

Create backup of all VibeKit data:

```bash
# Create timestamped backup
BACKUP_DIR="$HOME/vibekit-backup-$(date +%Y%m%d-%H%M%S)"
cp -r ~/.vibekit "$BACKUP_DIR"
tar -czf "$BACKUP_DIR.tar.gz" -C "$HOME" "$(basename "$BACKUP_DIR")"
rm -rf "$BACKUP_DIR"

echo "Backup created: $BACKUP_DIR.tar.gz"
```

### Restore Configuration

```bash
# Restore from backup
tar -xzf ~/vibekit-backup-20240115-103000.tar.gz -C ~/
mv ~/vibekit-backup-20240115-103000 ~/.vibekit
```

## Maintenance

### Clean Data

Remove old logs and analytics:

```bash
# Clean all data
vibekit clean

# Clean specific data types
vibekit clean --logs      # Remove log files
vibekit clean --analytics # Remove analytics data
vibekit clean --docker   # Remove Docker resources
```

### Reset Configuration

Reset settings to defaults:

```bash
# Remove settings file (will recreate with defaults)
rm ~/.vibekit/settings.json

# Or reset all data (careful!)
rm -rf ~/.vibekit
```

## Troubleshooting

### Corrupted Settings

Check settings file validity:

```bash
# Validate JSON
jq '.' ~/.vibekit/settings.json

# Fix corrupted file
echo '{}' > ~/.vibekit/settings.json
```

### Permission Issues

Fix file permissions:

```bash
# Ensure proper ownership and permissions
chmod 700 ~/.vibekit
find ~/.vibekit -type f -exec chmod 600 {} \;

# Check current permissions
ls -la ~/.vibekit/
```

### Missing Dependencies

Check for required tools:

```bash
# Check for Claude Code CLI
claude --version

# Check for Docker (if using sandbox)
docker --version

# Diagnose common issues
vibekit diagnose-aliases
```

## Best Practices

### 1. Secure API Keys

Never commit API keys to version control:

```bash
# .gitignore
.env
*.log
```

Use environment variables or secure storage.

### 2. Regular Cleanup

Set up automatic cleanup:

```bash
# Add to crontab for weekly cleanup
0 0 * * 0 vibekit clean --logs
```

### 3. Monitor Usage

Use analytics to understand your usage patterns:

```bash
# Weekly usage review
vibekit analytics --days 7 --summary

# Export for analysis
vibekit analytics --export weekly-report.json --days 7
```

### 4. Safe Experimentation

Enable Docker sandbox for unknown or experimental prompts:

```bash
# Enable sandbox in settings for safety
vibekit

# Or use per-command
vibekit claude --sandbox docker "Experimental code generation"
```

## Related Topics

- [Environment Variables](/cli/environment-variables) - Runtime configuration
- [Installation](/cli/installation) - Initial setup
- [Quick Reference](/cli/quick-reference) - Common commands


================================================
FILE: docs/cli/environment-variables.mdx
================================================
---
title: Environment Variables
description: "Complete reference for environment variables used by the VibeKit CLI"
---

## Overview

The VibeKit CLI uses environment variables for configuration, API keys, and integration settings. These can be set in your shell, `.env` files, or passed directly to commands.

## API Keys

### AI Agent Keys

Configure API keys for different AI providers:

| Variable | Description | Required For |
|----------|-------------|--------------|
| `ANTHROPIC_API_KEY` | Anthropic API key for Claude | `--agent claude` |
| `OPENAI_API_KEY` | OpenAI API key | `--agent codex` |
| `GOOGLE_API_KEY` | Google API key | `--agent gemini` |
| `GROQ_API_KEY` | Groq API key | `--agent opencode` |

Example:
```bash
export ANTHROPIC_API_KEY="sk-ant-api03-..."
export OPENAI_API_KEY="sk-..."
export GOOGLE_API_KEY="AIza..."
export GROQ_API_KEY="gsk_..."

### Priority Order

API keys are resolved in this order:
1. Command line `--api-key` option
2. Environment-specific API key variable
3. Environment variables passed via `--env`
4. `.env` file in current directory

## GitHub Integration

### Authentication

| Variable | Description | Required For |
|----------|-------------|--------------|
| `GITHUB_TOKEN` | Personal access token | PR creation, Git operations |
| `GITHUB_REPOSITORY` | Repository in `owner/repo` format | PR creation |

Example:
```bash
export GITHUB_TOKEN="ghp_xxxxxxxxxxxxxxxxxxxx"
export GITHUB_REPOSITORY="myorg/myrepo"

### Token Permissions

Required GitHub token scopes:
- `repo` - Full repository access
- `write:pull_requests` - Create PRs
- `read:user` - Read user profile

## Provider Configuration

### Dagger (Local Provider)

| Variable | Description | Default |
|----------|-------------|---------|
| `VIBEKIT_PREFER_REGISTRY_IMAGES` | Use Docker Hub images instead of local builds | `false` |
| `DOCKER_USERNAME` | Docker Hub username for image uploads | None |

Example:
```bash
export VIBEKIT_PREFER_REGISTRY_IMAGES="true"
export DOCKER_USERNAME="myusername"

### Northflank

| Variable | Description | Default |
|----------|-------------|---------|
| `NORTHFLANK_PROJECT_ID` | Default project ID for Northflank | None |
| `NORTHFLANK_API_TOKEN` | Northflank API token | None |

### Daytona

| Variable | Description | Default |
|----------|-------------|---------|
| `DAYTONA_WORKSPACE_ID` | Default workspace ID | None |
| `DAYTONA_API_TOKEN` | Daytona API token | None |

### E2B

| Variable | Description | Default |
|----------|-------------|---------|
| `E2B_API_KEY` | E2B API key | None |
| `E2B_TEAM_ID` | E2B team identifier | None |


## Default Settings

### Resource Allocation

| Variable | Description | Default |
|----------|-------------|---------|
| `VIBEKIT_DEFAULT_CPU` | Default CPU cores for environments | 2 |
| `VIBEKIT_DEFAULT_MEMORY` | Default memory in MB | 2048 |
| `VIBEKIT_DEFAULT_DISK` | Default disk space in GB | 20 |

Example:
```bash
export VIBEKIT_DEFAULT_CPU="4"
export VIBEKIT_DEFAULT_MEMORY="4096"
export VIBEKIT_DEFAULT_DISK="50"

### Behavior Settings

| Variable | Description | Default |
|----------|-------------|---------|
| `VIBEKIT_DEFAULT_AGENT` | Default AI agent type | None |
| `VIBEKIT_DEFAULT_TIMEOUT` | Default command timeout in ms | 30000 |
| `VIBEKIT_AUTO_CLEANUP` | Auto-delete stopped environments | `false` |

## Development Settings

### Debug Options

| Variable | Description | Default |
|----------|-------------|---------|
| `VIBEKIT_DEBUG` | Enable debug logging | `false` |
| `VIBEKIT_LOG_LEVEL` | Log level (error, warn, info, debug) | `info` |
| `VIBEKIT_LOG_FILE` | Log output file | None (stdout) |

Example:
```bash
export VIBEKIT_DEBUG="true"
export VIBEKIT_LOG_LEVEL="debug"
export VIBEKIT_LOG_FILE="/tmp/vibekit.log"

## Using .env Files

### File Location

The CLI automatically loads `.env` files from:
1. Current working directory
2. Project root (if in a git repository)
3. Home directory (`~/.env`)

### .env File Format

```bash
# .env
# AI API Keys
ANTHROPIC_API_KEY=sk-ant-api03-...
OPENAI_API_KEY=sk-...

# GitHub Integration
GITHUB_TOKEN=ghp_...
GITHUB_REPOSITORY=owner/repo

# Provider Settings
DOCKER_USERNAME=myusername
NORTHFLANK_PROJECT_ID=proj_123

# Defaults
VIBEKIT_DEFAULT_AGENT=claude
VIBEKIT_DEFAULT_MEMORY=4096

# Debug
VIBEKIT_DEBUG=true

### Security Best Practices

1. **Never commit `.env` files** - Add to `.gitignore`
2. **Use `.env.example`** - Template without secrets
3. **Restrict permissions** - `chmod 600 .env`
4. **Rotate keys regularly** - Update API keys periodically

## Command-Specific Variables

### vibekit init

Additional variables during initialization:
```bash
# Skip interactive prompts
export VIBEKIT_INIT_PROVIDERS="Dagger,E2B"
export VIBEKIT_INIT_AGENTS="claude,codex"
export VIBEKIT_INIT_CPU="4"
export VIBEKIT_INIT_MEMORY="4096"

### vibekit local create

Override defaults for environment creation:
```bash
# Set working directory
export VIBEKIT_WORKING_DIR="/app"

# Set default environment variables
export VIBEKIT_ENV_VARS="NODE_ENV=development,PORT=3000"

## Precedence Rules

Environment variables are loaded in this order (later overrides earlier):

1. System environment variables
2. `~/.env` file
3. Project `.env` file
4. Current directory `.env` file
5. Command line options

Example:
```bash
# System env
export ANTHROPIC_API_KEY="old-key"

# .env file
ANTHROPIC_API_KEY=new-key

# Command line (highest priority)
vibekit local create --api-key "newest-key"

## Validation

### Checking Variables

View current settings:
```bash
# All environment variables
env | grep VIBEKIT

# Specific variable
echo $ANTHROPIC_API_KEY

# In environment
vibekit local exec -e my-env -c "env | grep API"

### Required Variables

Commands will fail with clear messages if required variables are missing:
âŒ No API key found for claude agent. 
Set ANTHROPIC_API_KEY environment variable or use --api-key

## Troubleshooting

### Variables Not Loading

```bash
# Check if .env exists
ls -la .env

# Verify format
cat .env

# Test loading
source .env
echo $ANTHROPIC_API_KEY

### Permission Issues

```bash
# Fix .env permissions
chmod 600 .env

# Check ownership
ls -l .env

### Debugging Variable Loading

```bash
# Enable debug mode
export VIBEKIT_DEBUG=true

# Run command to see variable loading
vibekit local create --name test

## Best Practices

### 1. Use .env.example

Create a template for team members:
```bash
# .env.example
ANTHROPIC_API_KEY=your-anthropic-key-here
OPENAI_API_KEY=your-openai-key-here
GITHUB_TOKEN=your-github-token-here
GITHUB_REPOSITORY=owner/repo

### 2. Separate Environments

Use different files for different environments:
```bash
# .env.development
VIBEKIT_DEFAULT_AGENT=codex
VIBEKIT_DEBUG=true

# .env.production
VIBEKIT_DEFAULT_AGENT=claude
VIBEKIT_DEBUG=false

### 3. Security Script

Check for exposed secrets:
```bash
#!/bin/bash
# check-secrets.sh
files=".env .env.* *.env"
for file in $files; do
  if [ -f "$file" ]; then
    if grep -q "sk-\|ghp_\|gsk_" "$file"; then
      echo "WARNING: $file might contain secrets"
      ls -la "$file"
    fi
  fi
done

## Related Topics

- [Configuration Files](/cli/configuration-files) - Other configuration options
- [Installation](/cli/installation) - Initial setup and configuration
- [Quick Reference](/cli/quick-reference) - Common variable usage


================================================
FILE: docs/cli/index.mdx
================================================
---
title: Introduction
description: "VibeKit is a safety layer for your coding agent. Run Claude Code, Gemini, Codex â€” or any coding agent â€” in a clean, isolated sandbox with sensitive data redaction and observability baked in."
---

<img
  src="/images/vibekit-cli.png"
  alt="Dashboard"
/>

## Key Features

<CardGroup cols={2}>
  <Card title="Local Sandbox" icon="container" color="#888">
    Runs agent output in isolated Docker containers â€” zero risk to your local setup
  </Card>
  <Card title="Built-in Redaction" icon="shield-check" color="#888">
    Auto-removes secrets, API keys, and other sensitive data from completions
  </Card>
  <Card title="Observability" icon="chart-line" color="#888">
    Complete visibility into agent operations with real-time logs, traces, and metrics
  </Card>
  <Card title="Universal Agent Support" icon="bot" color="#888">
    Works with Claude Code, Gemini CLI, Grok CLI, Codex CLI, OpenCode, and more
  </Card>
</CardGroup>

## Getting Started

<CardGroup cols={2}>
  <Card
    title="Installation"
    icon="download"
    href="/cli/installation"
    color="#888"
  >
    Install the VibeKit CLI and get started in minutes
  </Card>
  <Card
    title="Quick Reference"
    icon="book-open"
    href="/cli/quick-reference"
    color="#888"
  >
    Common commands and workflows for daily use
  </Card>
</CardGroup>

## Try It Out

Get started with VibeKit CLI in seconds:

```bash
# Install globally
npm install -g vibekit

# Run Claude Code with enhanced security
vibekit claude
```

## Why Use VibeKit CLI?

Instead of running coding agents directly on your machine, VibeKit provides crucial safety and visibility:

- **Zero Risk**: Isolated Docker containers prevent any damage to your local environment
- **Security First**: Built-in redaction removes sensitive data from agent completions automatically  
- **Full Visibility**: Complete observability into what your coding agents are actually doing
- **Works Offline**: No cloud dependencies or internet required â€” works entirely on your machine

Whether you're using Claude Code for development, integrating AI agents into your workflow, or building applications that need secure code execution, VibeKit CLI provides the safety foundation you need to use coding agents with confidence.


================================================
FILE: docs/cli/installation.mdx
================================================
---
title: Installation
description: "How to install and set up the VibeKit CLI on your system"
---

## Prerequisites

Before installing the VibeKit CLI, ensure you have:

- **Node.js** version 18.0.0 or higher
- **npm** or **yarn** package manager
- **Docker** installed and running (optional, for maximum security)
- **Claude Code CLI** or **Gemini CLI** for the agents you want to use

## Installation Methods

### Global Installation (Recommended)

Installing globally makes the `vibekit` command available system-wide:

<CodeGroup>
```bash npm
npm install -g vibekit
```

```bash yarn
yarn global add vibekit
```

```bash pnpm
pnpm add -g vibekit
```
</CodeGroup>

### Project Installation

For project-specific installations:

<CodeGroup>
```bash npm
npm install --save-dev vibekit
```

```bash yarn
yarn add --dev vibekit
```

```bash pnpm
pnpm add -D vibekit
```
</CodeGroup>

### Using npx (No Installation)

Run commands without installing:

```bash
npx vibekit claude "Generate a REST API"
npx vibekit dashboard
```

## Verify Installation

After installation, verify that the CLI is working:

```bash
# Check version
vibekit --version

# View help
vibekit --help
```

## Post-Installation Setup

### 1. Install Required Agents

Install the coding agents you want to use:

```bash
# Install Claude Code CLI
npm install -g @anthropic/claude-code

# Install Gemini CLI (if available)
# Follow Gemini CLI installation instructions
```

### 2. Configure Environment Variables

Set up your API keys:

```bash
# For Claude
export ANTHROPIC_API_KEY="sk-ant-..."

# For Gemini
export GOOGLE_API_KEY="..."

# For proxy configuration (optional)
export HTTP_PROXY="http://proxy.example.com:8080"
```

Or add them to your shell profile (`~/.bashrc`, `~/.zshrc`):

```bash
echo 'export ANTHROPIC_API_KEY="sk-ant-..."' >> ~/.zshrc
source ~/.zshrc
```

### 3. Configure Settings (Optional)

Run the settings interface to configure VibeKit:

```bash
vibekit
```

This allows you to:
- Enable/disable Docker sandbox
- Configure proxy server settings
- Enable/disable analytics
- Set up global aliases

### 4. Docker Setup (Optional)

For maximum security, ensure Docker is running:

```bash
# Check Docker status
docker info

# Start Docker daemon if needed
# On macOS: Open Docker Desktop
# On Linux: sudo systemctl start docker
```

## Troubleshooting Installation

### Command Not Found

If `vibekit` command is not found after global installation:

<Tabs>
  <Tab title="npm">
    ```bash
    # Check npm global bin directory
    npm config get prefix

    # Add to PATH (example for macOS/Linux)
    export PATH="$(npm config get prefix)/bin:$PATH"

    # Make permanent by adding to ~/.bashrc or ~/.zshrc
    echo 'export PATH="$(npm config get prefix)/bin:$PATH"' >> ~/.bashrc
    ```
  </Tab>
  <Tab title="yarn">
    ```bash
    # Check yarn global bin directory
    yarn global bin

    # Add to PATH
    export PATH="$(yarn global bin):$PATH"
    ```
  </Tab>
</Tabs>

### Permission Errors

If you encounter permission errors during global installation:

```bash
# Option 1: Use a Node version manager (recommended)
# Install nvm: https://github.com/nvm-sh/nvm
nvm install node
npm install -g vibekit

# Option 2: Change npm's default directory
mkdir ~/.npm-global
npm config set prefix '~/.npm-global'
export PATH=~/.npm-global/bin:$PATH
npm install -g vibekit
```

### Docker Not Running (Optional)

If you want to use Docker sandbox and see Docker-related errors:

```bash
# Check if Docker is installed
docker --version

# Check if Docker daemon is running
docker ps

# Start Docker
# macOS: Open Docker Desktop application
# Linux: sudo systemctl start docker
# Windows: Start Docker Desktop
```

### Agent Not Found

If you see "command not found" errors for Claude or Gemini:

```bash
# For Claude Code CLI
npm install -g @anthropic/claude-code

# Verify installation
claude --version

# Set up global aliases (optional)
vibekit setup-aliases
```

## Platform-Specific Notes

### macOS
- Docker Desktop is recommended
- May need to grant terminal permissions for Docker
- Homebrew users can install Node.js with `brew install node`

### Linux
- Add your user to the docker group: `sudo usermod -aG docker $USER`
- Log out and back in for group changes to take effect
- Some distributions may require `sudo` for global npm installs

### Windows
- Use WSL2 for best compatibility
- Docker Desktop with WSL2 backend is recommended
- Run commands in WSL2 terminal, not Command Prompt

## Updating the CLI

To update to the latest version:

<CodeGroup>
```bash npm
npm update -g vibekit
```

```bash yarn
yarn global upgrade vibekit
```

```bash npx
# npx always uses the latest version
npx vibekit@latest
```
</CodeGroup>

## Uninstalling

To remove the CLI:

<CodeGroup>
```bash npm
npm uninstall -g vibekit
```

```bash yarn
yarn global remove vibekit
```
</CodeGroup>

## Next Steps

After installation, you're ready to:

1. [Configure settings](/cli/configuration-files) with `vibekit`
2. [Run your first agent](/cli/quick-reference) with `vibekit claude "Hello world"`
3. [Set up monitoring](/cli/quick-reference) with `vibekit dashboard`

For a quick overview of all commands, see the [Quick Reference](/cli/quick-reference).


================================================
FILE: docs/cli/local-sandbox.mdx
================================================
---
title: Local Sandbox
description: "Optional Docker container isolation for running AI coding agents with filesystem protection."
---

VibeKit's local sandbox feature optionally runs coding agents inside Docker containers, providing isolation from your host system. The sandbox functionality is available but not enabled by default.

## How It Works

When sandbox mode is enabled, VibeKit creates isolated Docker containers to run coding agents:

- **Container Isolation**: Agent processes run inside Docker containers
- **Filesystem Control**: Limited access to host filesystem through controlled mounts
- **Runtime Support**: Works with Docker or Podman
- **Optional Feature**: Sandbox can be enabled per-command or via settings

## Configuration

### Enable Sandbox Mode
```bash
# Enable sandbox for a single command
vibekit claude --sandbox "Help me debug this issue"

# Specify sandbox type (docker or podman)
vibekit claude --sandbox-type docker "Generate some code"

# Use podman instead of docker
vibekit claude --sandbox-type podman "Review this function"
```

### Environment Variables
```bash
# Enable sandbox globally
export VIBEKIT_SANDBOX=true

# Set default sandbox type
export VIBEKIT_SANDBOX_TYPE=docker
```

### Settings Configuration
Configure sandbox in `~/.vibekit/settings.json`:
```json
{
  "sandbox": {
    "enabled": false,
    "type": "docker"
  }
}
```

## Sandbox Management

### Check Sandbox Status
```bash
# View current sandbox configuration
vibekit sandbox status

# Check with specific options
vibekit sandbox status --sandbox --sandbox-type docker
```

### Build Sandbox Image
```bash
# Build the sandbox container image
vibekit sandbox build
```

### Clean Up Sandbox Resources
```bash
# Remove sandbox images and containers
vibekit sandbox clean
```

## Current Implementation

### What's Available
- **Docker/Podman Support**: Configurable container runtime
- **Sandbox Detection**: Automatic detection of available runtimes
- **Image Building**: Build custom sandbox images
- **Status Reporting**: Check sandbox readiness and configuration
- **Optional Operation**: Works with or without sandboxing

### Sandbox Engine Features
The sandbox engine provides:
- Runtime detection (Docker/Podman availability)
- Container image management
- Configuration resolution from CLI options and settings
- Execution orchestration between sandboxed and direct execution

### Example Status Output
```
ðŸ“¦ Sandbox Status
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Status: ENABLED
Type: docker
Source: CLI option
Runtime: docker
Available: YES
Image: vibekit-sandbox:latest
Image Exists: YES
Ready: YES
```

## Benefits

### Isolation
- **Process Isolation**: Agent processes run in separate containers
- **Filesystem Protection**: Host filesystem access is controlled
- **Resource Containment**: Container resource limits prevent system impact

### Flexibility
- **Optional Use**: Enable only when needed for sensitive operations
- **Runtime Choice**: Support for both Docker and Podman
- **Configuration Options**: CLI flags, environment variables, or settings file

### Development Safety
- **Safe Experimentation**: Test potentially risky operations in isolation
- **Clean Environment**: Fresh container state for reproducible results
- **Host Protection**: Prevent accidental system modifications

## Best Practices

### When to Use Sandbox
- Working with untrusted or experimental code
- Testing potentially destructive operations
- Ensuring reproducible development environments
- Protecting sensitive host system configurations

### Setup Recommendations
1. **Install Docker/Podman**: Ensure container runtime is available
2. **Build Image**: Pre-build sandbox image for faster startup
3. **Test Configuration**: Verify sandbox status before important work
4. **Monitor Resources**: Check container resource usage during long sessions

### Security Considerations
- Sandbox provides process isolation, not complete security
- Container breakout vulnerabilities may still exist
- Host filesystem mounts reduce isolation benefits
- Keep container runtime updated for security patches

The local sandbox feature provides an additional layer of protection when running AI coding agents, offering configurable isolation without requiring it for basic operations.


================================================
FILE: docs/cli/observability.mdx
================================================
---
title: Observability
description: "Complete visibility into agent operations with logs, analytics, and dashboard to understand what your coding agents are doing."
---
<img
  src="/images/dashboard.png"
  alt="Dashboard"
/>

## Dashboard

### Web Dashboard
VibeKit includes a web dashboard for monitoring agent activity:
```bash
# Start the dashboard (opens browser automatically)
vibekit dashboard

# Start on custom port
vibekit dashboard --port 3001

# Start without opening browser
vibekit dashboard --no-open

# Stop dashboard
vibekit dashboard stop
```

### Dashboard Features
The dashboard provides:
- Agent session monitoring
- Analytics visualization
- Settings management
- Real-time activity tracking

## Logging System

### View Logs
Monitor agent activity through comprehensive logging:
```bash
# View recent logs (default: 50 lines)
vibekit logs

# View logs for specific agent
vibekit logs --agent claude

# View more lines
vibekit logs --lines 100

# Filter by specific agent
vibekit logs --agent gemini
```

### Log Storage
Logs are stored in JSON format at `~/.vibekit/logs/`:
- Daily log files per agent (e.g., `claude-2024-01-15.log`)
- Structured JSON entries with timestamps, levels, and metadata
- Session IDs for tracking individual agent runs

### Log Format
Each log entry contains:
```json
{
  "timestamp": "2024-01-15T10:30:00.000Z",
  "level": "INFO",
  "agent": "claude",
  "sessionId": "1705312200000",
  "message": "Agent session started",
  "metadata": {}
}
```

## Analytics

### Usage Statistics
View detailed analytics about your agent usage:
```bash
# View analytics summary (default: 7 days)
vibekit analytics

# View analytics for specific agent
vibekit analytics --agent claude

# View analytics for custom time period
vibekit analytics --days 30

# Export analytics to JSON
vibekit analytics --export analytics.json
```

### Analytics Metrics
The analytics system tracks:
- **Total Sessions**: Number of agent sessions
- **Session Duration**: Average and total session time
- **Success Rate**: Percentage of successful completions
- **Files Changed**: Number of files modified during sessions
- **Error Count**: Total errors and warnings encountered
- **Agent Breakdown**: Performance comparison across agents

### Example Analytics Output
```
ðŸ“Š Agent Analytics Summary
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total Sessions: 45
Total Duration: 1,200s  
Average Duration: 27s
Success Rate: 89.3%
Files Changed: 127
Total Errors: 5
Total Warnings: 12

ðŸ¤– Agent Breakdown
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
claude:
  Sessions: 32
  Avg Duration: 31s
  Success Rate: 91.2%

gemini:
  Sessions: 13
  Avg Duration: 18s
  Success Rate: 84.6%
```

## Data Management

### Clean Up Data
Remove old logs and analytics:
```bash
# Clean both logs and analytics
vibekit clean

# Clean only logs
vibekit clean --logs

# Clean only analytics data  
vibekit clean --analytics
```

### Log Location
- **Logs**: `~/.vibekit/logs/`
- **Analytics**: `~/.vibekit/analytics/`
- **Settings**: `~/.vibekit/settings.json`

## Current Capabilities

### What's Available
- **Structured Logging**: JSON-formatted logs with timestamps and metadata
- **Analytics Dashboard**: Web interface for viewing usage statistics
- **CLI Analytics**: Command-line access to usage metrics
- **Agent Tracking**: Per-agent performance monitoring
- **Session Management**: Track individual agent sessions
- **Data Export**: Export analytics to JSON format

### Dashboard Features
- Real-time session monitoring
- Settings management interface
- Analytics visualization
- Agent comparison views

## Proxy Server Observability

### Traffic Monitoring
The proxy server provides additional observability:
- HTTP/HTTPS request logging
- Response time tracking
- Redaction statistics
- SSE (Server-Sent Events) stream monitoring

### Proxy Logs
Proxy activity is captured but processed silently for privacy:
- Request/response analysis
- Traffic patterns
- Redaction effectiveness
- Performance metrics

## Best Practices

### Regular Monitoring
1. **Check Analytics Weekly**: Review agent usage patterns
2. **Monitor Success Rates**: Identify problematic sessions
3. **Clean Up Data**: Regularly remove old logs and analytics
4. **Use Dashboard**: Keep dashboard running for real-time monitoring

### Troubleshooting
1. **Check Recent Logs**: Look for error patterns in recent sessions
2. **Review Analytics**: Identify trends in failure rates
3. **Monitor Dashboard**: Watch for real-time issues
4. **Export Data**: Save important metrics before cleanup

The observability features help you understand agent performance, track usage patterns, and identify issues through comprehensive logging and analytics.


================================================
FILE: docs/cli/overview.mdx
================================================
---
title: CLI Overview
description: "Introduction to the VibeKit CLI - a secure middleware for headless and TUI coding agents"
---

## What is the VibeKit CLI?

The VibeKit CLI (`vibekit`) is a security and analytics middleware for existing coding agents like Claude Code CLI and Gemini CLI. It provides:

- ðŸ”’ **Docker Security**: Agents run in isolated containers with no host system access
- ðŸ“Š **Logging & Analytics**: Capture all agent interactions and commands
- ðŸ›¡ï¸ **Safe Sandboxing**: Complete isolation with resource limits and network restrictions
- ðŸ”„ **Unified Interface**: Single CLI for multiple coding agents
- ðŸ“ˆ **Real-time Dashboard**: Monitor agent activity and performance
- ðŸŒ **Proxy Support**: Request/response logging and PII redaction

## Architecture

VibeKit CLI acts as a wrapper around existing coding agents:

1. **Agent Middleware** - Wraps Claude Code CLI, Gemini CLI, and others
2. **Sandbox Security** - Optional Docker containerization for complete isolation
3. **Analytics Engine** - Tracks usage, performance, and error patterns
4. **Proxy Server** - Logs and redacts sensitive data in API requests
5. **Dashboard Interface** - Web UI for monitoring and insights

## Quick Example

Here's how to use VibeKit CLI:

```bash
# Run Claude with security features
vibekit claude "Fix the bug in src/app.js"

# Run with Docker sandbox (maximum security)
vibekit claude --sandbox docker "Add user authentication"

# Run Gemini with network access
vibekit gemini --network "Create a web scraper"

# View logs and analytics
vibekit logs --agent claude --lines 100
vibekit analytics --days 7

# Open analytics dashboard
vibekit dashboard

# Manage Docker containers
vibekit docker --status
```

## Why Use the CLI?

### Security Benefits
- **Container Isolation**: Agents can't access your host system
- **Network Control**: Restrict or monitor network access
- **File Protection**: Protect your main project files from modifications
- **PII Redaction**: Automatically remove sensitive data from logs

### Analytics & Monitoring
- **Usage Tracking**: Monitor coding session duration and productivity
- **Error Analysis**: Identify common issues and failure patterns
- **Performance Metrics**: Analyze agent response times and success rates
- **Real-time Dashboard**: Live monitoring of agent activity

### Development Workflow
- **Easy Integration**: Drop-in replacement for existing agent commands
- **Sync Capabilities**: Sync changes back from sandbox to your project
- **Persistent Containers**: Reuse containers for faster startup
- **Global Aliases**: Use `claude` instead of `vibekit claude`

## CLI Structure

The VibeKit CLI provides these main commands:

### Agent Commands
- **`vibekit claude`** - Run Claude Code CLI with security and logging
- **`vibekit gemini`** - Run Gemini CLI with security and logging

### Management Commands
- **`vibekit logs`** - View agent logs and interactions
- **`vibekit analytics`** - View usage statistics and performance metrics
- **`vibekit dashboard`** - Start analytics dashboard

### Utility Commands
- **`vibekit sync`** - Sync changes from sandbox back to project
- **`vibekit docker`** - Manage Docker containers
- **`vibekit proxy`** - Manage proxy server
- **`vibekit clean`** - Clean logs, analytics, and Docker resources

## Next Steps

<CardGroup cols={2}>
  <Card title="Installation" icon="download" href="/cli/installation" color="#888">
    Install the VibeKit CLI and set up your development environment
  </Card>
  <Card title="Quick Reference" icon="book" href="/cli/quick-reference" color="#888">
    Browse common commands and workflows
  </Card>
  <Card title="Configuration" icon="gear" href="/cli/configuration-files" color="#888">
    Learn how to configure settings and preferences
  </Card>
  <Card title="Environment Variables" icon="code" href="/cli/environment-variables" color="#888">
    Set up API keys and environment configuration
  </Card>
</CardGroup>

## Support

- **GitHub Issues**: [github.com/superagent-ai/vibekit/issues](https://github.com/superagent-ai/vibekit/issues)
- **Discord Community**: [discord.gg/spZ7MnqFT4](https://discord.gg/spZ7MnqFT4)
- **Email**: ismail@superagent.sh


================================================
FILE: docs/cli/proxy-server.mdx
================================================
---
title: Proxy Server
description: "Secure API routing with built-in data redaction for protecting sensitive information in agent communications."
---

VibeKit's proxy server intercepts HTTP/HTTPS traffic between coding agents and their API endpoints, providing real-time data redaction and request logging. The proxy sits between your agents and external services, automatically removing sensitive data before it reaches your terminal or logs.

## Quick Start

```bash
# Start proxy with npx (no installation needed)
npx vibekit-proxy start

# Or through VibeKit CLI
vibekit proxy start

# Check server status
npx vibekit-proxy status
```

### Essential Commands

```bash
# Core operations
npx vibekit-proxy start       # Start proxy server
npx vibekit-proxy stop        # Stop proxy server  
npx vibekit-proxy status      # Check server status

# With options
npx vibekit-proxy start -p 3000    # Custom port
npx vibekit-proxy start -d         # Run as daemon
```

## Installation

Run directly with npx (recommended) or install globally for frequent use:

```bash
# Direct usage (no installation)
npx vibekit-proxy start

# Global installation
npm install -g vibekit-proxy
vibekit-proxy start

# Through VibeKit CLI
vibekit proxy start --port 8080
```

## Configuration

| Variable | Description | Default |
|----------|-------------|---------|
| `PORT` or `VIBEKIT_PROXY_PORT` | Proxy server port | `8080` |
| `VIBEKIT_PROXY_TARGET_URL` | Target API URL for routing | - |

### Health Monitoring

```bash
# Check health status
curl http://localhost:8080/health
# Returns: {"status": "healthy", "uptime": 3600, "timestamp": "2024-01-15T10:30:00.000Z", "requestCount": 142}
```

## Docker Deployment

```bash
# Use published image
docker run -p 8080:8080 -e PORT=8080 vibekit-proxy

# Or build from vibekit-proxy repository
git clone https://github.com/ismailpelaseyed/vibekit-proxy.git
cd vibekit-proxy
docker build -t vibekit-proxy -f docker/Dockerfile.node .
docker run -p 8080:8080 -e PORT=8080 vibekit-proxy
```

Docker Compose for production:
```yaml
version: '3.8'
services:
  vibekit-proxy:
    image: vibekit-proxy:latest
    ports: ["8080:8080"]
    environment:
      - PORT=8080
    restart: unless-stopped
```

## Data Redaction

The proxy automatically detects and removes 70+ patterns of sensitive information:

- **API Keys**: OpenAI (`sk-proj-`), Anthropic (`sk-ant-`), GitHub (`ghp_`), AWS, Google, Slack, Stripe
- **Personal Data**: Email addresses, credit card numbers, database connection strings, JWT tokens
- **Secrets**: SSH private keys, `SECRET_KEY`, `API_SECRET`, `CLIENT_SECRET` values, passwords

The proxy processes streaming responses (SSE) in real-time, accumulating chunks to ensure complete pattern matches before redaction.

## Cloud Deployment

```bash
# Google Cloud Run (after building and pushing your image)
gcloud run deploy vibekit-proxy --image vibekit-proxy --port 8080

# AWS ECS, Azure Container Instances also supported
```

## Using with Agents

```bash
# Run agents through proxy
vibekit claude --proxy http://localhost:8080 "Create a React component"
vibekit gemini --network "Create a web scraper"

# Proxy starts automatically when needed
vibekit claude "Generate API documentation"
```

## Status Monitoring

```bash
# Check proxy status
vibekit proxy status
# Output: Port 8080: âœ… RUNNING, Uptime: 1800s, Requests: 45

# View in dashboard
vibekit dashboard
```

## Troubleshooting

```bash
# Port already in use
npx vibekit-proxy stop -p 8080        # Stop existing proxy
npx vibekit-proxy start -p 3000       # Use different port

# Connection issues  
npx vibekit-proxy status              # Verify proxy is running
curl http://localhost:8080/health # Test health endpoint

# Enable debug logging
VIBEKIT_DEBUG=1 npx vibekit-proxy start
```

The proxy handles shutdown signals gracefully (Ctrl+C, SIGTERM) for clean container deployments.

## Next Steps

<CardGroup cols={2}>
  <Card title="Built-in Redaction" icon="shield-check" href="/cli/redaction" color="#888">
    Learn more about VibeKit's data redaction capabilities
  </Card>
  <Card title="Observability" icon="chart-line" href="/cli/observability" color="#888">
    Monitor proxy performance and analytics
  </Card>
  <Card title="Environment Variables" icon="code" href="/cli/environment-variables" color="#888">
    Configure proxy settings and API endpoints
  </Card>
  <Card title="Configuration Files" icon="gear" href="/cli/configuration-files" color="#888">
    Set up persistent proxy configuration
  </Card>
</CardGroup>


================================================
FILE: docs/cli/quick-reference.mdx
================================================
---
title: Quick Reference
description: "Quick reference card for common VibeKit CLI commands"
---

## Essential Commands

### Setup & Installation

```bash
# Install VibeKit CLI globally
npm install -g vibekit

# Configure settings
vibekit

# Set up global aliases (optional)
vibekit setup-aliases
```

### Running Agents

```bash
# Run Claude with default settings
vibekit claude "Create a REST API"

# Run Claude with Docker sandbox (maximum security)
vibekit claude --sandbox docker "Add authentication"

# Run Gemini with network access
vibekit gemini --network "Create a web scraper"

# Pass additional arguments to the underlying agent
vibekit claude --help
vibekit claude --model claude-3-5-sonnet-20241022 "Generate code"
```

### Sandbox Options

```bash
# No sandbox (default, fast startup)
vibekit claude --sandbox none "Fix the bug"

# Docker sandbox (complete isolation)
vibekit claude --sandbox docker "Run untrusted code"

# Docker with no network access (maximum security)
vibekit claude --sandbox docker --no-network "Secure development"

# Use fresh container instead of persistent one
vibekit claude --sandbox docker --fresh-container "Clean environment"
```

### Monitoring & Analytics

```bash
# View recent logs
vibekit logs

# View logs for specific agent
vibekit logs --agent claude --lines 100

# View analytics and statistics
vibekit analytics --days 7

# View analytics for specific agent
vibekit analytics --agent claude --summary

# Export analytics to file
vibekit analytics --export analytics.json
```

### Dashboard & Web Interface

```bash
# Start analytics dashboard and open in browser
vibekit dashboard

# Start dashboard on specific port
vibekit dashboard start --port 3001 --open

# Stop dashboard
vibekit dashboard stop
```

## Common Workflows

### Secure Development

```bash
# 1. Enable Docker sandbox in settings
vibekit

# 2. Run agents in isolated containers
vibekit claude --sandbox docker "Implement user authentication"

# 3. Sync changes back to your project when ready
vibekit sync

# 4. Monitor activity in dashboard
vibekit dashboard
```

### Debugging & Analysis

```bash
# 1. Run agent and capture all interactions
vibekit claude --sandbox docker "Debug the payment system"

# 2. Check logs for errors
vibekit logs --agent claude --lines 50

# 3. View analytics to understand patterns
vibekit analytics --agent claude --days 1

# 4. Check container status if needed
vibekit docker --status
```

### Team Collaboration

```bash
# 1. Enable proxy for request logging
vibekit proxy start

# 2. Run agents through proxy
vibekit claude --proxy http://localhost:8080 "Add new feature"

# 3. Share analytics and logs with team
vibekit analytics --export team-report.json

# 4. Clean up when done
vibekit clean
```

### Proxy & Security

```bash
# Start proxy server for request logging
vibekit proxy start --port 8080

# Kill proxy server on specific port
vibekit proxy kill --port 8080

# Run agent through custom proxy
vibekit claude --proxy http://proxy.example.com:8080 "Generate code"
```

### Docker Management

```bash
# Check Docker container status
vibekit docker --status

# Stop persistent container
vibekit docker --stop

# Restart persistent container
vibekit docker --restart

# Sync changes from sandbox to project
vibekit sync
```

### Maintenance

```bash
# Clean all data
vibekit clean

# Clean only logs
vibekit clean --logs

# Clean only Docker resources
vibekit clean --docker

# Clean only analytics
vibekit clean --analytics
```

## Environment Variables Quick Reference

```bash
# In .env file or shell
export ANTHROPIC_API_KEY="sk-ant-..."  # For Claude
export GOOGLE_API_KEY="..."            # For Gemini
export HTTP_PROXY="http://..."         # Proxy for all requests
export HTTPS_PROXY="http://..."        # HTTPS proxy
export VIBEKIT_DEBUG="1"               # Enable debug logging
```

## Keyboard Shortcuts

When using interactive commands:
- `â†‘/â†“` - Navigate options
- `Space` - Select/deselect option
- `Enter` - Confirm selection
- `Ctrl+C` - Cancel operation

## Common Flags

| Flag | Description | Example |
|------|-------------|---------|
| `--sandbox <type>` | Sandbox type (none, docker) | `--sandbox docker` |
| `--proxy <url>` | HTTP proxy URL | `--proxy http://localhost:8080` |
| `--network` / `--no-network` | Network access control | `--no-network` |
| `--fresh-container` | Use new Docker container | `--fresh-container` |
| `-a, --agent <agent>` | Filter by agent | `--agent claude` |
| `-n, --lines <number>` | Number of lines | `--lines 100` |
| `--json` | JSON output | `--json` |
| `--export <file>` | Export to file | `--export report.json` |
| `-p, --port <port>` | Port number | `--port 3001` |

## Exit Codes

- `0` - Success
- `1` - General error
- `127` - Command not found
- `130` - Interrupted (Ctrl+C)

## Getting Help

```bash
# General help
vibekit --help

# Command-specific help
vibekit claude --help
vibekit analytics --help
vibekit dashboard --help

# Show version
vibekit --version

# Diagnose setup issues
vibekit diagnose-aliases
```


================================================
FILE: docs/cli/redaction.mdx
================================================
---
title: Built-in Redaction
description: "Automatically detect and remove sensitive data like API keys, secrets, and PII from AI agent completions through the proxy server."
---

VibeKit's built-in redaction system automatically identifies and removes sensitive information from coding agent outputs by intercepting HTTP traffic through a proxy server that applies pattern-based filtering.

## How It Works

VibeKit runs a proxy server that sits between coding agents and their API endpoints. All HTTP/HTTPS traffic flows through this proxy, where responses are processed in real-time to detect and redact sensitive data before it reaches you.

### Proxy-based Redaction
```bash
# VibeKit automatically starts proxy server
vibekit claude "Show me API integration code"

# Traffic flows: Claude API â†’ Proxy (redaction) â†’ Your terminal
# Sensitive data is replaced before you see it
```

### Pattern Detection
The redaction system uses comprehensive pattern matching from `rules-stable.yml` that includes hundreds of patterns for:

- **AWS**: Access keys (AKIA...), ARNs, API Gateway URLs, RDS endpoints
- **OpenAI**: API keys (sk-...), organization keys, project keys
- **GitHub**: Personal access tokens, app tokens
- **Google**: API keys, service account keys, OAuth tokens
- **Database**: Connection strings, credentials
- **Generic**: Email addresses, credit card numbers, phone numbers

## Configuration

### Settings Management
Control redaction through the VibeKit settings:
```bash
# Open settings interface
vibekit

# Toggle redaction on/off in the proxy section
```

### Settings File
Located at `~/.vibekit/settings.json`:
```json
{
  "proxy": {
    "enabled": true,
    "redactionEnabled": true
  }
}
```

### How Patterns Work
Patterns are loaded from `packages/cli/src/utils/rules-stable.yml`:
```yaml
patterns:
  - pattern:
      name: OpenAI API Key
      regex: sk-[a-zA-Z0-9]{48}
      confidence: high
  - pattern:
      name: AWS Access Key ID Value
      regex: (A3T[A-Z0-9]|AKIA|AGPA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}
      confidence: high
```

## Real-time Processing

### Stream Processing
Redaction happens as data flows through Transform streams:
- HTTP responses are processed in chunks
- Pattern matching occurs on buffered content
- Sensitive data is replaced with `[PATTERN_NAME_REDACTED]` tokens
- Modified responses are sent to your terminal

### Example Output
```bash
# Original API response:
# "Configure with API key sk-1234567890abcdef..."

# What you see:
# "Configure with API key [OPENAI_API_KEY_REDACTED]..."
```

## Current Capabilities

### What's Implemented
- **Proxy Server**: Intercepts HTTP/HTTPS traffic
- **Pattern Matching**: 200+ predefined patterns for common secrets
- **Real-time Processing**: Redacts responses as they stream
- **Settings Integration**: Toggle redaction on/off
- **Multiple Agents**: Works with Claude, Gemini, Codex, etc.

### Default Patterns Include
- AWS access keys, secret keys, ARNs
- OpenAI API keys and organization keys
- GitHub personal access tokens
- Google API keys and service accounts
- Database connection strings
- Email addresses and phone numbers
- Credit card patterns

## Proxy Server Management

### Automatic Operation
The proxy server starts automatically when needed:
```bash
# Proxy starts automatically with redaction enabled
vibekit claude "Generate secure API client"
```

### Manual Control
```bash
# Start proxy server manually
vibekit proxy start --port 8080

# Stop proxy server
vibekit proxy kill --port 8080
```

## Limitations & Current State

### What's Not Yet Implemented
- Custom pattern definition through CLI
- Redaction reporting and analytics
- Retroactive log processing
- Sensitivity level controls
- Whitelist management

### Fallback Behavior
If pattern loading fails, the system falls back to basic patterns:
- Email addresses: `[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}`
- Credit cards: `[0-9]{13,19}`

## Best Practices

### Security
- Keep redaction enabled in settings
- Regularly review proxy logs for sensitive data
- Monitor pattern matching effectiveness
- Update VibeKit for new pattern definitions

### Development
- Test with dummy secrets to verify redaction works
- Check settings periodically to ensure redaction is enabled
- Be aware that redaction only works through the proxy server

Built-in redaction provides an essential security layer by intercepting and filtering sensitive data from AI coding agent responses, helping prevent accidental exposure of secrets and credentials.


================================================
FILE: docs/components/code-block.tsx
================================================
"use client";

import { cn } from "@/lib/utils";
import React, { useEffect, useState } from "react";
import { codeToHtml } from "shiki";

export type CodeBlockProps = {
  children?: React.ReactNode;
  className?: string;
} & React.HTMLProps<HTMLDivElement>;

function CodeBlock({ children, className, ...props }: CodeBlockProps) {
  return (
    <div
      className={cn(
        "not-prose flex w-full flex-col overflow-clip border",
        "border-border bg-card text-card-foreground rounded-xl",
        className
      )}
      {...props}
    >
      {children}
    </div>
  );
}

export type CodeBlockCodeProps = {
  code: string;
  language?: string;
  theme?: string;
  className?: string;
} & React.HTMLProps<HTMLDivElement>;

function CodeBlockCode({
  code,
  language = "tsx",
  theme = "github-light",
  className,
  ...props
}: CodeBlockCodeProps) {
  const [highlightedHtml, setHighlightedHtml] = useState<string | null>(null);

  useEffect(() => {
    async function highlight() {
      if (!code) {
        setHighlightedHtml("<pre><code></code></pre>");
        return;
      }

      const html = await codeToHtml(code, { lang: language, theme });
      setHighlightedHtml(html);
    }
    highlight();
  }, [code, language, theme]);

  const classNames = cn(
    "w-full overflow-x-auto text-[13px] [&>pre]:px-4 [&>pre]:py-4",
    className
  );

  // SSR fallback: render plain code if not hydrated yet
  return highlightedHtml ? (
    <div
      className={classNames}
      dangerouslySetInnerHTML={{ __html: highlightedHtml }}
      {...props}
    />
  ) : (
    <div className={classNames} {...props}>
      <pre>
        <code>{code}</code>
      </pre>
    </div>
  );
}

export type CodeBlockGroupProps = React.HTMLAttributes<HTMLDivElement>;

function CodeBlockGroup({
  children,
  className,
  ...props
}: CodeBlockGroupProps) {
  return (
    <div
      className={cn("flex items-center justify-between", className)}
      {...props}
    >
      {children}
    </div>
  );
}

export type CodeBlockPreviewProps = React.HTMLAttributes<HTMLDivElement>;

function CodeBlockPreview({
  children,
  className,
  ...props
}: CodeBlockPreviewProps) {
  return (
    <div
      className={cn("flex items-center justify-center p-4", className)}
      {...props}
    >
      {children}
    </div>
  );
}

export { CodeBlockGroup, CodeBlockCode, CodeBlock, CodeBlockPreview };



================================================
FILE: docs/components/conditional-layout.tsx
================================================
"use client";

import { usePathname } from "next/navigation";
import Navbar, { SidebarProvider } from "@/components/navbar";

interface ConditionalLayoutProps {
  children: React.ReactNode;
}

export default function ConditionalLayout({
  children,
}: ConditionalLayoutProps) {
  const pathname = usePathname();
  const isEmbedRoute = pathname.startsWith("/embed/");

  if (isEmbedRoute) {
    return <div className="flex flex-col h-screen bg-muted">{children}</div>;
  }

  return (
    <SidebarProvider>
      <div className="flex flex-col h-screen bg-muted">
        <Navbar />
        {children}
      </div>
    </SidebarProvider>
  );
}



================================================
FILE: docs/components/markdown-editor.tsx
================================================
import React from "react";
import { Textarea } from "@/components/ui/textarea";
import { cn } from "@/lib/utils";

interface MarkdownEditorProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  className?: string;
  disabled?: boolean;
}

export function MarkdownEditor({
  value,
  onChange,
  placeholder = "Enter instructions...",
  className,
  disabled = false,
}: MarkdownEditorProps) {
  return (
    <Textarea
      value={value}
      onChange={(e) => onChange(e.target.value)}
      placeholder={placeholder}
      className={cn(
        "border-none rounded-none shadow-none font-mono resize",
        className
      )}
      disabled={disabled}
    />
  );
}



================================================
FILE: docs/components/navbar.tsx
================================================
"use client";

import { useUser, useAuth } from "@clerk/nextjs";
import Image from "next/image";
import Link from "next/link";
import { useState, useEffect, createContext, useContext } from "react";
import { usePathname } from "next/navigation";

import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils";
import { siteConfig } from "@/config";

// Create context for sidebar state
const SidebarContext = createContext<{
  sidebarOpen: boolean;
  setSidebarOpen: (open: boolean) => void;
}>({
  sidebarOpen: false,
  setSidebarOpen: () => {},
});

export const useSidebar = () => useContext(SidebarContext);

export function SidebarProvider({ children }: { children: React.ReactNode }) {
  const [sidebarOpen, setSidebarOpen] = useState(false);

  return (
    <SidebarContext.Provider value={{ sidebarOpen, setSidebarOpen }}>
      {children}
    </SidebarContext.Provider>
  );
}

export default function Navbar() {
  const { user } = useUser();
  const { signOut } = useAuth();
  const { sidebarOpen, setSidebarOpen } = useSidebar();
  const pathname = usePathname();

  const isActive = (href: string) => pathname === href;

  // Handle escape key to close sidebar
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === "Escape" && sidebarOpen) {
        setSidebarOpen(false);
      }
    };

    document.addEventListener("keydown", handleEscape);
    return () => document.removeEventListener("keydown", handleEscape);
  }, [sidebarOpen, setSidebarOpen]);

  // Create initials for avatar fallback
  const getInitials = () => {
    if (!user) return "?";

    const firstName = user.firstName || "";
    const lastName = user.lastName || "";

    if (!firstName && !lastName) return "?";

    return `${firstName.charAt(0)}${lastName.charAt(0)}`.toUpperCase();
  };

  return (
    <>
      <div className="h-12 px-2 flex items-center justify-between fixed top-0 left-0 right-0 z-50 backdrop-blur">
        <div className="flex items-center gap-x-1">
          <Button
            variant="ghost"
            size="icon"
            onClick={() => setSidebarOpen(!sidebarOpen)}
            className="transition-colors hover:bg-background hover:border cursor-pointer ml-1"
            aria-label={sidebarOpen ? "Close sidebar" : "Open sidebar"}
          >
            {sidebarOpen ? (
              <Image
                src="/sidebar-open.svg"
                alt="Open sidebar"
                width={22}
                height={22}
                className="opacity-50 transform rotate-y-180"
              />
            ) : (
              <Image
                src="/sidebar-open.svg"
                alt="Open sidebar"
                width={22}
                height={22}
                className="opacity-50"
              />
            )}
          </Button>

          <div className="flex items-center gap-x-2 ml-2 text-muted-foreground">
            <Image src="/mark.png" alt="Superagent" width={20} height={20} />
            <p className="font-medium">VibeKit Onboard</p>
          </div>
        </div>
      </div>
      {/* Sidebar */}
      <div
        className={cn(
          "fixed top-10  left-0 h-[calc(100vh-3rem)] z-30 transition-all duration-300 ease-in-out",
          sidebarOpen ? "w-40" : "w-16"
        )}
      >
        <div className="p-2 flex flex-col h-full justify-between">
          <div className="flex flex-col gap-y-1">
            {siteConfig.mainNav.map((item) => (
              <Link href={item.href} key={item.title} className="w-full">
                <Button
                  variant={isActive(item.href) ? "outline" : "ghost"}
                  className={cn(
                    "transition-all duration-300 ease-in-out w-full ml-1 hover:bg-background border border-transparent hover:border-muted-foreground/20 cursor-pointer opacity-50 hover:opacity-100 justify-start",
                    sidebarOpen ? "px-1.5 pr-4" : "px-1.5 w-9",
                    isActive(item.href) &&
                      "opacity-100 border-muted-foreground/20"
                  )}
                >
                  <div className="flex items-center gap-2 min-w-0">
                    <Image
                      src={item.icon as string}
                      alt={item.title}
                      width={22}
                      height={22}
                      className="flex-shrink-0"
                    />
                    <span
                      className={cn(
                        "font-medium transition-all duration-300 ease-in-out overflow-hidden whitespace-nowrap text-[16px]",
                        sidebarOpen ? "opacity-100 w-auto" : "opacity-0 w-0"
                      )}
                    >
                      {item.title}
                    </span>
                  </div>
                </Button>
              </Link>
            ))}
          </div>
          <div className="flex flex-col gap-y-1">
            {user && (
              <DropdownMenu>
                <DropdownMenuTrigger>
                  <Avatar className="cursor-pointer ml-1">
                    <AvatarImage
                      src={user.imageUrl}
                      alt={user.fullName || user.emailAddresses[0].emailAddress}
                    />
                    <AvatarFallback>{getInitials()}</AvatarFallback>
                  </Avatar>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="start" className="w-56">
                  <DropdownMenuLabel className="text-md font-medium">
                    My Account
                    <p className="text-sm font-normal text-muted-foreground">
                      {user.emailAddresses[0].emailAddress}
                    </p>
                  </DropdownMenuLabel>
                  <DropdownMenuSeparator />
                  <Link href="/profile" passHref>
                    <DropdownMenuItem className="text-md">
                      Profile
                    </DropdownMenuItem>
                  </Link>
                  <Link href="/billing" passHref>
                    <DropdownMenuItem className="text-md">
                      Billing
                    </DropdownMenuItem>
                  </Link>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem
                    className="text-md"
                    onClick={() => signOut()}
                  >
                    Sign out
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </div>
        </div>
      </div>
    </>
  );
}



================================================
FILE: docs/components/ui/avatar.tsx
================================================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }



================================================
FILE: docs/components/ui/badge.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }



================================================
FILE: docs/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: docs/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}



================================================
FILE: docs/components/ui/color-picker.tsx
================================================
"use client";

import * as React from "react";
import { Input } from "@/components/ui/input";
import { cn } from "@/lib/utils";

interface ColorPickerProps {
  value?: string;
  onChange?: (value: string) => void;
  className?: string;
  placeholder?: string;
}

const ColorPicker = React.forwardRef<HTMLInputElement, ColorPickerProps>(
  ({ className, value = "#000000", onChange, placeholder, ...props }, ref) => {
    const [color, setColor] = React.useState(value);

    React.useEffect(() => {
      setColor(value);
    }, [value]);

    const handleColorChange = (newColor: string) => {
      setColor(newColor);
      onChange?.(newColor);
    };

    return (
      <div className="flex items-center gap-2">
        <div className="relative">
          <input
            type="color"
            value={color}
            onChange={(e) => handleColorChange(e.target.value)}
            className="absolute inset-0 h-full opacity-0 cursor-pointer"
            {...props}
            ref={ref}
          />
          <div
            className="w-9 h-9 rounded-md border border-input cursor-pointer"
            style={{ backgroundColor: color }}
          />
        </div>
        <Input
          type="text"
          value={color}
          onChange={(e) => handleColorChange(e.target.value)}
          placeholder={placeholder || "#000000"}
          className={cn("font-mono w-fit", className)}
          pattern="^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$"
        />
      </div>
    );
  }
);

ColorPicker.displayName = "ColorPicker";

export { ColorPicker };



================================================
FILE: docs/components/ui/command.tsx
================================================
"use client"

import * as React from "react"
import { Command as CommandPrimitive } from "cmdk"
import { SearchIcon } from "lucide-react"

import { cn } from "@/lib/utils"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        className
      )}
      {...props}
    />
  )
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  className,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string
  description?: string
  className?: string
  showCloseButton?: boolean
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent
        className={cn("overflow-hidden p-0", className)}
        showCloseButton={showCloseButton}
      >
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
        className
      )}
      {...props}
    />
  )
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  )
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
        className
      )}
      {...props}
    />
  )
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("bg-border -mx-1 h-px", className)}
      {...props}
    />
  )
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}



================================================
FILE: docs/components/ui/dialog.tsx
================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}



================================================
FILE: docs/components/ui/dropdown-menu.tsx
================================================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}



================================================
FILE: docs/components/ui/file-upload.tsx
================================================
"use client";

import * as React from "react";
import { Upload, X } from "lucide-react";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { useDropzone } from "react-dropzone";
import Image from "next/image";

// Type definitions for the use-file-upload library
type FileUpload = {
  source: URL;
  name: string;
  size: number;
  file: File;
};

interface FileUploadProps {
  value?: string;
  onChange?: (value: string | undefined) => void;
  className?: string;
  accept?: string;
}

const FileUpload: React.FC<FileUploadProps> = ({
  className,
  value,
  onChange,
  accept = "image/*",
}) => {
  const [preview, setPreview] = React.useState<string | undefined>(value);

  React.useEffect(() => {
    setPreview(value);
  }, [value]);

  // Process file to data URL
  const processFile = React.useCallback(
    (file: File) => {
      if (file && file.type.startsWith("image/")) {
        const reader = new FileReader();
        reader.onload = (event) => {
          const result = event.target?.result as string;
          setPreview(result);
          onChange?.(result);
        };
        reader.readAsDataURL(file);
      }
    },
    [onChange]
  );

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    accept: {
      [accept]: [],
    },
    maxFiles: 1,
    onDrop: (acceptedFiles) => {
      if (acceptedFiles?.[0]) {
        processFile(acceptedFiles[0]);
      }
    },
  });

  const removeFile = () => {
    setPreview(undefined);
    onChange?.(undefined);
  };

  return (
    <div className={cn("space-y-2", className)}>
      {preview ? (
        <div className="relative w-25 h-25">
          <div className="w-24 h-24 rounded-lg border border-input overflow-hidden bg-muted flex items-center justify-center relative">
            <Image
              src={preview}
              alt="Preview"
              fill
              className="object-cover"
              unoptimized={true}
              onError={() => {
                console.error("Image failed to load:", preview);
                setPreview(undefined);
                onChange?.(undefined);
              }}
            />
          </div>
          <Button
            type="button"
            variant="outline"
            size="icon"
            className="absolute -top-2 -right-2 h-6 w-6 rounded-full"
            onClick={removeFile}
          >
            <X className="h-3 w-3" />
          </Button>
        </div>
      ) : (
        <div
          {...getRootProps()}
          className={cn(
            "w-24 h-24 rounded-lg border-2 border-dashed border-input bg-muted/30 flex flex-col items-center justify-center cursor-pointer transition-colors hover:bg-muted/50",
            isDragActive && "border-primary bg-primary/10"
          )}
        >
          <input {...getInputProps()} />
          <Upload className="h-4 w-4 text-muted-foreground mb-1" />
          <span className="text-xs text-muted-foreground text-center">
            Upload Logo
          </span>
        </div>
      )}
    </div>
  );
};

FileUpload.displayName = "FileUpload";

export { FileUpload };



================================================
FILE: docs/components/ui/form.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}



================================================
FILE: docs/components/ui/input-otp.tsx
================================================
"use client"

import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { MinusIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function InputOTP({
  className,
  containerClassName,
  ...props
}: React.ComponentProps<typeof OTPInput> & {
  containerClassName?: string
}) {
  return (
    <OTPInput
      data-slot="input-otp"
      containerClassName={cn(
        "flex items-center gap-2 has-disabled:opacity-50",
        containerClassName
      )}
      className={cn("disabled:cursor-not-allowed", className)}
      {...props}
    />
  )
}

function InputOTPGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="input-otp-group"
      className={cn("flex items-center", className)}
      {...props}
    />
  )
}

function InputOTPSlot({
  index,
  className,
  ...props
}: React.ComponentProps<"div"> & {
  index: number
}) {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext?.slots[index] ?? {}

  return (
    <div
      data-slot="input-otp-slot"
      data-active={isActive}
      className={cn(
        "data-[active=true]:border-ring data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:ring-destructive/20 dark:data-[active=true]:aria-invalid:ring-destructive/40 aria-invalid:border-destructive data-[active=true]:aria-invalid:border-destructive dark:bg-input/30 border-input relative flex h-9 w-9 items-center justify-center border-y border-r text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md data-[active=true]:z-10 data-[active=true]:ring-[3px]",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink bg-foreground h-4 w-px duration-1000" />
        </div>
      )}
    </div>
  )
}

function InputOTPSeparator({ ...props }: React.ComponentProps<"div">) {
  return (
    <div data-slot="input-otp-separator" role="separator" {...props}>
      <MinusIcon />
    </div>
  )
}

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }



================================================
FILE: docs/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }



================================================
FILE: docs/components/ui/label.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }



================================================
FILE: docs/components/ui/scroll-area.tsx
================================================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }



================================================
FILE: docs/components/ui/select.tsx
================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}



================================================
FILE: docs/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: docs/components/ui/sonner.tsx
================================================
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }



================================================
FILE: docs/components/ui/switch.tsx
================================================
"use client";

import * as React from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";

import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };



================================================
FILE: docs/components/ui/table.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
));
Table.displayName = "Table";

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
));
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
));
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
));
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
));
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
));
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
));
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
));
TableCaption.displayName = "TableCaption";

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};



================================================
FILE: docs/components/ui/tabs.tsx
================================================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: docs/components/ui/text-shimmer.tsx
================================================
"use client";
import React, { useMemo, type JSX } from "react";
import { motion } from "framer-motion";
import { cn } from "@/lib/utils";

interface TextShimmerProps {
  children: string;
  as?: React.ElementType;
  className?: string;
  duration?: number;
  spread?: number;
}

export function TextShimmer({
  children,
  as: Component = "p",
  className,
  duration = 2,
  spread = 2,
}: TextShimmerProps) {
  const MotionComponent = motion(Component as keyof JSX.IntrinsicElements);

  const dynamicSpread = useMemo(() => {
    return children.length * spread;
  }, [children, spread]);

  return (
    <MotionComponent
      className={cn(
        "relative inline-block bg-[length:250%_100%,auto] bg-clip-text",
        "text-transparent [--base-color:#a1a1aa] [--base-gradient-color:#000]",
        "[--bg:linear-gradient(90deg,#0000_calc(50%-var(--spread)),var(--base-gradient-color),#0000_calc(50%+var(--spread)))] [background-repeat:no-repeat,padding-box]",
        "dark:[--base-color:#71717a] dark:[--base-gradient-color:#ffffff] dark:[--bg:linear-gradient(90deg,#0000_calc(50%-var(--spread)),var(--base-gradient-color),#0000_calc(50%+var(--spread)))]",
        className
      )}
      initial={{ backgroundPosition: "100% center" }}
      animate={{ backgroundPosition: "0% center" }}
      transition={{
        repeat: Infinity,
        duration,
        ease: "linear",
      }}
      style={
        {
          "--spread": `${dynamicSpread}px`,
          backgroundImage: `var(--bg), linear-gradient(var(--base-color), var(--base-color))`,
        } as React.CSSProperties
      }
    >
      {children}
    </MotionComponent>
  );
}



================================================
FILE: docs/components/ui/textarea.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }



================================================
FILE: docs/convex/actionLogs.ts
================================================
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

// CREATE - Create an action log
export const createActionLog = mutation({
  args: {
    action: v.union(v.literal("COPY_PROMPT"), v.literal("CREATE_AGENT")),
    agentId: v.id("agent"),
    projectId: v.id("project"),
    metadata: v.optional(
      v.object({
        repository: v.optional(v.string()),
        instructions: v.optional(v.string()),
        githubUserProfile: v.optional(
          v.object({
            name: v.optional(v.string()),
            avatar: v.optional(v.string()),
            profileUrl: v.optional(v.string()),
          })
        ),
      })
    ),
  },
  handler: async (ctx, args) => {
    const id = await ctx.db.insert("actionLog", {
      action: args.action,
      agentId: args.agentId,
      projectId: args.projectId,
      metadata: args.metadata,
    });
    return id;
  },
});

// READ - Get a single action log by ID
export const getActionLog = query({
  args: { id: v.id("actionLog") },
  handler: async (ctx, args) => {
    const log = await ctx.db.get(args.id);
    return log;
  },
});

// READ - Get all action logs
export const getAllActionLogs = query({
  args: {},
  handler: async (ctx) => {
    const logs = await ctx.db.query("actionLog").order("desc").collect();
    return logs;
  },
});

// READ - Get action logs by agent
export const getLogsByAgent = query({
  args: { agentId: v.id("agent") },
  handler: async (ctx, args) => {
    const logs = await ctx.db
      .query("actionLog")
      .withIndex("by_agent", (q) => q.eq("agentId", args.agentId))
      .order("desc")
      .collect();
    return logs;
  },
});

// READ - Get action logs by project
export const getLogsByProject = query({
  args: { projectId: v.id("project") },
  handler: async (ctx, args) => {
    const logs = await ctx.db
      .query("actionLog")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .order("desc")
      .collect();
    return logs;
  },
});

// READ - Get action logs by action type
export const getLogsByAction = query({
  args: {
    action: v.union(v.literal("COPY_PROMPT"), v.literal("CREATE_AGENT")),
  },
  handler: async (ctx, args) => {
    const logs = await ctx.db
      .query("actionLog")
      .withIndex("by_action", (q) => q.eq("action", args.action))
      .order("desc")
      .collect();
    return logs;
  },
});

// READ - Get action logs count
export const getActionLogCount = query({
  args: {},
  handler: async (ctx) => {
    const logs = await ctx.db.query("actionLog").collect();
    return logs.length;
  },
});

// UPDATE - Update action log metadata
export const updateActionLog = mutation({
  args: {
    id: v.id("actionLog"),
    metadata: v.optional(
      v.object({
        repository: v.optional(v.string()),
        instructions: v.optional(v.string()),
        githubUserProfile: v.optional(
          v.object({
            name: v.optional(v.string()),
            avatar: v.optional(v.string()),
            profileUrl: v.optional(v.string()),
          })
        ),
      })
    ),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db.get(args.id);
    if (!existing) {
      throw new Error("Action log not found");
    }

    await ctx.db.patch(args.id, {
      metadata: args.metadata,
    });
    return true;
  },
});

// UPDATE - Add metadata to existing action log
export const addMetadataToActionLog = mutation({
  args: {
    id: v.id("actionLog"),
    additionalMetadata: v.object({
      repository: v.optional(v.string()),
      instructions: v.optional(v.string()),
      githubUserProfile: v.optional(
        v.object({
          name: v.optional(v.string()),
          avatar: v.optional(v.string()),
          profileUrl: v.optional(v.string()),
        })
      ),
    }),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db.get(args.id);
    if (!existing) {
      throw new Error("Action log not found");
    }

    // Merge existing metadata with new metadata
    const updatedMetadata = {
      ...existing.metadata,
      ...args.additionalMetadata,
    };

    await ctx.db.patch(args.id, {
      metadata: updatedMetadata,
    });
    return true;
  },
});

// DELETE - Delete a single action log
export const deleteActionLog = mutation({
  args: { id: v.id("actionLog") },
  handler: async (ctx, args) => {
    const existing = await ctx.db.get(args.id);
    if (!existing) {
      throw new Error("Action log not found");
    }

    await ctx.db.delete(args.id);
    return true;
  },
});

// DELETE - Delete action logs by agent
export const deleteLogsByAgent = mutation({
  args: { agentId: v.id("agent") },
  handler: async (ctx, args) => {
    const logs = await ctx.db
      .query("actionLog")
      .withIndex("by_agent", (q) => q.eq("agentId", args.agentId))
      .collect();

    let deletedCount = 0;
    for (const log of logs) {
      await ctx.db.delete(log._id);
      deletedCount++;
    }

    return { deletedCount };
  },
});

// DELETE - Delete action logs by project
export const deleteLogsByProject = mutation({
  args: { projectId: v.id("project") },
  handler: async (ctx, args) => {
    const logs = await ctx.db
      .query("actionLog")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .collect();

    let deletedCount = 0;
    for (const log of logs) {
      await ctx.db.delete(log._id);
      deletedCount++;
    }

    return { deletedCount };
  },
});

// DELETE - Bulk delete action logs by IDs
export const bulkDeleteActionLogs = mutation({
  args: { ids: v.array(v.id("actionLog")) },
  handler: async (ctx, args) => {
    let deletedCount = 0;
    let failedCount = 0;

    for (const id of args.ids) {
      try {
        const existing = await ctx.db.get(id);
        if (existing) {
          await ctx.db.delete(id);
          deletedCount++;
        } else {
          failedCount++;
        }
      } catch {
        failedCount++;
      }
    }

    return { deletedCount, failedCount };
  },
});

// READ - Get action logs for a user's organization
export const getLogsByUserOrganization = query({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    // Step 1: Get the user's profile to find their organization
    const userProfile = await ctx.db
      .query("userProfile")
      .withIndex("by_user", (q) => q.eq("userId", args.userId))
      .first();

    if (!userProfile || !userProfile.organizationId) {
      // User has no organization, return empty array
      return [];
    }

    // Step 2: Get all users connected to the same organization
    const orgUsers = await ctx.db
      .query("userProfile")
      .filter((q) =>
        q.eq(q.field("organizationId"), userProfile.organizationId)
      )
      .collect();

    if (orgUsers.length === 0) {
      return [];
    }

    // Step 3: Get all agents for each user in the organization
    const allAgents = [];
    for (const user of orgUsers) {
      const userAgents = await ctx.db
        .query("agent")
        .withIndex("by_user", (q) => q.eq("createdBy", user.userId))
        .collect();
      allAgents.push(...userAgents);
    }

    if (allAgents.length === 0) {
      return [];
    }

    // Step 4: Get all action logs for all those agents
    const allLogs = [];
    for (const agent of allAgents) {
      const agentLogs = await ctx.db
        .query("actionLog")
        .withIndex("by_agent", (q) => q.eq("agentId", agent._id))
        .collect();
      allLogs.push(...agentLogs);
    }

    // Sort by creation time (most recent first)
    allLogs.sort((a, b) => b._creationTime - a._creationTime);

    return allLogs;
  },
});



================================================
FILE: docs/convex/agents.ts
================================================
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

export const createAgent = mutation({
  args: {
    name: v.string(),
    status: v.union(v.literal("ACTIVE"), v.literal("INACTIVE")),
    createdBy: v.string(),
    projectId: v.id("project"),
    logo: v.optional(v.string()),
    primaryColor: v.optional(v.string()),
    buttonColor: v.optional(v.string()),
    systemPrompt: v.optional(v.string()),
    headlineText: v.optional(v.string()),
    buttonText: v.optional(v.string()),
    descriptionText: v.optional(v.string()),
    showButtonLogo: v.optional(v.boolean()),
    privacyPolicy: v.optional(v.string()),
    termsOfService: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const id = await ctx.db.insert("agent", {
      name: args.name,
      status: args.status,
      createdBy: args.createdBy,
      projectId: args.projectId,
      logo: args.logo,
      primaryColor: args.primaryColor,
      buttonColor: args.buttonColor,
      systemPrompt: args.systemPrompt,
      headlineText: args.headlineText,
      buttonText: args.buttonText,
      descriptionText: args.descriptionText,
      showButtonLogo: args.showButtonLogo,
      privacyPolicy: args.privacyPolicy,
      termsOfService: args.termsOfService,
    });
    return id;
  },
});

export const getAgent = query({
  args: { id: v.id("agent") },
  handler: async (ctx, args) => {
    const agent = await ctx.db.get(args.id);
    return agent;
  },
});

export const updateAgent = mutation({
  args: {
    id: v.id("agent"),
    name: v.string(),
    logo: v.optional(v.string()),
    primaryColor: v.optional(v.string()),
    buttonColor: v.optional(v.string()),
    systemPrompt: v.optional(v.string()),
    headlineText: v.optional(v.string()),
    buttonText: v.optional(v.string()),
    descriptionText: v.optional(v.string()),
    showButtonLogo: v.optional(v.boolean()),
    privacyPolicy: v.optional(v.string()),
    termsOfService: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const updateFields: {
      name: string;
      logo?: string;
      primaryColor?: string;
      buttonColor?: string;
      systemPrompt?: string;
      headlineText?: string;
      buttonText?: string;
      descriptionText?: string;
      showButtonLogo?: boolean;
      privacyPolicy?: string;
      termsOfService?: string;
    } = {
      name: args.name,
    };

    // Only add optional fields if they are present
    if (args.logo !== undefined) updateFields.logo = args.logo;
    if (args.primaryColor !== undefined)
      updateFields.primaryColor = args.primaryColor;
    if (args.systemPrompt !== undefined)
      updateFields.systemPrompt = args.systemPrompt;
    if (args.headlineText !== undefined)
      updateFields.headlineText = args.headlineText;
    if (args.buttonText !== undefined)
      updateFields.buttonText = args.buttonText;
    if (args.descriptionText !== undefined)
      updateFields.descriptionText = args.descriptionText;
    if (args.showButtonLogo !== undefined)
      updateFields.showButtonLogo = args.showButtonLogo;
    if (args.privacyPolicy !== undefined)
      updateFields.privacyPolicy = args.privacyPolicy;
    if (args.termsOfService !== undefined)
      updateFields.termsOfService = args.termsOfService;
    if (args.buttonColor !== undefined)
      updateFields.buttonColor = args.buttonColor;
    await ctx.db.patch(args.id, updateFields);
    return true;
  },
});

export const updateAgentName = mutation({
  args: {
    id: v.id("agent"),
    name: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.id, {
      name: args.name,
    });
    return true;
  },
});

export const deleteAgent = mutation({
  args: { id: v.id("agent") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
    return true;
  },
});

export const getAgentsByProjectId = query({
  args: { projectId: v.id("project") },
  handler: async (ctx, args) => {
    const agents = await ctx.db
      .query("agent")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .collect();
    return agents;
  },
});

export const getAgentsByUserId = query({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    const agents = await ctx.db
      .query("agent")
      .withIndex("by_user", (q) => q.eq("createdBy", args.userId))
      .collect();
    return agents;
  },
});

export const getAgentByProjectAndUser = query({
  args: {
    projectId: v.id("project"),
    userId: v.string(),
  },
  handler: async (ctx, args) => {
    const agent = await ctx.db
      .query("agent")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .filter((q) => q.eq(q.field("createdBy"), args.userId))
      .first();
    return agent;
  },
});



================================================
FILE: docs/convex/organizations.ts
================================================
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

export const createOrganization = mutation({
  args: {
    name: v.string(),
    createdBy: v.string(),
    stripeCustomerId: v.optional(v.string()),
    stripeSubscriptionId: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const id = await ctx.db.insert("organization", {
      name: args.name,
      createdBy: args.createdBy,
      stripeCustomerId: args.stripeCustomerId,
      stripeSubscriptionId: args.stripeSubscriptionId,
    });
    return id;
  },
});

export const getOrganization = query({
  args: { id: v.id("organization") },
  handler: async (ctx, args) => {
    const organization = await ctx.db.get(args.id);
    return organization;
  },
});

export const updateOrganization = mutation({
  args: {
    id: v.id("organization"),
    name: v.string(),
    stripeCustomerId: v.optional(v.string()),
    stripeSubscriptionId: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.id, {
      name: args.name,
      stripeCustomerId: args.stripeCustomerId,
      stripeSubscriptionId: args.stripeSubscriptionId,
    });
    return true;
  },
});

export const getOrganizationByUserId = query({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    const organization = await ctx.db
      .query("organization")
      .withIndex("by_user", (q) => q.eq("createdBy", args.userId))
      .first();
    return organization;
  },
});

export const deleteOrganization = mutation({
  args: { id: v.id("organization") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
    return true;
  },
});



================================================
FILE: docs/convex/projects.ts
================================================
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

export const createProject = mutation({
  args: {
    name: v.string(),
    createdBy: v.string(),
    logo: v.optional(v.string()),
    primaryColor: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const id = await ctx.db.insert("project", {
      name: args.name,
      createdBy: args.createdBy,
      logo: args.logo,
      primaryColor: args.primaryColor,
    });
    return id;
  },
});

export const getProject = query({
  args: { id: v.id("project") },
  handler: async (ctx, args) => {
    const project = await ctx.db.get(args.id);
    return project;
  },
});

export const updateProject = mutation({
  args: {
    id: v.id("project"),
    name: v.string(),
    logo: v.optional(v.string()),
    primaryColor: v.optional(v.string()),
    githubClientId: v.optional(v.string()),
    githubClientSecret: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.id, {
      name: args.name,
      logo: args.logo,
      primaryColor: args.primaryColor,
      githubClientId: args.githubClientId,
      githubClientSecret: args.githubClientSecret,
    });
    return true;
  },
});

export const getProjectByUserId = query({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    const project = await ctx.db
      .query("project")
      .withIndex("by_user", (q) => q.eq("createdBy", args.userId))
      .first();
    return project;
  },
});

export const getProjectsByUserId = query({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    const projects = await ctx.db
      .query("project")
      .withIndex("by_user", (q) => q.eq("createdBy", args.userId))
      .collect();
    return projects;
  },
});

export const deleteProject = mutation({
  args: { id: v.id("project") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
    return true;
  },
});



================================================
FILE: docs/convex/schema.ts
================================================
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  organization: defineTable({
    name: v.string(),
    createdBy: v.string(),
    stripeCustomerId: v.optional(v.string()),
    stripeSubscriptionId: v.optional(v.string()),
  }).index("by_user", ["createdBy"]),
  userProfile: defineTable(
    v.object({
      userId: v.string(),
      organizationId: v.optional(v.id("organization")),
    })
  ).index("by_user", ["userId"]),
  project: defineTable({
    name: v.string(),
    createdBy: v.string(),
    logo: v.optional(v.string()),
    primaryColor: v.optional(v.string()),
    githubClientId: v.optional(v.string()),
    githubClientSecret: v.optional(v.string()),
  }).index("by_user", ["createdBy"]),
  agent: defineTable({
    name: v.string(),
    status: v.union(v.literal("ACTIVE"), v.literal("INACTIVE")),
    createdBy: v.string(),
    projectId: v.id("project"),
    logo: v.optional(v.string()),
    primaryColor: v.optional(v.string()),
    systemPrompt: v.optional(v.string()),
    buttonColor: v.optional(v.string()),
    headlineText: v.optional(v.string()),
    buttonText: v.optional(v.string()),
    descriptionText: v.optional(v.string()),
    showButtonLogo: v.optional(v.boolean()),
    privacyPolicy: v.optional(v.string()),
    termsOfService: v.optional(v.string()),
  })
    .index("by_user", ["createdBy"])
    .index("by_project", ["projectId"]),
  actionLog: defineTable({
    action: v.union(v.literal("COPY_PROMPT"), v.literal("CREATE_AGENT")),
    agentId: v.id("agent"),
    projectId: v.id("project"),
    metadata: v.optional(
      v.object({
        repository: v.optional(v.string()),
        instructions: v.optional(v.string()),
        githubUserProfile: v.optional(
          v.object({
            name: v.optional(v.string()),
            avatar: v.optional(v.string()),
            profileUrl: v.optional(v.string()),
          })
        ),
      })
    ),
  })
    .index("by_agent", ["agentId"])
    .index("by_project", ["projectId"])
    .index("by_action", ["action"]),
});



================================================
FILE: docs/convex/userProfiles.ts
================================================
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

// Create a new user profile
export const createUserProfile = mutation({
  args: {
    userId: v.string(),
    organizationId: v.optional(v.id("organization")),
  },
  handler: async (ctx, args) => {
    const id = await ctx.db.insert("userProfile", {
      userId: args.userId,
      organizationId: args.organizationId,
    });
    return id;
  },
});

// Get a user profile by userId
export const getUserProfile = query({
  args: { userId: v.string() },
  handler: async (ctx, args) => {
    const profile = await ctx.db
      .query("userProfile")
      .withIndex("by_user", (q) => q.eq("userId", args.userId))
      .first();
    return profile;
  },
});

// Delete a user profile by document id
export const deleteUserProfile = mutation({
  args: { id: v.id("userProfile") },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
    return true;
  },
});



================================================
FILE: docs/convex/_generated/api.d.ts
================================================
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  ApiFromModules,
  FilterApi,
  FunctionReference,
} from "convex/server";
import type * as actionLogs from "../actionLogs.js";
import type * as agents from "../agents.js";
import type * as organizations from "../organizations.js";
import type * as projects from "../projects.js";
import type * as userProfiles from "../userProfiles.js";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
declare const fullApi: ApiFromModules<{
  actionLogs: typeof actionLogs;
  agents: typeof agents;
  organizations: typeof organizations;
  projects: typeof projects;
  userProfiles: typeof userProfiles;
}>;
export declare const api: FilterApi<
  typeof fullApi,
  FunctionReference<any, "public">
>;
export declare const internal: FilterApi<
  typeof fullApi,
  FunctionReference<any, "internal">
>;



================================================
FILE: docs/convex/_generated/api.js
================================================
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import { anyApi } from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
export const api = anyApi;
export const internal = anyApi;



================================================
FILE: docs/convex/_generated/dataModel.d.ts
================================================
/* eslint-disable */
/**
 * Generated data model types.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  DataModelFromSchemaDefinition,
  DocumentByName,
  TableNamesInDataModel,
  SystemTableNames,
} from "convex/server";
import type { GenericId } from "convex/values";
import schema from "../schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<
  DataModel,
  TableName
>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames | SystemTableNames> =
  GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like `queryGeneric` and
 * `mutationGeneric` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;



================================================
FILE: docs/convex/_generated/server.d.ts
================================================
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  ActionBuilder,
  HttpActionBuilder,
  MutationBuilder,
  QueryBuilder,
  GenericActionCtx,
  GenericMutationCtx,
  GenericQueryCtx,
  GenericDatabaseReader,
  GenericDatabaseWriter,
} from "convex/server";
import type { DataModel } from "./dataModel.js";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const query: QueryBuilder<DataModel, "public">;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const internalQuery: QueryBuilder<DataModel, "internal">;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const mutation: MutationBuilder<DataModel, "public">;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const internalMutation: MutationBuilder<DataModel, "internal">;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export declare const action: ActionBuilder<DataModel, "public">;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export declare const internalAction: ActionBuilder<DataModel, "internal">;

/**
 * Define an HTTP action.
 *
 * This function will be used to respond to HTTP requests received by a Convex
 * deployment if the requests matches the path and method where this action
 * is routed. Be sure to route your action in `convex/http.js`.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Import this function from `convex/http.js` and route it to hook it up.
 */
export declare const httpAction: HttpActionBuilder;

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;

/**
 * A set of services for use within Convex action functions.
 *
 * The action context is passed as the first argument to any Convex action
 * function run on the server.
 */
export type ActionCtx = GenericActionCtx<DataModel>;

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link Id}, or {@link DatabaseReader.query}, which starts
 * building a query.
 */
export type DatabaseReader = GenericDatabaseReader<DataModel>;

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 */
export type DatabaseWriter = GenericDatabaseWriter<DataModel>;



================================================
FILE: docs/convex/_generated/server.js
================================================
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
} from "convex/server";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const query = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const internalQuery = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const mutation = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const internalMutation = internalMutationGeneric;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export const action = actionGeneric;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export const internalAction = internalActionGeneric;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */
export const httpAction = httpActionGeneric;



================================================
FILE: docs/hooks/use-github.ts
================================================
import { useState, useEffect } from "react";
import { siteConfig } from "@/config";

export type Agent = {
  _id: string;
  name: string;
  descriptionText: string;
  headlineText: string;
  buttonText: string;
  logo: string;
  showButtonLogo: boolean;
  systemPrompt: string;
  primaryColor: string;
  projectId: string;
};

export type Project = {
  _id: string;
  logo: string;
  name: string;
  primaryColor: string;
  githubClientId: string;
  githubClientSecret: string;
};

export interface GitHubRepository {
  id: number;
  name: string;
  full_name: string;
  private: boolean;
  description?: string;
  html_url: string;
  default_branch: string;
  fork: boolean;
  permissions?: {
    admin: boolean;
    push: boolean;
    pull: boolean;
  };
}

export interface GitHubUser {
  id: number;
  login: string;
  avatar_url: string;
  name?: string;
  email?: string;
}

export interface GitHubAuth {
  isAuthenticated: boolean;
  user: GitHubUser | null;
  repositories: GitHubRepository[];
  isLoading: boolean;
  isFetchingRepositories: boolean;
  token: string | null;
  error: string | null;
  login: (agentId: string) => Promise<void>;
  logout: () => void;
  fetchRepositories: (agentId: string) => Promise<void>;
}

export function useGitHubAuth(agentId: string): GitHubAuth {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState<GitHubUser | null>(null);
  const [repositories, setRepositories] = useState<GitHubRepository[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isFetchingRepositories, setIsFetchingRepositories] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [token, setToken] = useState<string | null>(null);

  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (event.data.type === "GITHUB_AUTH_SUCCESS") {
        // Wait a bit for cookies to be set, then check auth status
        setTimeout(async () => {
          // Instead of reloading the page, just check auth status again
          const userCookie = document.cookie
            .split("; ")
            .find((row) => row.startsWith("github_user="));

          const userTokenCookie = document.cookie
            .split("; ")
            .find((row) => row.startsWith("github_access_token="));

          if (userCookie && userTokenCookie) {
            try {
              const userData = JSON.parse(
                decodeURIComponent(userCookie.split("=")[1])
              );
              const userToken = decodeURIComponent(
                userTokenCookie.split("=")[1]
              );

              setUser(userData);
              setIsAuthenticated(true);
              setToken(userToken);
              await fetchRepositories(agentId);
              setIsLoading(false);
            } catch (error) {
              console.error("Error parsing user data:", error);
              setIsAuthenticated(false);
              setUser(null);
              setIsLoading(false);
            }
          }
        }, 1000);
      }
    };

    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  }, []);

  const login = async (agentId: string): Promise<void> => {
    try {
      setIsLoading(true);
      setError(null);

      // Get the auth URL from our API with prompt=consent to always show grant page
      const response = await fetch(
        `${siteConfig.baseUrl}/api/github/auth/url?agentId=${agentId}`
      );
      const { url } = await response.json();

      // Open popup window for OAuth - centered on screen
      const width = 600;
      const height = 700;
      const left = (window.screen.width - width) / 2;
      const top = (window.screen.height - height) / 2;

      const popup = window.open(
        url,
        "github-oauth",
        `width=${width},height=${height},left=${left},top=${top},scrollbars=yes,resizable=yes`
      );

      // Check if popup was blocked
      if (!popup) {
        throw new Error("Popup blocked. Please allow popups for this site.");
      }

      // Wait for popup to close
      const checkClosed = setInterval(() => {
        if (popup.closed) {
          clearInterval(checkClosed);
          setIsLoading(false);
        }
      }, 1000);
    } catch (error) {
      setError(
        error instanceof Error ? error.message : "Authentication failed"
      );
      setIsLoading(false);
    }
  };

  const logout = (): void => {
    // Clear cookies
    document.cookie =
      "github_access_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
    document.cookie =
      "github_user=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";

    setIsAuthenticated(false);
    setUser(null);
    setRepositories([]);
  };

  const fetchRepositories = async (agentId: string): Promise<void> => {
    try {
      setIsFetchingRepositories(true);
      setError(null);

      const response = await fetch(
        `${siteConfig.baseUrl}/api/github/repositories?token=${token}&agentId=${agentId}`
      );

      if (!response.ok) {
        throw new Error("Failed to fetch repositories");
      }

      const data = await response.json();
      setRepositories(data.repositories || []);
    } catch (error) {
      setError(
        error instanceof Error ? error.message : "Failed to fetch repositories"
      );
    } finally {
      setIsFetchingRepositories(false);
    }
  };

  return {
    isAuthenticated,
    user,
    repositories,
    isLoading,
    isFetchingRepositories,
    error,
    token,
    login,
    logout,
    fetchRepositories,
  };
}



================================================
FILE: docs/lib/clerk.ts
================================================
import { createClerkClient } from "@clerk/backend";

export const clerkClient = createClerkClient({
  secretKey: process.env.CLERK_SECRET_KEY,
});



================================================
FILE: docs/lib/github.ts
================================================
import { siteConfig } from "@/config";

export interface GitHubRepository {
  id: number;
  name: string;
  full_name: string;
  private: boolean;
  description?: string;
  html_url: string;
  default_branch: string;
  fork: boolean;
  permissions?: {
    admin: boolean;
    push: boolean;
    pull: boolean;
  };
}

export interface GitHubUser {
  id: number;
  login: string;
  avatar_url: string;
  name?: string;
  email?: string;
}

export class GitHubAuth {
  private clientId: string;
  private clientSecret: string;
  private redirectUri: string;

  constructor(clientId?: string, clientSecret?: string) {
    this.clientId = clientId || process.env.GITHUB_CLIENT_ID!;
    this.clientSecret = clientSecret || process.env.GITHUB_CLIENT_SECRET!;
    this.redirectUri = siteConfig.githubCallbackUrl;
  }

  // Generate GitHub OAuth URL
  getAuthUrl(state?: string): string {
    const params = new URLSearchParams({
      client_id: this.clientId,
      redirect_uri: this.redirectUri,
      scope: "repo user:email",
      state: state || Math.random().toString(36).substring(7),
    });

    return `https://github.com/login/oauth/authorize?${params.toString()}`;
  }

  // Exchange code for access token
  async exchangeCodeForToken(code: string): Promise<string> {
    const response = await fetch(
      "https://github.com/login/oauth/access_token",
      {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          client_id: this.clientId,
          client_secret: this.clientSecret,
          code,
        }),
      }
    );

    const data = await response.json();

    if (data.error) {
      throw new Error(`GitHub OAuth error: ${data.error_description}`);
    }

    return data.access_token;
  }

  // Get user information
  async getUser(accessToken: string): Promise<GitHubUser> {
    const response = await fetch("https://api.github.com/user", {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/vnd.github.v3+json",
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch user: ${response.statusText}`);
    }

    return response.json();
  }

  // Get user repositories
  async getUserRepositories(accessToken: string): Promise<GitHubRepository[]> {
    const response = await fetch(
      "https://api.github.com/user/repos?sort=updated&per_page=100",
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: "application/vnd.github.v3+json",
        },
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to fetch repositories: ${response.statusText}`);
    }

    return response.json();
  }

  // Create a pull request
  async createPullRequest(
    accessToken: string,
    owner: string,
    repo: string,
    title: string,
    body: string,
    head: string,
    base: string = "main"
  ) {
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/pulls`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: "application/vnd.github.v3+json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          title,
          body,
          head,
          base,
        }),
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to create pull request: ${response.statusText}`);
    }

    return response.json();
  }
}

export const getGithubAuth = (clientId?: string, clientSecret?: string) =>
  new GitHubAuth(clientId, clientSecret);



================================================
FILE: docs/lib/inngest.ts
================================================
import { Inngest } from "inngest";

import { realtimeMiddleware, channel, topic } from "@inngest/realtime";
import { generateClient } from "@/lib/vibekit";

let app: Inngest | undefined;

// Create a client to send and receive events
export const inngest = new Inngest({
  id: "vibekit",
  middleware: [realtimeMiddleware()],
});

export const getInngestApp = () => {
  return (app ??= new Inngest({
    id: typeof window !== "undefined" ? "client" : "server",
    middleware: [realtimeMiddleware()],
  }));
};

export const agentChannel = channel("agents").addTopic(
  topic("status").type<{
    status:
      | "INITIALIZING"
      | "CLONING_REPO"
      | "IMPLEMENTING_CODE"
      | "CREATING_PR"
      | "DONE";
    logId: string;
  }>()
);
export const createAgent = inngest.createFunction(
  {
    id: "run-agent",
  },
  { event: "app/run.agent" },
  async ({ event, step, publish }) => {
    const { repository, instructions, prompt, githubToken, logId } = event.data;
    const client = generateClient(githubToken, repository);

    await publish(
      agentChannel().status({
        status: "INITIALIZING",
        logId,
      })
    );

    await step.run("generate code", async () => {
      await client.generateCode({
        prompt:
          `## GOAL\nYour goal is to implement the below instructions into the users project.\n` +
          "DO NOT install any dependencies.\n\n" +
          `#USER INSTRUCTIONS\n${instructions}\n\n#DOCUMENTATION\n${prompt}`,
        mode: "code",
        callbacks: {
          async onUpdate(message: string) {
            try {
              const _message = JSON.parse(message);
              console.log("message", message);
              if (_message.type === "start") {
                await publish(
                  agentChannel().status({
                    status: "INITIALIZING",
                    logId,
                  })
                );
              } else if (_message.type === "git") {
                await publish(
                  agentChannel().status({
                    status: "CLONING_REPO",
                    logId,
                  })
                );
              } else {
                await publish(
                  agentChannel().status({
                    status: "IMPLEMENTING_CODE",
                    logId,
                  })
                );
              }
            } catch {
              // Log non-JSON messages for debugging but don't crash
              console.log("Received non-JSON message:", message);
            }
          },
          onError(error) {
            console.error(error);
          },
        },
      });

      await publish(
        agentChannel().status({
          status: "CREATING_PR",
          logId,
        })
      );

      await client.createPullRequest();

      return { message: "Code generated" };
    });

    await publish(
      agentChannel().status({
        status: "DONE",
        logId,
      })
    );

    return { message: "Agent run completed" };
  }
);



================================================
FILE: docs/lib/stripe.ts
================================================
import Stripe from "stripe";

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);



================================================
FILE: docs/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// Returns either '#000' (black) or '#fff' (white) depending on which has better contrast with the given hex background color
export function getContrastTextColor(hex: string): "#000" | "#fff" {
  // Remove hash if present
  hex = hex.replace("#", "");
  // Convert 3-digit hex to 6-digit
  if (hex.length === 3) {
    hex = hex
      .split("")
      .map((x) => x + x)
      .join("");
  }
  if (hex.length !== 6) return "#000"; // fallback
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);
  // Calculate luminance
  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return luminance > 0.5 ? "#000" : "#fff";
}



================================================
FILE: docs/lib/vibekit.ts
================================================
import { VibeKit, VibeKitConfig } from "@vibe-kit/sdk";

export function generateClient(githubToken: string, repository: string) {
  const config: VibeKitConfig = {
    agent: {
      type: "claude",
      model: {
        apiKey: process.env.ANTHROPIC_API_KEY!,
      },
    },
    environment: {
      e2b: {
        apiKey: process.env.E2B_API_KEY!,
      },
    },
    github: {
      token: githubToken,
      repository: repository,
    },
  };

  const client = new VibeKit(config);

  return client;
}



================================================
FILE: docs/providers/convex.tsx
================================================
"use client";

import { ConvexProvider, ConvexReactClient } from "convex/react";
import { ReactNode } from "react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({ children }: { children: ReactNode }) {
  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
}



================================================
FILE: docs/proxy/anthropic-sdk.mdx
================================================
---
title: Anthropic SDK
description: "Integrate VibeKit Proxy with Anthropic SDK for Python and TypeScript"
---

## Overview

VibeKit Proxy seamlessly integrates with the Anthropic SDK, providing automatic data redaction and security for your Claude applications without changing your existing code.

<Warning>
Make sure you have the VibeKit Proxy server installed and running before using this integration. See the [Quickstart guide](/proxy/quickstart) for installation instructions.
</Warning>

## Integration

Simply add the VibeKit Proxy URL to your existing Anthropic SDK configuration:

<CodeGroup>

```python Python
import anthropic

client = anthropic.Anthropic(
    base_url="http://localhost:8080"  # Add this line
)

message = client.messages.create(
    model="claude-3-5-sonnet-20241022",
    max_tokens=1024,
    messages=[
        {"role": "user", "content": "My SSN is 123-45-6789. Help me with privacy."}
    ]
)
```

```typescript TypeScript
import Anthropic from '@anthropic-ai/sdk';

const anthropic = new Anthropic({
  baseURL: 'http://localhost:8080'  // Add this line
});

const message = await anthropic.messages.create({
  model: 'claude-3-5-sonnet-20241022',
  max_tokens: 1024,
  messages: [
    { role: 'user', content: 'My email is john@company.com and phone is 555-0123.' }
  ]
});
```

</CodeGroup>

## Environment Configuration

<CodeGroup>

```python Python
import os
import anthropic

proxy_url = os.getenv("VIBEKIT_PROXY_URL", "http://localhost:8080")

client = anthropic.Anthropic(
    base_url=proxy_url  # Use environment variable
)
```

```typescript TypeScript
import Anthropic from '@anthropic-ai/sdk';

const proxyUrl = process.env.VIBEKIT_PROXY_URL || 'http://localhost:8080';

const anthropic = new Anthropic({
  baseURL: proxyUrl  // Use environment variable
});
```

```bash Environment Variables
# Development
VIBEKIT_PROXY_URL=http://localhost:8080

# Production  
VIBEKIT_PROXY_URL=https://your-proxy-domain.com
```

</CodeGroup>



================================================
FILE: docs/proxy/aws-deployment.mdx
================================================
---
title: AWS Deployment
description: "Deploy VibeKit Proxy to AWS using ECS, Lambda, EC2, and other AWS services"
---

## Overview

This guide covers deploying VibeKit Proxy to Amazon Web Services (AWS) using various services including ECS with Fargate, Lambda, EC2, and EKS.

## ECS with Fargate

AWS Fargate provides serverless container hosting that's perfect for VibeKit Proxy.

### Task Definition

Create a task definition for your VibeKit Proxy container:

```json
{
  "family": "vibekit-proxy",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "executionRoleArn": "arn:aws:iam::ACCOUNT:role/ecsTaskExecutionRole",
  "taskRoleArn": "arn:aws:iam::ACCOUNT:role/ecsTaskRole",
  "containerDefinitions": [
    {
      "name": "vibekit-proxy",
      "image": "your-account.dkr.ecr.region.amazonaws.com/vibekit-proxy:latest",
      "portMappings": [
        {
          "containerPort": 8080,
          "protocol": "tcp"
        }
      ],
      "essential": true,
      "healthCheck": {
        "command": ["CMD-SHELL", "curl -f http://localhost:8080/health || exit 1"],
        "interval": 30,
        "timeout": 5,
        "retries": 3,
        "startPeriod": 10
      },
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/vibekit-proxy",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      },
      "environment": [
        {
          "name": "NODE_ENV",
          "value": "production"
        },
        {
          "name": "PORT",
          "value": "8080"
        }
      ]
    }
  ]
}
```

### ECS Service

Create a service to manage your containers:

```json
{
  "serviceName": "vibekit-proxy-service",
  "cluster": "vibekit-cluster",
  "taskDefinition": "vibekit-proxy:1",
  "desiredCount": 2,
  "launchType": "FARGATE",
  "networkConfiguration": {
    "awsvpcConfiguration": {
      "subnets": [
        "subnet-12345678",
        "subnet-87654321"
      ],
      "securityGroups": [
        "sg-12345678"
      ],
      "assignPublicIp": "ENABLED"
    }
  },
  "loadBalancers": [
    {
      "targetGroupArn": "arn:aws:elasticloadbalancing:region:account:targetgroup/vibekit-proxy/12345",
      "containerName": "vibekit-proxy",
      "containerPort": 8080
    }
  ],
  "deploymentConfiguration": {
    "maximumPercent": 200,
    "minimumHealthyPercent": 50
  }
}
```

### Application Load Balancer

```yaml
# CloudFormation template for ALB
Resources:
  VibeKitProxyALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: vibekit-proxy-alb
      Scheme: internet-facing
      Type: application
      Subnets:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      SecurityGroups:
        - !Ref ALBSecurityGroup

  VibeKitProxyTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: vibekit-proxy-tg
      Port: 8080
      Protocol: HTTP
      VpcId: !Ref VPC
      TargetType: ip
      HealthCheckPath: /health
      HealthCheckProtocol: HTTP
      HealthCheckIntervalSeconds: 30
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 3

  VibeKitProxyListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref VibeKitProxyTargetGroup
      LoadBalancerArn: !Ref VibeKitProxyALB
      Port: 80
      Protocol: HTTP
```

## Lambda Deployment

Deploy VibeKit Proxy as a serverless function using AWS Lambda.

### Serverless Framework

**serverless.yml:**
```yaml
service: vibekit-proxy-lambda

provider:
  name: aws
  runtime: nodejs18.x
  region: us-east-1
  timeout: 30
  memorySize: 1024
  stage: ${opt:stage, 'dev'}
  environment:
    NODE_ENV: production
    STAGE: ${self:provider.stage}
  iamRoleStatements:
    - Effect: Allow
      Action:
        - logs:CreateLogGroup
        - logs:CreateLogStream
        - logs:PutLogEvents
      Resource: "*"

functions:
  proxy:
    handler: src/lambda.handler
    events:
      - http:
          path: /{proxy+}
          method: ANY
          cors:
            origin: '*'
            headers:
              - Content-Type
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
    reservedConcurrency: 100

plugins:
  - serverless-offline
  - serverless-webpack

custom:
  webpack:
    webpackConfig: webpack.config.js
    includeModules: true
    packager: npm

package:
  individually: true
  exclude:
    - .git/**
    - .github/**
    - test/**
    - docs/**
```

**src/lambda.js:**
```javascript
import serverless from 'serverless-http';
import express from 'express';
import ProxyServer from '@vibe-kit/proxy/src/server.js';

const app = express();

// Initialize proxy server
const proxy = new ProxyServer(8080);

// Handle all requests through the proxy
app.use('*', async (req, res) => {
  try {
    await proxy.handleHttpRequest(req, res);
  } catch (error) {
    console.error('Proxy error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    version: process.env.npm_package_version || '1.0.0'
  });
});

export const handler = serverless(app, {
  binary: ['*/*']
});
```

### API Gateway Configuration

```yaml
# CloudFormation for API Gateway
Resources:
  VibeKitProxyApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: vibekit-proxy-api
      Description: VibeKit Proxy API Gateway
      EndpointConfiguration:
        Types:
          - REGIONAL

  VibeKitProxyResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref VibeKitProxyApiGateway
      ParentId: !GetAtt VibeKitProxyApiGateway.RootResourceId
      PathPart: '{proxy+}'

  VibeKitProxyMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref VibeKitProxyApiGateway
      ResourceId: !Ref VibeKitProxyResource
      HttpMethod: ANY
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${VibeKitProxyLambda.Arn}/invocations'
```

## EC2 Deployment

### User Data Script

```bash
#!/bin/bash
yum update -y
yum install -y docker

# Start Docker
systemctl start docker
systemctl enable docker

# Add ec2-user to docker group
usermod -a -G docker ec2-user

# Install Docker Compose
curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose

# Create app directory
mkdir -p /opt/vibekit-proxy

# Create docker-compose.yml
cat > /opt/vibekit-proxy/docker-compose.yml << EOF
version: '3.8'
services:
  vibekit-proxy:
    image: vibekit/proxy:latest
    ports:
      - "8080:8080"
    environment:
      - NODE_ENV=production
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
EOF

# Start the application
cd /opt/vibekit-proxy
docker-compose up -d
```

### CloudFormation Template

```yaml
AWSTemplateFormatVersion: '2010-09-09'
Description: 'VibeKit Proxy EC2 Deployment'

Parameters:
  InstanceType:
    Type: String
    Default: t3.micro
    AllowedValues:
      - t3.micro
      - t3.small
      - t3.medium
    Description: EC2 instance type

  KeyName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: EC2 Key Pair for SSH access

Resources:
  VibeKitProxySecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for VibeKit Proxy
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 8080
          ToPort: 8080
          CidrIp: 0.0.0.0/0

  VibeKitProxyInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: ami-0abcdef1234567890  # Amazon Linux 2 AMI
      InstanceType: !Ref InstanceType
      KeyName: !Ref KeyName
      SecurityGroupIds:
        - !Ref VibeKitProxySecurityGroup
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum update -y
          yum install -y docker
          systemctl start docker
          systemctl enable docker
          usermod -a -G docker ec2-user
          
          # Install Node.js
          curl -fsSL https://rpm.nodesource.com/setup_18.x | bash -
          yum install -y nodejs
          
          # Install VibeKit Proxy
          npm install -g @vibe-kit/proxy
          
          # Create systemd service
          cat > /etc/systemd/system/vibekit-proxy.service << EOF
          [Unit]
          Description=VibeKit Proxy Service
          After=network.target
          
          [Service]
          Type=simple
          User=ec2-user
          WorkingDirectory=/home/ec2-user
          ExecStart=/usr/bin/npx @vibe-kit/proxy start --port 8080
          Restart=always
          RestartSec=10
          Environment=NODE_ENV=production
          
          [Install]
          WantedBy=multi-user.target
          EOF
          
          # Start the service
          systemctl daemon-reload
          systemctl enable vibekit-proxy
          systemctl start vibekit-proxy

Outputs:
  InstancePublicIP:
    Description: Public IP address of the EC2 instance
    Value: !GetAtt VibeKitProxyInstance.PublicIp
    Export:
      Name: !Sub "${AWS::StackName}-PublicIP"
```

## EKS Deployment

### Kubernetes Manifests

**deployment.yaml:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vibekit-proxy
  namespace: default
  labels:
    app: vibekit-proxy
spec:
  replicas: 3
  selector:
    matchLabels:
      app: vibekit-proxy
  template:
    metadata:
      labels:
        app: vibekit-proxy
    spec:
      containers:
      - name: vibekit-proxy
        image: your-account.dkr.ecr.region.amazonaws.com/vibekit-proxy:latest
        ports:
        - containerPort: 8080
          name: http
        env:
        - name: NODE_ENV
          value: "production"
        - name: PORT
          value: "8080"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: vibekit-proxy-service
  namespace: default
spec:
  selector:
    app: vibekit-proxy
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
  type: LoadBalancer
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
```

### Auto Scaling

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: vibekit-proxy-hpa
  namespace: default
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: vibekit-proxy
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

## Security Configuration

### IAM Roles and Policies

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents",
        "logs:DescribeLogGroups",
        "logs:DescribeLogStreams"
      ],
      "Resource": "arn:aws:logs:*:*:*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "ecr:BatchCheckLayerAvailability",
        "ecr:GetDownloadUrlForLayer",
        "ecr:BatchGetImage",
        "ecr:GetAuthorizationToken"
      ],
      "Resource": "*"
    }
  ]
}
```

### Security Groups

```yaml
# Security group for ECS/EC2
VibeKitProxySecurityGroup:
  Type: AWS::EC2::SecurityGroup
  Properties:
    GroupDescription: Security group for VibeKit Proxy
    VpcId: !Ref VPC
    SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 8080
        ToPort: 8080
        SourceSecurityGroupId: !Ref ALBSecurityGroup
        Description: Allow traffic from ALB
    SecurityGroupEgress:
      - IpProtocol: -1
        CidrIp: 0.0.0.0/0
        Description: Allow all outbound traffic
```

## Monitoring and Logging

### CloudWatch Configuration

```yaml
# CloudWatch Log Group
VibeKitProxyLogGroup:
  Type: AWS::Logs::LogGroup
  Properties:
    LogGroupName: /aws/ecs/vibekit-proxy
    RetentionInDays: 7

# CloudWatch Alarms
VibeKitProxyHighCPUAlarm:
  Type: AWS::CloudWatch::Alarm
  Properties:
    AlarmName: VibeKit-Proxy-High-CPU
    AlarmDescription: Alarm when CPU exceeds 80%
    MetricName: CPUUtilization
    Namespace: AWS/ECS
    Statistic: Average
    Period: 300
    EvaluationPeriods: 2
    Threshold: 80
    ComparisonOperator: GreaterThanThreshold
    Dimensions:
      - Name: ServiceName
        Value: vibekit-proxy-service
      - Name: ClusterName
        Value: vibekit-cluster
```

## Cost Optimization

### Recommendations

1. **Use Spot Instances** for non-critical workloads
2. **Auto Scaling Groups** to handle variable load
3. **Reserved Instances** for predictable workloads
4. **Lambda** for low-traffic scenarios
5. **CloudWatch** monitoring to optimize resource usage

## Troubleshooting

### Common Issues

1. **Task startup failures**: Check IAM permissions and image availability
2. **Health check failures**: Verify `/health` endpoint accessibility
3. **Network connectivity**: Check security groups and NACLs
4. **Resource limits**: Monitor CloudWatch metrics

### Debugging Commands

```bash
# ECS Service logs
aws logs get-log-events --log-group-name /aws/ecs/vibekit-proxy --log-stream-name <stream-name>

# Lambda logs
aws logs tail /aws/lambda/vibekit-proxy-lambda --follow

# ECS service status
aws ecs describe-services --cluster vibekit-cluster --services vibekit-proxy-service
```

## What's Next?

- Configure [GCP deployment](/proxy/gcp-deployment)
- Set up [monitoring and observability](/proxy/observability)
- Learn about [custom redaction rules](/proxy/redaction)
- Explore [performance optimization](/proxy/performance)


================================================
FILE: docs/proxy/claude-code.mdx
================================================
---
title: Claude Code
description: "Integrate VibeKit Proxy with Claude Code for secure AI-powered development"
---

## Overview

VibeKit Proxy seamlessly integrates with Claude Code, Anthropic's official CLI tool, providing automatic data redaction and security for your AI-powered development workflow without changing your existing code patterns.

<Warning>
Make sure you have the VibeKit Proxy server installed and running before using this integration. See the [Quickstart guide](/proxy/quickstart) for installation instructions.
</Warning>

## Prerequisites

Ensure you have Claude Code installed:

```bash
# Install Claude Code (if not already installed)
npm install -g @anthropic-ai/claude-code
```

## Configuration

Configure Claude Code to route through VibeKit Proxy using environment variables:

### Basic Proxy Configuration

```bash
# Set proxy environment variables
export ANTHROPIC_BASE_URL=http://localhost:8080

# Run Claude Code as normal
claude "Create a React component for user authentication"
```

### Environment Variable Configuration

Create a `.env` file or set environment variables:

```bash
# Basic proxy setup
ANTHROPIC_BASE_URL=http://localhost:8080
```

### Settings.json Configuration

You can also configure proxy settings in Claude Code's `settings.json`:

```json
{
  "env": {
    "ANTHROPIC_BASE_URL": "http://localhost:8080"
  }
}
```


================================================
FILE: docs/proxy/configuration.mdx
================================================
---
title: Configuration
description: "Complete guide to configuring VibeKit Proxy with vibekit.yaml"
---

VibeKit Proxy uses a YAML configuration file to define models, providers, and routing rules. This guide covers the complete configuration schema and usage examples.

## Configuration File Location

By default, both Node.js and Rust implementations look for `vibekit.yaml` in the current working directory. You can specify a custom config file path using the `--config` parameter:

<CodeGroup>

```bash Node.js
npm start -- --config=/etc/vibekit/vibekit.yaml
```

```bash Rust
./target/release/vibekit-proxy start --config=/etc/vibekit/vibekit.yaml
```

```bash Global Installation
vibekit-proxy start --config=/path/to/custom/vibekit.yaml
```

</CodeGroup>

## Basic Configuration Schema

### Minimal Configuration

The simplest configuration requires only a list of models:

```yaml
models:
  - model_name: "gpt-5"
    provider: "openai"
    api_base: "https://api.openai.com"
```

### Complete Schema

Here's the full configuration schema with all available options:

```yaml
# Model definitions - required
models:
  - model_name: "string"        # Model identifier (required)
    provider: "string"          # Provider name (required)
    api_base: "string"          # API endpoint URL (required)

## Field Descriptions

### Models Section

#### Required Fields

- **`model_name`**: The exact model identifier used in API requests. Must match the model name used by clients.
- **`provider`**: The AI provider name. Supported values: `openai`, `anthropic`, `google`, `mistral`, `cohere`.
- **`api_base`**: The base URL for the provider's API endpoint.

## Configuration Examples

### Multiple Providers

Configure multiple AI providers for different models:

```yaml
models:
  # OpenAI models
  - model_name: "gpt-5"
    provider: "openai"
    api_base: "https://api.openai.com"

  - model_name: "gpt-5-mini"
    provider: "openai"
    api_base: "https://api.openai.com"

  # Anthropic models
  - model_name: "claude-4-sonnet"
    provider: "anthropic"
    api_base: "https://api.anthropic.com/v1"

  - model_name: "claude-4-haiku"
    provider: "anthropic"
    api_base: "https://api.anthropic.com/v1"

  # Google models
  - model_name: "gemini-2.0-flash-thinking-exp"
    provider: "google"
    api_base: "https://generativelanguage.googleapis.com"
```

### Custom API Endpoints

Configure custom or self-hosted API endpoints:

```yaml
models:
  # Azure OpenAI
  - model_name: "gpt-5"
    provider: "openai"
    api_base: "https://your-resource.openai.azure.com"

  # Self-hosted model
  - model_name: "custom-llm"
    provider: "openai"  # Use OpenAI-compatible API
    api_base: "https://your-model.internal.com/v1"

  # AWS Bedrock (via proxy)
  - model_name: "claude-4-sonnet"
    provider: "anthropic"
    api_base: "https://bedrock-runtime.us-east-1.amazonaws.com"
```

## Validation and Testing

Test your configuration with the health endpoint:

```bash
# Check if proxy is running with your config
curl http://localhost:8080/health

# Test a specific model
curl -X POST http://localhost:8080/v1/responses \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your-api-key" \
  -d '{
    "model": "gpt-5",
    "messages": [{"role": "user", "content": "Hello"}]
  }'
```


================================================
FILE: docs/proxy/cursor-cli.mdx
================================================
---
title: Cursor CLI
description: "Integrate VibeKit Proxy with Cursor CLI for secure AI-powered development"
---

## Overview

VibeKit Proxy seamlessly integrates with Cursor CLI, Cursor's command-line interface for AI-powered development, providing automatic data redaction and security for your AI-powered development workflow without changing your existing code patterns.

<Warning>
Make sure you have the VibeKit Proxy server installed and running before using this integration. See the [Quickstart guide](/proxy/quickstart) for installation instructions.
</Warning>

## Prerequisites

Ensure you have Cursor CLI installed:

```bash
# Install Cursor CLI
curl https://cursor.com/install -fsS | bash
```

## Configuration

Configure Cursor CLI to route through VibeKit Proxy using the `--endpoint` flag:

### Basic Proxy Configuration

```bash
# Run Cursor CLI with proxy endpoint
cursor-agent --endpoint http://localhost:8080 "Create a React component for user authentication"
```


================================================
FILE: docs/proxy/deployment.mdx
================================================
---
title: Deployment Overview
description: "Deploy VibeKit Proxy to production environments on AWS, GCP, and other platforms"
---

## Cloud Platforms

Choose your preferred cloud platform for detailed deployment instructions:

<CardGroup cols={2}>
  <Card
    title="AWS Deployment"
    icon="aws"
    href="/proxy/aws-deployment"
    color="#888"
  >
    Deploy to ECS, Lambda, EC2, EKS with CloudFormation templates and Terraform configurations
  </Card>
  <Card
    title="GCP Deployment"  
    icon="google"
    href="/proxy/gcp-deployment"
    color="#888"
  >
    Deploy to Cloud Run, GKE, Compute Engine, Cloud Functions with comprehensive setup guides
  </Card>
</CardGroup>

## Docker Deployment

VibeKit Proxy is available as both Node.js and Rust implementations, each with optimized Docker containers.

### Using Pre-built Dockerfiles

Clone the vibekit-proxy repository to use the production-ready Dockerfiles:

```bash
git clone https://github.com/ismailpelaseyed/vibekit-proxy.git
cd vibekit-proxy
```

<CodeGroup>

```dockerfile Node.js (docker/Dockerfile.node)
# Multi-stage build for smaller production image
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY ../node/package*.json ./

# Install dependencies
RUN npm ci --only=production && npm cache clean --force

# Production stage
FROM node:18-alpine AS production

# Create non-root user for security
RUN addgroup -g 1001 -S nodejs && \
    adduser -S vibekit -u 1001

# Set working directory
WORKDIR /app

# Copy dependencies from builder stage
COPY --from=builder --chown=vibekit:nodejs /app/node_modules ./node_modules

# Copy application code
COPY --chown=vibekit:nodejs ../node/src ./src
COPY --chown=vibekit:nodejs ../node/package.json ./

# Copy shared config
COPY --chown=vibekit:nodejs ../vibekit.yaml ./

# Switch to non-root user
USER vibekit

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "http.get('http://localhost:8080/health', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })"

# Start the application
CMD ["node", "src/index.js"]
```

```dockerfile Rust (docker/Dockerfile.rust)
# Build stage
FROM rust:1.82 as builder

WORKDIR /app

# Copy Cargo files first for better layer caching
COPY rust/Cargo.toml rust/Cargo.lock ./

# Create a dummy main.rs to build dependencies
RUN mkdir src && echo "fn main() {}" > src/main.rs
RUN cargo build --release
RUN rm -rf src

# Copy source code
COPY rust/src/ ./src/

# Build the actual application
RUN cargo build --release

# Runtime stage
FROM debian:bookworm-slim

# Install necessary packages
RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy the binary from builder stage
COPY --from=builder /app/target/release/vibekit-proxy ./vibekit-proxy

# Copy config file
COPY vibekit.yaml ./vibekit.yaml

# Create non-root user
RUN useradd -r -s /bin/false vibekit
RUN chown -R vibekit:vibekit /app
USER vibekit

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD ./vibekit-proxy status || exit 1

# Default command
CMD ["./vibekit-proxy", "start", "--port", "8080", "--config", "vibekit.yaml"]
```

</CodeGroup>

### Building and Running

<CodeGroup>

```bash Node.js
# Build Node.js version
docker build -f docker/Dockerfile.node -t vibekit-proxy-node .

# Run Node.js version
docker run -p 8080:8080 -v ./vibekit.yaml:/app/vibekit.yaml vibekit-proxy-node
```

```bash Rust
# Build Rust version
docker build -f docker/Dockerfile.rust -t vibekit-proxy-rust .

# Run Rust version
docker run -p 8080:8080 -v ./vibekit.yaml:/app/vibekit.yaml vibekit-proxy-rust
```

</CodeGroup>

## Local Development

### Docker Compose

Use the included `docker-compose.yml` that runs both implementations:

```yaml
# docker/docker-compose.yml
version: '3.8'

services:
  vibekit-proxy-node:
    build:
      context: ..
      dockerfile: docker/Dockerfile.node
    ports:
      - "8080:8080"
    environment:
      - NODE_ENV=production
      - PORT=8080
    volumes:
      - ../vibekit.yaml:/app/vibekit.yaml:ro
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "node", "-e", "http.get('http://localhost:8080/health', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - vibekit-network

  vibekit-proxy-rust:
    build:
      context: ..
      dockerfile: docker/Dockerfile.rust
    ports:
      - "8081:8080"
    volumes:
      - ../vibekit.yaml:/app/vibekit.yaml:ro
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "./vibekit-proxy", "status"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 5s
    networks:
      - vibekit-network

networks:
  vibekit-network:
    driver: bridge
```

Start both services:
```bash
cd docker
docker-compose up -d
```

Or start individual services:
```bash
# Node.js only on port 8080
docker-compose up vibekit-proxy-node -d

# Rust only on port 8081
docker-compose up vibekit-proxy-rust -d
```

### Direct Installation

<CodeGroup>

```bash Node.js
# Install and run locally
npm install -g vibekit-proxy
vibekit-proxy start --port 8080
```

```bash Rust
# Install and run locally
cargo install vibekit-proxy
vibekit-proxy start --port 8080
```

</CodeGroup>

## Configuration

### Config File (vibekit.yaml)

Both implementations use the same configuration format:

```yaml
models:
  - model_name: "gpt-4o"
    provider: "openai"
    api_base: "https://api.openai.com"
  
  - model_name: "claude-3-7-sonnet-20250219"
    provider: "anthropic"
    api_base: "https://api.anthropic.com/v1"
```

### Environment Variables

```bash
# Production environment variables
PORT=8080
```

## Health Monitoring

The proxy exposes a `/health` endpoint for monitoring:

```json
{
  "status": "healthy",
  "uptime": 3600,
  "timestamp": "2025-01-15T10:30:00.000Z",
  "requestCount": 1234
}
```

## Security Best Practices

- Use HTTPS termination at load balancer
- Run containers as non-root user
- Implement rate limiting
- Restrict network access with security groups/firewall rules
- Regular security updates

## Troubleshooting

Common issues and solutions:

1. **Port binding errors**: Ensure port 8080 is available
2. **Memory limits**: Monitor and adjust container memory
3. **Network connectivity**: Check security groups and firewall rules
4. **Health check failures**: Verify `/health` endpoint accessibility

### Debugging Commands

```bash
# Check proxy status
vibekit-proxy status --port 8080

# View container logs  
docker logs vibekit-proxy-container

# Test health endpoint
curl http://localhost:8080/health
```

## What's Next?

- Set up [monitoring and observability](/proxy/observability)
- Configure [custom redaction rules](/proxy/redaction)  
- Learn about [compliance features](/proxy/compliance)
- Explore [performance optimization](/proxy/performance)


================================================
FILE: docs/proxy/gcp-deployment.mdx
================================================
---
title: GCP Deployment
description: "Deploy VibeKit Proxy to Google Cloud Platform using Cloud Run, GKE, Compute Engine, and other GCP services"
---

## Overview

This guide covers deploying VibeKit Proxy to Google Cloud Platform (GCP) using various services including Cloud Run, Google Kubernetes Engine (GKE), Compute Engine, and Cloud Functions.

## Cloud Run Deployment

Cloud Run is the easiest way to deploy VibeKit Proxy on GCP with automatic scaling and serverless pricing.

### Using gcloud CLI

```bash
# Build and deploy in one command
gcloud run deploy vibekit-proxy \
  --source . \
  --region us-central1 \
  --platform managed \
  --port 8080 \
  --memory 512Mi \
  --cpu 1 \
  --min-instances 0 \
  --max-instances 10 \
  --allow-unauthenticated \
  --set-env-vars NODE_ENV=production
```

### Using Cloud Build

**cloudbuild.yaml:**
```yaml
steps:
  # Build the container image
  - name: 'gcr.io/cloud-builders/docker'
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/vibekit-proxy:$BUILD_ID', '.']
  
  # Push the container image to Container Registry
  - name: 'gcr.io/cloud-builders/docker'
    args: ['push', 'gcr.io/$PROJECT_ID/vibekit-proxy:$BUILD_ID']
  
  # Deploy to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - 'vibekit-proxy'
      - '--image'
      - 'gcr.io/$PROJECT_ID/vibekit-proxy:$BUILD_ID'
      - '--region'
      - 'us-central1'
      - '--platform'
      - 'managed'
      - '--port'
      - '8080'
      - '--memory'
      - '512Mi'
      - '--cpu'
      - '1'
      - '--min-instances'
      - '1'
      - '--max-instances'
      - '100'
      - '--allow-unauthenticated'
      - '--set-env-vars'
      - 'NODE_ENV=production'

images:
  - 'gcr.io/$PROJECT_ID/vibekit-proxy:$BUILD_ID'

options:
  logging: CLOUD_LOGGING_ONLY
```

### Terraform Configuration

```hcl
resource "google_cloud_run_service" "vibekit_proxy" {
  name     = "vibekit-proxy"
  location = "us-central1"

  template {
    spec {
      containers {
        image = "gcr.io/${var.project_id}/vibekit-proxy:latest"
        
        ports {
          container_port = 8080
        }

        resources {
          limits = {
            cpu    = "1"
            memory = "512Mi"
          }
        }

        env {
          name  = "NODE_ENV"
          value = "production"
        }

        env {
          name  = "PORT"
          value = "8080"
        }

        liveness_probe {
          http_get {
            path = "/health"
            port = 8080
          }
          initial_delay_seconds = 30
          timeout_seconds       = 5
          period_seconds        = 10
          failure_threshold     = 3
        }
      }

      container_concurrency = 80
      timeout_seconds      = 300
    }

    metadata {
      annotations = {
        "autoscaling.knative.dev/minScale" = "1"
        "autoscaling.knative.dev/maxScale" = "100"
        "run.googleapis.com/cpu-throttling" = "false"
      }
    }
  }

  traffic {
    percent         = 100
    latest_revision = true
  }

  autogenerate_revision_name = true
}

resource "google_cloud_run_service_iam_binding" "public" {
  location = google_cloud_run_service.vibekit_proxy.location
  service  = google_cloud_run_service.vibekit_proxy.name
  role     = "roles/run.invoker"
  members  = ["allUsers"]
}

output "service_url" {
  value = google_cloud_run_service.vibekit_proxy.status[0].url
}
```

## Google Kubernetes Engine (GKE)

### Cluster Setup

```bash
# Create GKE cluster
gcloud container clusters create vibekit-proxy-cluster \
  --zone us-central1-a \
  --machine-type e2-medium \
  --num-nodes 3 \
  --enable-autoscaling \
  --min-nodes 1 \
  --max-nodes 10 \
  --enable-network-policy \
  --enable-ip-alias

# Get cluster credentials
gcloud container clusters get-credentials vibekit-proxy-cluster --zone us-central1-a
```

### Kubernetes Manifests

**namespace.yaml:**
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: vibekit-proxy
```

**deployment.yaml:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vibekit-proxy
  namespace: vibekit-proxy
  labels:
    app: vibekit-proxy
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: vibekit-proxy
  template:
    metadata:
      labels:
        app: vibekit-proxy
        version: v1
    spec:
      containers:
      - name: vibekit-proxy
        image: gcr.io/PROJECT_ID/vibekit-proxy:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
          name: http
        env:
        - name: NODE_ENV
          value: "production"
        - name: PORT
          value: "8080"
        - name: GOOGLE_CLOUD_PROJECT
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: project-id
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        securityContext:
          allowPrivilegeEscalation: false
          runAsNonRoot: true
          runAsUser: 1000
          capabilities:
            drop:
            - ALL
      securityContext:
        fsGroup: 1000
```

**service.yaml:**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: vibekit-proxy-service
  namespace: vibekit-proxy
  annotations:
    cloud.google.com/backend-config: '{"default": "vibekit-proxy-backendconfig"}'
spec:
  type: ClusterIP
  selector:
    app: vibekit-proxy
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
    name: http
```

**ingress.yaml:**
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: vibekit-proxy-ingress
  namespace: vibekit-proxy
  annotations:
    kubernetes.io/ingress.class: "gce"
    kubernetes.io/ingress.global-static-ip-name: "vibekit-proxy-ip"
    networking.gke.io/managed-certificates: "vibekit-proxy-ssl-cert"
spec:
  rules:
  - host: proxy.yourdomain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: vibekit-proxy-service
            port:
              number: 80
```

**hpa.yaml:**
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: vibekit-proxy-hpa
  namespace: vibekit-proxy
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: vibekit-proxy
  minReplicas: 2
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
```

## Compute Engine Deployment

### Instance Template

```bash
# Create instance template
gcloud compute instance-templates create vibekit-proxy-template \
  --machine-type=e2-medium \
  --image-family=ubuntu-2004-lts \
  --image-project=ubuntu-os-cloud \
  --boot-disk-size=20GB \
  --boot-disk-type=pd-standard \
  --tags=http-server,https-server \
  --metadata-from-file startup-script=startup-script.sh
```

**startup-script.sh:**
```bash
#!/bin/bash

# Update system
apt-get update
apt-get install -y curl software-properties-common

# Install Node.js 18
curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
apt-get install -y nodejs

# Install VibeKit Proxy
npm install -g @vibe-kit/proxy

# Create systemd service
cat > /etc/systemd/system/vibekit-proxy.service << EOF
[Unit]
Description=VibeKit Proxy Service
After=network.target

[Service]
Type=simple
User=www-data
Group=www-data
WorkingDirectory=/var/www
ExecStart=/usr/bin/npx @vibe-kit/proxy start --port 8080
Restart=always
RestartSec=10
Environment=NODE_ENV=production
Environment=PORT=8080

# Security settings
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/www

[Install]
WantedBy=multi-user.target
EOF

# Create working directory
mkdir -p /var/www
chown www-data:www-data /var/www

# Enable and start service
systemctl daemon-reload
systemctl enable vibekit-proxy
systemctl start vibekit-proxy

# Install monitoring agent
curl -sSO https://dl.google.com/cloudagents/add-monitoring-agent-repo.sh
bash add-monitoring-agent-repo.sh
apt-get update
apt-get install -y stackdriver-agent
systemctl enable stackdriver-agent
systemctl start stackdriver-agent
```

### Managed Instance Group

```bash
# Create managed instance group
gcloud compute instance-groups managed create vibekit-proxy-mig \
  --template=vibekit-proxy-template \
  --size=3 \
  --zone=us-central1-a

# Configure autoscaling
gcloud compute instance-groups managed set-autoscaling vibekit-proxy-mig \
  --zone=us-central1-a \
  --max-num-replicas=10 \
  --min-num-replicas=2 \
  --target-cpu-utilization=0.7
```

### Load Balancer

```bash
# Create health check
gcloud compute health-checks create http vibekit-proxy-health-check \
  --port=8080 \
  --request-path=/health \
  --check-interval=30s \
  --timeout=10s \
  --healthy-threshold=2 \
  --unhealthy-threshold=3

# Create backend service
gcloud compute backend-services create vibekit-proxy-backend \
  --protocol=HTTP \
  --port-name=http \
  --health-checks=vibekit-proxy-health-check \
  --global

# Add instance group to backend service
gcloud compute backend-services add-backend vibekit-proxy-backend \
  --instance-group=vibekit-proxy-mig \
  --instance-group-zone=us-central1-a \
  --global

# Create URL map
gcloud compute url-maps create vibekit-proxy-map \
  --default-service=vibekit-proxy-backend

# Create HTTP(S) proxy
gcloud compute target-http-proxies create vibekit-proxy-http-proxy \
  --url-map=vibekit-proxy-map

# Create forwarding rule
gcloud compute forwarding-rules create vibekit-proxy-forwarding-rule \
  --global \
  --target-http-proxy=vibekit-proxy-http-proxy \
  --ports=80
```

## Cloud Functions Deployment

### Function Code

**index.js:**
```javascript
const functions = require('@google-cloud/functions-framework');
const ProxyServer = require('@vibe-kit/proxy/src/server.js').default;

// Initialize proxy server
const proxy = new ProxyServer(8080);

functions.http('vibekit-proxy', async (req, res) => {
  try {
    await proxy.handleHttpRequest(req, res);
  } catch (error) {
    console.error('Proxy error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

**package.json:**
```json
{
  "name": "vibekit-proxy-function",
  "version": "1.0.0",
  "main": "index.js",
  "dependencies": {
    "@google-cloud/functions-framework": "^3.0.0",
    "@vibe-kit/proxy": "latest"
  },
  "engines": {
    "node": "18"
  }
}
```

### Deploy Function

```bash
# Deploy function
gcloud functions deploy vibekit-proxy \
  --runtime=nodejs18 \
  --trigger=http \
  --allow-unauthenticated \
  --memory=512MB \
  --timeout=60s \
  --max-instances=100 \
  --region=us-central1 \
  --set-env-vars=NODE_ENV=production
```

## Security Configuration

### IAM and Service Accounts

```bash
# Create service account
gcloud iam service-accounts create vibekit-proxy-sa \
  --description="Service account for VibeKit Proxy" \
  --display-name="VibeKit Proxy SA"

# Grant necessary permissions
gcloud projects add-iam-policy-binding PROJECT_ID \
  --member="serviceAccount:vibekit-proxy-sa@PROJECT_ID.iam.gserviceaccount.com" \
  --role="roles/logging.logWriter"

gcloud projects add-iam-policy-binding PROJECT_ID \
  --member="serviceAccount:vibekit-proxy-sa@PROJECT_ID.iam.gserviceaccount.com" \
  --role="roles/monitoring.metricWriter"
```

### Firewall Rules

```bash
# Create firewall rules
gcloud compute firewall-rules create vibekit-proxy-allow-http \
  --allow tcp:8080 \
  --source-ranges 0.0.0.0/0 \
  --target-tags http-server \
  --description "Allow HTTP traffic to VibeKit Proxy"

# For internal traffic only
gcloud compute firewall-rules create vibekit-proxy-allow-internal \
  --allow tcp:8080 \
  --source-ranges 10.0.0.0/8 \
  --target-tags vibekit-proxy-internal \
  --description "Allow internal HTTP traffic to VibeKit Proxy"
```

## Monitoring and Logging

### Cloud Monitoring

```yaml
# monitoring.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: monitoring-config
  namespace: vibekit-proxy
data:
  config.yaml: |
    global:
      scrape_interval: 15s
    scrape_configs:
    - job_name: 'vibekit-proxy'
      static_configs:
      - targets: ['vibekit-proxy-service:80']
      metrics_path: /metrics
      scrape_interval: 30s
```

### Log-based Metrics

```bash
# Create log-based metric for request count
gcloud logging metrics create vibekit_proxy_requests \
  --description="Number of requests to VibeKit Proxy" \
  --log-filter='resource.type="cloud_run_revision" AND resource.labels.service_name="vibekit-proxy"' \
  --value-extractor='EXTRACT(httpRequest.requestUrl)'

# Create alerting policy
gcloud alpha monitoring policies create \
  --policy-from-file=alerting-policy.yaml
```

**alerting-policy.yaml:**
```yaml
displayName: "VibeKit Proxy High Error Rate"
conditions:
  - displayName: "Error rate > 5%"
    conditionThreshold:
      filter: 'resource.type="cloud_run_revision" resource.label.service_name="vibekit-proxy"'
      comparison: COMPARISON_GREATER_THAN
      thresholdValue: 0.05
      duration: 300s
      aggregations:
        - alignmentPeriod: 60s
          perSeriesAligner: ALIGN_RATE
          crossSeriesReducer: REDUCE_MEAN
```

## Cost Optimization

### Recommendations

1. **Use Cloud Run** for variable workloads (pay-per-request)
2. **Preemptible instances** for Compute Engine (up to 80% savings)
3. **Sustained use discounts** for consistent workloads
4. **Committed use contracts** for predictable usage
5. **Regional persistent disks** instead of zonal for better cost/performance

### Budget Alerts

```bash
# Create budget
gcloud billing budgets create \
  --billing-account=BILLING_ACCOUNT_ID \
  --display-name="VibeKit Proxy Budget" \
  --budget-amount=100USD \
  --threshold-rule=percent=0.8,basis=CURRENT_SPEND \
  --threshold-rule=percent=1.0,basis=CURRENT_SPEND \
  --filter-projects=PROJECT_ID
```

## Troubleshooting

### Common Issues

1. **Cold starts**: Use minimum instances in Cloud Run
2. **Memory limits**: Monitor memory usage and adjust limits
3. **Network connectivity**: Check VPC and firewall rules
4. **Permission denied**: Verify IAM roles and service accounts

### Debugging Commands

```bash
# Cloud Run logs
gcloud logs read "resource.type=cloud_run_revision AND resource.labels.service_name=vibekit-proxy" --limit=50

# GKE pod logs
kubectl logs -f deployment/vibekit-proxy -n vibekit-proxy

# Compute Engine logs
gcloud compute instances get-serial-port-output INSTANCE_NAME --zone=ZONE

# Health check status
gcloud compute backend-services get-health vibekit-proxy-backend --global
```

## What's Next?

- Configure [AWS deployment](/proxy/aws-deployment)
- Set up [monitoring and observability](/proxy/observability)
- Learn about [custom redaction rules](/proxy/redaction)
- Explore [performance optimization](/proxy/performance)


================================================
FILE: docs/proxy/gemini-cli.mdx
================================================
---
title: Gemini CLI
description: "Integrate VibeKit Proxy with Gemini CLI for secure AI-powered development"
---

## Overview

VibeKit Proxy seamlessly integrates with Gemini CLI, Google's command-line interface for AI-powered development, providing automatic data redaction and security for your AI-powered development workflow without changing your existing code patterns.

<Warning>
Make sure you have the VibeKit Proxy server installed and running before using this integration. See the [Quickstart guide](/proxy/quickstart) for installation instructions.
</Warning>

## Prerequisites

Ensure you have Gemini CLI installed:

```bash
# Install Gemini CLI (if not already installed)
npm install -g @google/gemini-cli
```

## Configuration

Configure Gemini CLI to route through VibeKit Proxy using the GOOGLE_GEMINI_BASE_URL environment variable:

### Basic Proxy Configuration

```bash
# Set proxy environment variables
export GOOGLE_GEMINI_BASE_URL=http://localhost:8080

# Run Gemini CLI as normal
gemini "Create a React component for user authentication"
```

### Environment Variable Configuration

Create a `.env` file or set environment variables:

```bash
# Basic proxy setup
GOOGLE_GEMINI_BASE_URL=http://localhost:8080
```

### Persistent Configuration

You can also configure proxy settings in your shell profile for persistent use:

```bash
# Add to ~/.bashrc, ~/.zshrc, or ~/.bash_profile
export GOOGLE_GEMINI_BASE_URL=http://localhost:8080
export GEMINI_API_KEY=your_api_key_here
```


================================================
FILE: docs/proxy/index.mdx
================================================
---
title: VibeKit Proxy
description: "The runtime firewall for AI. Blocks OWASP LLM vulnerabilities in real time (prompt injection, data leaks, insecure outputs). Tiny, fast model â€” <50ms latency overhead built into the proxy. Drop-in middleware, simple, universal, compliance-ready."
---

## Features

<CardGroup cols={2}>
  <Card title="Real-Time Data Redaction" icon="shield-check" color="#888">
    Automatically detects and masks sensitive data on both input and output.
  </Card>
  <Card title="Prompt Injection Defense" icon="shield" color="#888">
    Blocks malicious instructions, jailbreaks, and exploits from compromising your AI.
  </Card>
  <Card title="Zero Latency" icon="bolt" color="#888">
    In-memory filtering provides security without any performance impact.
  </Card>
  <Card title="AI Threat Intelligence" icon="brain" color="#888">
    Learns from attack patterns to protect against new threats automatically.
  </Card>
  <Card title="Compliance-Ready" icon="check" color="#888">
    Meets GDPR, HIPAA, PCI, and SOC 2 requirements out of the box.
  </Card>
  <Card title="Observability" icon="chart-line" color="#888">
    Real-time logs, traces, and metrics provide complete visibility into operations.
  </Card>
</CardGroup>

## Getting Started

<CardGroup cols={2}>
  <Card
    title="Quickstart"
    icon="rocket"
    href="/proxy/quickstart"
    color="#888"
  >
    Get up and running with VibeKit Proxy in under 5 minutes
  </Card>
  <Card
    title="Deployment"
    icon="cloud"
    href="/proxy/deployment"
    color="#888"
  >
    Deploy to production on AWS, GCP, and other platforms
  </Card>
</CardGroup>

## Why Use VibeKit Proxy?

Instead of running coding agents directly on your machine, VibeKit provides crucial safety and visibility:

- **Zero Risk**: Isolated Docker containers prevent any damage to your local environment
- **Security First**: Built-in redaction removes sensitive data from agent completions automatically  
- **Full Visibility**: Complete observability into what your coding agents are actually doing
- **Works Offline**: No cloud dependencies or internet required â€” works entirely on your machine

Whether you're using Claude Code for development, integrating AI agents into your workflow, or building applications that need secure code execution, VibeKit CLI provides the safety foundation you need to use coding agents with confidence.


================================================
FILE: docs/proxy/litellm.mdx
================================================
---
title: LiteLLM
description: "Integrate VibeKit Proxy with LiteLLM for unified access to 100+ LLM providers"
---

## Overview

VibeKit Proxy seamlessly integrates with LiteLLM, a unified interface for calling 100+ LLM APIs in OpenAI format. This integration allows you to route requests through VibeKit Proxy to a LiteLLM instance for enhanced model management and provider abstraction.

<Warning>
Make sure you have the VibeKit Proxy server installed and running before using this integration. See the [Quickstart guide](/proxy/quickstart) for installation instructions.
</Warning>

## Prerequisites

Ensure you have LiteLLM installed and running:

```bash
# Install LiteLLM
pip install litellm[proxy]

# Start LiteLLM proxy
litellm --port 4000
```

## VibeKit Proxy Configuration

Configure VibeKit Proxy to forward requests to your LiteLLM instance:

### Basic LiteLLM Integration

```yaml
# vibekit.yaml
models:
  # Forward all OpenAI-compatible requests to LiteLLM
  - model_name: "gpt-5"
    provider: "openai"
    api_base: "http://localhost:4000"
  
  - model_name: "claude-4-sonnet"
    provider: "openai"  # LiteLLM uses OpenAI-compatible format
    api_base: "http://localhost:4000"
  
  - model_name: "gemini-2.0-flash"
    provider: "openai"  # LiteLLM uses OpenAI-compatible format
    api_base: "http://localhost:4000"
```

### Production LiteLLM Integration

```yaml
# vibekit.yaml
models:
  # Production LiteLLM instance
  - model_name: "gpt-5"
    provider: "openai"
    api_base: "https://your-litellm-proxy.com"

  - model_name: "claude-4-sonnet"
    provider: "openai"
    api_base: "https://your-litellm-proxy.com"
  
  - model_name: "gemini-2.0-flash"
    provider: "openai"
    api_base: "https://your-litellm-proxy.com"
```


================================================
FILE: docs/proxy/openai-codex.mdx
================================================
---
title: OpenAI Codex
description: "Integrate VibeKit Proxy with OpenAI Codex for secure AI-powered development"
---

## Overview

VibeKit Proxy seamlessly integrates with OpenAI Codex, OpenAI's official CLI tool, providing automatic data redaction and security for your AI-powered development workflow without changing your existing code patterns.

<Warning>
Make sure you have the VibeKit Proxy server installed and running before using this integration. See the [Quickstart guide](/proxy/quickstart) for installation instructions.
</Warning>

## Prerequisites

Ensure you have OpenAI Codex installed:

```bash
# Install OpenAI Codex (if not already installed)
npm install -g @openai/codex
```

## Configuration

Configure OpenAI Codex to route through VibeKit Proxy using environment variables:

### Basic Proxy Configuration

```bash
# Set proxy environment variables
export OPENAI_BASE_URL=http://localhost:8080

# Run OpenAI Codex as normal
codex "Create a React component for user authentication"
```

### Environment Variable Configuration

Create a `.env` file or set environment variables:

```bash
# Basic proxy setup
OPENAI_BASE_URL=http://localhost:8080
```

### Config File Configuration

You can also configure proxy settings in OpenAI Codex's config file:

```json
{
  "env": {
    "OPENAI_BASE_URL": "http://localhost:8080"
  }
}
```


================================================
FILE: docs/proxy/openai-sdk.mdx
================================================
---
title: OpenAI SDK
description: "Integrate VibeKit Proxy with OpenAI SDK for Python and JavaScript/TypeScript"
---

## Overview

VibeKit Proxy seamlessly integrates with the OpenAI SDK, providing automatic data redaction and security for your OpenAI applications without changing your existing code.

<Warning>
Make sure you have the VibeKit Proxy server installed and running before using this integration. See the [Quickstart guide](/proxy/quickstart) for installation instructions.
</Warning>

## Integration

Simply add the VibeKit Proxy URL to your existing OpenAI SDK configuration:

### Chat Completions

<CodeGroup>

```python Python
from openai import OpenAI

client = OpenAI(
    base_url="http://localhost:8080/v1"  # Add this line
)

response = client.chat.completions.create(
    model="gpt-4",
    messages=[
        {"role": "user", "content": "My SSN is 123-45-6789. Help me with privacy."}
    ]
)
```

```typescript TypeScript
import OpenAI from 'openai';

const openai = new OpenAI({
  baseURL: 'http://localhost:8080/v1'  // Add this line
});

const response = await openai.chat.completions.create({
  model: 'gpt-4',
  messages: [
    { role: 'user', content: 'My email is john@company.com and phone is 555-0123.' }
  ]
});
```

</CodeGroup>

## Environment Configuration

<CodeGroup>

```python Python
import os
from openai import OpenAI

proxy_url = os.getenv("VIBEKIT_PROXY_URL", "http://localhost:8080/v1")

client = OpenAI(
    base_url=proxy_url  # Use environment variable
)
```

```typescript TypeScript
import OpenAI from 'openai';

const proxyUrl = process.env.VIBEKIT_PROXY_URL || 'http://localhost:8080/v1';

const openai = new OpenAI({
  baseURL: proxyUrl  // Use environment variable
});
```

```bash Environment Variables
# Development
VIBEKIT_PROXY_URL=http://localhost:8080/v1

# Production  
VIBEKIT_PROXY_URL=https://your-proxy-domain.com/v1
```

</CodeGroup>



================================================
FILE: docs/proxy/other-frameworks.mdx
================================================
---
title: Other Frameworks
description: "Integrate VibeKit Proxy with popular AI frameworks and libraries"
---

## Overview

VibeKit Proxy works with any framework or library that makes HTTP requests to AI providers. Simply configure the proxy URL in your existing setup.

<Warning>
Make sure you have the VibeKit Proxy server installed and running before using this integration. See the [Quickstart guide](/proxy/quickstart) for installation instructions.
</Warning>

## LangChain

<CodeGroup>

```python Python
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic

# OpenAI models
openai_llm = ChatOpenAI(
    model="gpt-4",
    base_url="http://localhost:8080/v1"  # Add this line
)

# Anthropic models
anthropic_llm = ChatAnthropic(
    model="claude-3-5-sonnet-20241022",
    base_url="http://localhost:8080"  # Add this line
)
```

```typescript TypeScript
import { ChatOpenAI } from "@langchain/openai";
import { ChatAnthropic } from "@langchain/anthropic";

// OpenAI models
const openaiLlm = new ChatOpenAI({
  model: "gpt-4",
  configuration: {
    baseURL: "http://localhost:8080/v1"  // Add this line
  }
});

// Anthropic models  
const anthropicLlm = new ChatAnthropic({
  model: "claude-3-5-sonnet-20241022",
  clientOptions: {
    baseURL: "http://localhost:8080"  // Add this line
  }
});
```

</CodeGroup>

## LlamaIndex

<CodeGroup>

```python Python
from llama_index.llms.openai import OpenAI
from llama_index.llms.anthropic import Anthropic

# OpenAI models
openai_llm = OpenAI(
    model="gpt-4",
    api_base="http://localhost:8080/v1"  # Add this line
)

# Anthropic models
anthropic_llm = Anthropic(
    model="claude-3-5-sonnet-20241022",
    api_base="http://localhost:8080"  # Add this line
)
```

```typescript TypeScript
import { OpenAI } from "llamaindex";

const llm = new OpenAI({
  model: "gpt-4",
  additionalChatOptions: {
    baseURL: "http://localhost:8080/v1"  // Add this line
  }
});
```

</CodeGroup>

## Haystack

```python Python
from haystack.components.generators import OpenAIGenerator
from haystack.utils import Secret

generator = OpenAIGenerator(
    model="gpt-4",
    api_key=Secret.from_token("your-api-key"),
    api_base_url="http://localhost:8080/v1"  # Add this line
)
```

## CrewAI

```python Python
from crewai import Agent, LLM

# OpenAI models
openai_llm = LLM(
    model="openai/gpt-4",
    base_url="http://localhost:8080/v1"  # Add this line
)

# Anthropic models
anthropic_llm = LLM(
    model="anthropic/claude-3-5-sonnet-20241022", 
    base_url="http://localhost:8080"  # Add this line
)

agent = Agent(
    role="Customer Service Agent",
    goal="Help customers securely",
    llm=openai_llm
)
```

## AutoGen

```python Python
from autogen import ConversableAgent

# OpenAI configuration
openai_config = {
    "model": "gpt-4",
    "api_key": "your-api-key",
    "base_url": "http://localhost:8080/v1"  # Add this line
}

agent = ConversableAgent(
    name="assistant",
    llm_config={"config_list": [openai_config]}
)
```

## Guidance

```python Python
import guidance

# Configure OpenAI with proxy
guidance.llm = guidance.llms.OpenAI(
    model="gpt-4",
    api_base="http://localhost:8080/v1"  # Add this line
)
```

## Instructor

<CodeGroup>

```python Python
import instructor
from openai import OpenAI

# Patch OpenAI client with proxy
client = instructor.from_openai(
    OpenAI(base_url="http://localhost:8080/v1")  # Add this line
)
```

```typescript TypeScript
import Instructor from "@instructor-ai/instructor";
import OpenAI from "openai";

const oai = new OpenAI({
  baseURL: "http://localhost:8080/v1"  // Add this line
});

const client = Instructor({ client: oai, mode: "FUNCTIONS" });
```

</CodeGroup>

## LiteLLM

```python Python
import litellm

# Set proxy URL for all LiteLLM calls
litellm.api_base = "http://localhost:8080"

# Use with any supported provider
response = litellm.completion(
    model="gpt-4",
    messages=[{"role": "user", "content": "Hello"}]
)
```

## Generic HTTP Clients

For any framework that uses HTTP clients directly:

<CodeGroup>

```python Python
import requests

# Direct HTTP requests to proxy
response = requests.post(
    "http://localhost:8080/v1/chat/completions",  # Use proxy URL
    headers={
        "Authorization": "Bearer your-api-key",
        "Content-Type": "application/json"
    },
    json={
        "model": "gpt-4",
        "messages": [{"role": "user", "content": "Hello"}]
    }
)
```

```typescript TypeScript
// Direct fetch requests to proxy
const response = await fetch("http://localhost:8080/v1/chat/completions", {
  method: "POST",
  headers: {
    "Authorization": "Bearer your-api-key",
    "Content-Type": "application/json"
  },
  body: JSON.stringify({
    model: "gpt-4",
    messages: [{ role: "user", content: "Hello" }]
  })
});
```

```bash cURL
# Direct cURL requests to proxy
curl -X POST http://localhost:8080/v1/chat/completions \
  -H "Authorization: Bearer your-api-key" \
  -H "Content-Type: application/json" \
  -d '{
    "model": "gpt-4",
    "messages": [{"role": "user", "content": "Hello"}]
  }'
```

</CodeGroup>

## Environment Configuration

Set up proxy URLs for any framework using environment variables:

```bash Environment Variables
# Development
VIBEKIT_PROXY_URL=http://localhost:8080
OPENAI_BASE_URL=http://localhost:8080/v1
ANTHROPIC_BASE_URL=http://localhost:8080

# Production  
VIBEKIT_PROXY_URL=https://your-proxy-domain.com
OPENAI_BASE_URL=https://your-proxy-domain.com/v1
ANTHROPIC_BASE_URL=https://your-proxy-domain.com
```

## Integration Pattern

Most AI frameworks follow this pattern:

1. **Find the configuration option** for base URL, API base, or endpoint
2. **Replace the default URL** with your VibeKit Proxy URL
3. **Keep everything else the same** - API keys, models, parameters

Common configuration parameter names:
- `base_url`, `baseURL`, `base_URL`
- `api_base`, `api_base_url`, `apiBase`
- `endpoint`, `host`, `url`



================================================
FILE: docs/proxy/quickstart.mdx
================================================
---
title: Quickstart
description: "Get started with VibeKit Proxy in under 5 minutes"
---

## Installation

<CodeGroup>

```bash Node.js
npm install -g vibekit-proxy
vibekit-proxy start
```

```bash Rust
cargo install vibekit-proxy
vibekit-proxy start
```

</CodeGroup>

The proxy is now running at `http://localhost:8080` and ready to intercept AI requests.

## Configuration

### Config File Location

By default, both implementations look for `vibekit.yaml` in the current working directory. You can specify a custom config file path using the `--config` parameter:

<CodeGroup>

```bash Node.js
npm start -- --config=/etc/vibekit/vibekit.yaml
```

```bash Rust
./target/release/vibekit-proxy start --config=/etc/vibekit/vibekit.yaml
```

</CodeGroup>

### Config File Format

Edit `vibekit.yaml` to add models and API endpoints:

```yaml
models:
  - model_name: "gpt-5"
    provider: "openai"
    api_base: "https://api.openai.com"
  
  - model_name: "claude-4-sonnet"
    provider: "anthropic"
    api_base: "https://api.anthropic.com"
```

### Additional Commands

```bash
# Check proxy status
vibekit-proxy status

# Stop the proxy server
vibekit-proxy stop
```

## Update Your Application

Simply change your base URL to point to the VibeKit proxy:

### Before
```javascript
const client = new OpenAI({
  baseURL: 'https://api.openai.com',
  apiKey: process.env.OPENAI_API_KEY,
});
```

### After
```javascript
const client = new OpenAI({
  baseURL: 'http://localhost:8080',
  apiKey: process.env.OPENAI_API_KEY,
});
```

## Test Your Setup

Make a test request to verify everything is working using one of the configured models:

<CodeGroup>

```bash Anthropic (curl)
curl -X POST http://localhost:8080/messages \
  -H "Content-Type: application/json" \
  -H "x-api-key: your-api-key" \
  -d '{
    "model": "claude-4-sonnet",
    "messages": [
      {
        "role": "user",
        "content": "Hello! Can you help me with a quick test?"
      }
    ]
  }'
```

```bash OpenAI (curl)
curl -X POST http://localhost:8080/v1/chat/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your-api-key" \
  -d '{
    "model": "gpt-5",
    "messages": [
      {
        "role": "user",
        "content": "Hello! Can you help me with a quick test?"
      }
    ]
  }'
```

```javascript JavaScript
const response = await client.chat.completions.create({
  model: "gpt-5", // Use configured model
  messages: [
    { role: "user", content: "My SSN is 123-45-6789. What can you tell me about privacy?" }
  ],
});

console.log(response.choices[0].message.content);
// The SSN will be automatically redacted in both the request and response
```

</CodeGroup>

Health check:
```bash
curl http://localhost:8080/health
```

## Configuration Options

You can customize the proxy with these options:

```bash
# Start with custom port
npx @vibe-kit/proxy start --port 3000

# Run in background (daemon mode)
npx @vibe-kit/proxy start --daemon

# Check status on specific port
npx @vibe-kit/proxy status --port 3000

# Stop proxy on specific port
npx @vibe-kit/proxy stop --port 3000
```


================================================
FILE: docs/proxy/vercel-ai-sdk.mdx
================================================
---
title: Vercel AI SDK
description: "Integrate VibeKit Proxy with Vercel AI SDK for secure AI applications"
---

## Overview

VibeKit Proxy seamlessly integrates with the Vercel AI SDK, providing automatic data redaction and security for your AI-powered applications without changing your existing code.

<Warning>
Make sure you have the VibeKit Proxy server installed and running before using this integration. See the [Quickstart guide](/proxy/quickstart) for installation instructions.
</Warning>

## Installation

Install the Vercel AI SDK:

```bash
npm install ai
```

## Configuration

Update your AI provider configuration to use the VibeKit proxy:

### OpenAI Integration

**Before:**
```javascript
import { openai } from '@ai-sdk/openai';

const model = openai('gpt-4');
```

**After:**
```javascript
import { openai } from '@ai-sdk/openai';

const model = openai('gpt-4', {
  baseURL: 'http://localhost:8080/v1'
});
```

### Anthropic Integration

**Before:**
```javascript
import { anthropic } from '@ai-sdk/anthropic';

const model = anthropic('claude-3-sonnet-20240229');
```

**After:**
```javascript
import { anthropic } from '@ai-sdk/anthropic';

const model = anthropic('claude-3-sonnet-20240229', {
  baseURL: 'http://localhost:8080'
});
```

## Usage Examples

### Chat Completion with Automatic Redaction

```javascript
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';

const model = openai('gpt-4', {
  baseURL: 'http://localhost:8080/v1'
});

const result = await generateText({
  model,
  prompt: 'My email is john@example.com and my SSN is 123-45-6789. Help me with privacy best practices.',
});

console.log(result.text);
// Sensitive data will be automatically redacted in both request and response
```

### Streaming with Security

```javascript
import { streamText } from 'ai';
import { anthropic } from '@ai-sdk/anthropic';

const model = anthropic('claude-3-sonnet-20240229', {
  baseURL: 'http://localhost:8080'
});

const result = await streamText({
  model,
  prompt: 'Analyze this customer data: Name: John Doe, Phone: (555) 123-4567, Account: 1234567890',
});

for await (const textPart of result.textStream) {
  process.stdout.write(textPart);
  // All streaming content is automatically redacted
}
```


================================================
FILE: docs/sdk/ask-mode.mdx
================================================
---
title: 'Ask Mode'
description: 'Ask mode allows you to run RAG over codebase and disables changes to the file system.'
---

VibeKit ships with an `ask` mode that allows you to ask questions to the agent without changing any files in the file system. This is useful for quick questions and answers or building powerful RAG applications.

```typescript
const result = await vibeKit.generateCode({
  prompt: "Describe the codebase in detail",
  mode: "ask",
})

console.log(result);
``` 


================================================
FILE: docs/sdk/github-integration.mdx
================================================
---
title: 'GitHub Integration'
description: 'Create branches, open pull requests, and more.'
---

VibeKit integrates with GitHub to allow you to create branches, open pull requests, and more. This is particularly powerful for conversational UIs where users can iteratively request changes and see them reflected in real-time through GitHub.

## Setup

First, configure your VibeKit instance with GitHub credentials:

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createE2BProvider } from "@vibe-kit/e2b";

const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY!,
  templateId: "vibekit-claude",
});

const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(e2bProvider)
  .withGitHub({
    token: process.env.GITHUB_TOKEN!, // GitHub Personal Access Token
    repository: "your-org/your-repo", // Repository in format "owner/repo"
  });
```

<Tip>
Your GitHub token needs the following permissions:
- `repo` (Full control of private repositories)
- `workflow` (Update GitHub Action workflows)
</Tip>

## Creating a PR

### The basic way

The simplest way to create a pull request is to generate code and then create a PR:

```typescript
// Add event listeners
vibeKit.on("update", (update) => {
  console.log("Update:", update);
});

vibeKit.on("error", (error) => {
  console.error("Error:", error);
});

// Generate initial code
const response = await vibeKit.generateCode({
  prompt: "Create a React component for user authentication with email and password fields",
  mode: "code",
});

// Create pull request with the generated changes
const pullRequest = await vibeKit.createPullRequest();

console.log("Pull Request created!");
console.log(`URL: ${pullRequest.html_url}`);
console.log(`PR Number: ${pullRequest.number}`);
console.log(`Branch: ${pullRequest.branchName}`);
console.log(`Commit SHA: ${pullRequest.commitSha}`);
```

## Iterative changes with pushToBranch

For conversational UIs, users often want to make multiple iterations on the same feature. Use `pushToBranch` to continuously update the same branch without creating multiple pull requests:

```typescript
const result = await vibeKit.generateCode({
  prompt: "Add validation to the login form",
  mode: "code",
  branch: pullRequest.branchName, // or an existing branch
});

await vibeKit.pushToBranch();

```

This comprehensive GitHub integration allows you to build powerful conversational UIs where users can iteratively request code changes, see them applied in real-time, and create pull requests when they're satisfied with the results.


================================================
FILE: docs/sdk/index.mdx
================================================
---
title: Introduction
description: "The VibeKit SDK makes it easy to embed powerful AI coding agents into your web applications. With support for multiple AI providers and secure sandboxed execution, you can add intelligent code generation, editing, and execution capabilities to any application."
---

## Key Features

<CardGroup cols={2}>
  <Card title="Multiple AI Agents" icon="bot" color="#888">
    Integrate Claude Code, Codex, Gemini, Grok, and OpenCode agents into your applications
  </Card>
  <Card title="Sandboxed Environments" icon="container" color="#888">
    Secure, isolated environments for safe code execution and development
  </Card>
  <Card title="Flexible Integration" icon="git-branch" color="#888">
    SDK for embedding in apps, CLI for development, and API for custom workflows
  </Card>
  <Card title="Provider Choice" icon="plug" color="#888">
    Deploy with E2B, Dagger, Daytona, Northflank, Cloudflare, Modal, or Fly.io
  </Card>
</CardGroup>

## Getting Started

<CardGroup cols={2}>
  <Card
    title="SDK Installation"
    icon="download"
    href="/sdk/quickstart"
    color="#888"
  >
    Install and configure the VibeKit SDK
  </Card>
  <Card
    title="SDK Examples"
    icon="code"
    href="https://github.com/superagent-ai/vibekit/tree/main/templates"
    color="#888"
  >
    Example integrations and code samples
  </Card>
</CardGroup>

## Why Use the VibeKit SDK?

Modern applications increasingly need AI-powered coding capabilities. The VibeKit SDK makes it simple to add these features without the complexity of managing sandboxed environments, AI model integrations, or security considerations.

Whether you're building a code editor, documentation platform, educational tool, or any application that could benefit from intelligent code generation and execution, the VibeKit SDK provides a secure, scalable foundation that grows with your needs.



================================================
FILE: docs/sdk/quickstart.mdx
================================================
---
title: 'Quickstart'
description: 'Below is an example on how to get started with VibeKit'
---
Follow these steps to install and run Vibekit:


## Basic setup

**Step 1**: Install VibeKit Typescript SDK:

<CodeGroup>

  ```bash npm
  npm i @vibe-kit/sdk
  ```

```bash yarn
yarn add @vibe-kit/sdk
```

</CodeGroup>

**Step 2**: Configure your VibeKit client:

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createE2BProvider } from "@vibe-kit/e2b";

const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY!,
  templateId: "vibekit-claude",
});

const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(e2bProvider);

```

**Step 3**: Add event listeners and generate code:

```typescript
// Add event listeners
vibeKit.on("update", (update) => {
  console.log("Update:", update);
});

vibeKit.on("error", (error) => {
  console.error("Error:", error);
});

// Generate code
const result = await vibeKit.generateCode({
  prompt: "Create a simple web app that displays a list of users",
  mode: "code",
});

// Get host URL (optional)
const host = await vibeKit.getHost(3000);

// Clean up when done
await vibeKit.kill();

console.log("Result:", result);
console.log("Host:", host);

```



================================================
FILE: docs/sdk/secrets.mdx
================================================
---
title: 'Secrets Management'
description: 'Learn how to configure secrets and environment variables in VibeKit'
---

VibeKit allows you to securely pass environment variables to your sandbox environment through the `secrets` configuration. This guide explains how to configure and manage these secrets.

## Configuration Overview

Secrets in VibeKit are environment variables that get passed to the sandbox where your code executes. They are configured through the optional `secrets` object when initializing the VibeKit class.

```typescript
export type SecretsConfig = {
  /** Environment variables to be passed to the sandbox */
  [key: string]: string;
};
```

## Basic Usage

### Using withSecrets

```typescript
import { VibeKit } from "@vibe-kit/sdk";

const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(e2bProvider)
  .withSecrets({
    DATABASE_URL: process.env.DATABASE_URL!,
    REDIS_URL: process.env.REDIS_URL!,
    STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY!,
    API_BASE_URL: process.env.API_BASE_URL!,
  });
```

### Adding Secrets to Your Configuration

```typescript
import { VibeKit, VibeKitConfig } from "@vibe-kit/sdk";

const config: VibeKitConfig = {
  agent: {
    type: "codex",
    model: {
      apiKey: process.env.OPENAI_API_KEY!,
    },
  },
  environment: {
    e2b: {
      apiKey: process.env.E2B_API_KEY!,
    },
  },
  secrets: {
    // These environment variables will be available in your sandbox
    DATABASE_URL: process.env.DATABASE_URL!,
    REDIS_URL: process.env.REDIS_URL!,
    STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY!,
    API_BASE_URL: process.env.API_BASE_URL!,
  },
};

const vibeKit = new VibeKit(config);
```

### Accessing Secrets in Generated Code

Once configured, these secrets are available as environment variables in your sandbox:

```typescript
// In your generated code running in the sandbox
const databaseUrl = process.env.DATABASE_URL;
const stripeKey = process.env.STRIPE_SECRET_KEY;

// Use them in your application
const db = new Database(databaseUrl);
const stripe = new Stripe(stripeKey);
```

## Common Use Cases

### Database Connections

```typescript
const config: VibeKitConfig = {
  // ... other configuration
  secrets: {
    DATABASE_URL: process.env.DATABASE_URL!,
    DB_USER: process.env.DB_USER!,
    DB_PASSWORD: process.env.DB_PASSWORD!,
    DB_HOST: process.env.DB_HOST!,
    DB_PORT: process.env.DB_PORT!,
  },
};
```

### API Keys and External Services

```typescript
const config: VibeKitConfig = {
  // ... other configuration
  secrets: {
    STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY!,
    SENDGRID_API_KEY: process.env.SENDGRID_API_KEY!,
    AWS_ACCESS_KEY_ID: process.env.AWS_ACCESS_KEY_ID!,
    AWS_SECRET_ACCESS_KEY: process.env.AWS_SECRET_ACCESS_KEY!,
    TWILIO_ACCOUNT_SID: process.env.TWILIO_ACCOUNT_SID!,
    TWILIO_AUTH_TOKEN: process.env.TWILIO_AUTH_TOKEN!,
  },
};
```

### Application Configuration

```typescript
const config: VibeKitConfig = {
  // ... other configuration
  secrets: {
    NODE_ENV: process.env.NODE_ENV || "development",
    PORT: process.env.PORT || "3000",
    JWT_SECRET: process.env.JWT_SECRET!,
    CORS_ORIGIN: process.env.CORS_ORIGIN!,
    APP_URL: process.env.APP_URL!,
  },
};
```

## Environment Variables Setup

Create a `.env` file in your project root to store your secrets:

```bash
# .env
# VibeKit Configuration
OPENAI_API_KEY=sk-proj-your-openai-key
E2B_API_KEY=e2b_your-e2b-key

# Application Secrets (passed to sandbox)
DATABASE_URL=postgresql://user:password@localhost:5432/mydb
REDIS_URL=redis://localhost:6379
STRIPE_SECRET_KEY=sk_test_your-stripe-key
SENDGRID_API_KEY=SG.your-sendgrid-key
JWT_SECRET=your-jwt-secret-key
APP_URL=http://localhost:3000
```

## Security Best Practices

<Warning>
Never commit secrets or API keys to version control. Always use environment variables and ensure your `.env` file is in your `.gitignore`.
</Warning>

### 1. Use Environment Variables

Always use `process.env` to access secrets:

```typescript
// âœ… Good
secrets: {
  API_KEY: process.env.API_KEY!,
}

// âŒ Bad - Never hardcode secrets
secrets: {
  API_KEY: "secret-123-abc",
}
```

### 2. Add .env to .gitignore

Ensure your `.env` file is not committed to version control:

```bash
# .gitignore
.env
.env.local
.env.*.local
```

### 3. Validate Required Secrets

Validate that all required secrets are present before initializing VibeKit:

```typescript
const requiredSecrets = [
  'DATABASE_URL',
  'STRIPE_SECRET_KEY',
  'JWT_SECRET'
];

requiredSecrets.forEach((secret) => {
  if (!process.env[secret]) {
    throw new Error(`Missing required environment variable: ${secret}`);
  }
});

const config: VibeKitConfig = {
  // ... other configuration
  secrets: {
    DATABASE_URL: process.env.DATABASE_URL!,
    STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY!,
    JWT_SECRET: process.env.JWT_SECRET!,
  },
};
```

### 4. Use Different Environments

Use different environment files for different stages:

<CodeGroup>

```.env.development Development
DATABASE_URL=postgresql://localhost:5432/myapp_dev
STRIPE_SECRET_KEY=sk_test_dev_key
APP_URL=http://localhost:3000
```

```.env.staging Staging
DATABASE_URL=postgresql://staging-db:5432/myapp_staging
STRIPE_SECRET_KEY=sk_test_staging_key
APP_URL=https://staging.myapp.com
```

```.env.production Production
DATABASE_URL=postgresql://prod-db:5432/myapp_prod
STRIPE_SECRET_KEY=sk_live_prod_key
APP_URL=https://myapp.com
```

</CodeGroup>

## Complete Example

Here's a complete example showing how to set up secrets for a full-stack application:

```typescript
import { VibeKit, VibeKitConfig } from "@vibe-kit/sdk";

// Validate required environment variables
const requiredEnvVars = [
  'OPENAI_API_KEY',
  'E2B_API_KEY',
  'DATABASE_URL',
  'JWT_SECRET'
];

requiredEnvVars.forEach((envVar) => {
  if (!process.env[envVar]) {
    throw new Error(`Missing required environment variable: ${envVar}`);
  }
});

const config: VibeKitConfig = {
  agent: {
    type: "codex",
    model: {
      apiKey: process.env.OPENAI_API_KEY!,
    },
  },
  environment: {
    e2b: {
      apiKey: process.env.E2B_API_KEY!,
    },
  },
  github: {
    token: process.env.GITHUB_TOKEN!,
    repository: "your-org/your-repo",
  },
  secrets: {
    // Database
    DATABASE_URL: process.env.DATABASE_URL!,
    
    // Authentication
    JWT_SECRET: process.env.JWT_SECRET!,
    
    // External APIs
    STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY!,
    SENDGRID_API_KEY: process.env.SENDGRID_API_KEY!,
    
    // Application Config
    NODE_ENV: process.env.NODE_ENV || "development",
    PORT: process.env.PORT || "3000",
    CORS_ORIGIN: process.env.CORS_ORIGIN || "http://localhost:3000",
    
    // Custom secrets
    CUSTOM_API_ENDPOINT: process.env.CUSTOM_API_ENDPOINT!,
    WEBHOOK_SECRET: process.env.WEBHOOK_SECRET!,
  },
};

const vibeKit = new VibeKit(config);
```

## Troubleshooting

### Common Issues

1. **Missing Environment Variable**: Make sure all required secrets are set in your environment
2. **Secrets Not Available in Sandbox**: Ensure secrets are properly configured in the `secrets` object
3. **Type Errors**: Use the non-null assertion operator `!` or provide default values for optional secrets

### Testing Your Configuration

You can test your configuration by initializing VibeKit:

```typescript
try {
  const vibeKit = new VibeKit(config);
  console.log("âœ… VibeKit initialized successfully");
  console.log("ðŸ” Secrets configured:", Object.keys(config.secrets || {}));
} catch (error) {
  console.error("âŒ Configuration error:", error.message);
}
``` 


================================================
FILE: docs/sdk/session-management.mdx
================================================
---
title: 'Session Management'
description: 'Learn how to manage sessions in VibeKit for multi-turn conversations'
---

## Sessions

Sessions are a way to group together multiple requests to the agent. This is useful for multi-turn conversations and changes.

**Using withSession**

```typescript
const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(e2bProvider)
  .withSession("session-id-123");
```

**Set session id**

```typescript
const session = await vibeKit.setSession("abcd***")
```

**Get session id**

```typescript
const session = await vibeKit.getSession()
```



================================================
FILE: docs/sdk/streaming.mdx
================================================
---
title: Streaming
description: "VibeKit supports streaming responses, allowing you to receive data from the API in real-time as it is generated."
---

VibeKit supports streaming responses, allowing you to receive data from the API in real-time as it is generated. This is particularly useful for applications that require immediate feedback or want to display results incrementally.

## Overview

Streaming enables your application to process and display data as soon as it is available, rather than waiting for the entire response. This can improve user experience and reduce perceived latency.

## How to Use Streaming

To enable streaming with the `generateCode` method, use the event-driven approach with `.on()` listeners. The API will emit events as data is generated.

### Example Usage

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createE2BProvider } from "@vibe-kit/e2b";

const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY!,
  templateId: "vibekit-claude",
});

const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(e2bProvider);

// Set up event listeners for streaming
vibeKit.on("update", (message) => {
  // Handle streaming updates
  console.log('Streaming update:', message);
  // Update your UI with the new content
  updateUI(message);
});

vibeKit.on("error", (error) => {
  // Handle streaming errors
  console.error('Streaming error:', error);
});

// Generate code
const response = await vibeKit.generateCode({
  prompt: "Create a React component for a todo list",
  mode: "code",
});

// The final response is still available
console.log('Final response:', response);
```

### With Conversation History

```typescript
// Event listeners are already set up from previous example
vibeKit.on("update", (message) => {
  // Display incremental updates to the user
  appendToOutput(message);
});

const response = await vibeKit.generateCode({
  prompt: "Now add error handling to the component",
  mode: "code",
  history: previousConversation,
});
```

## When to Use Streaming

- When you want to display results to users as soon as they are available
- For long-running code generation tasks where incremental updates improve UX
- For interactive coding sessions where immediate feedback is valuable
- For chatbots or Q&A mode where responses can be shown progressively

## Streaming Events

VibeKit uses an event-driven approach for streaming with the following events:

| Event | Type | Description |
|----------|------|-------------|
| `update` | `(message: string) => void` | Emitted with streaming content updates as they are generated |
| `error` | `(error: string) => void` | Emitted when errors occur during streaming |

## Notes

- Streaming is available for both "ask" and "code" modes
- The final response is still returned as a Promise, even when using streaming events
- Event listeners are optional - you can use the method without them for non-streaming behavior
- Handle errors appropriately in your `error` event listener to provide good user experience

For more details, refer to the [Generate Code API Reference](/api-reference/generate-code) or contact support. 


================================================
FILE: docs/snippets/snippet-intro.mdx
================================================
One of the core principles of software development is DRY (Don't Repeat
Yourself). This is a principle that apply to documentation as
well. If you find yourself repeating the same content in multiple places, you
should consider creating a custom snippet to keep your content in sync.



================================================
FILE: docs/supported-sandboxes/cloudflare.mdx
================================================
---
title: 'Cloudflare'
description: 'Configure VibeKit with Cloudflare Sandboxes'
---

Cloudflare Sandboxes provide edge-native sandboxed code environments built on Cloudflare's container platform and Durable Objects. Unlike other VibeKit providers, Cloudflare sandboxes run exclusively within Cloudflare Workers for agentic & AI use cases. Learn more about Cloudflare Workers [here](https://workers.cloudflare.com/).

## Installation

```bash
npm install @vibe-kit/cloudflare
```

## Configuration

### Using the provider directly

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createCloudflareProvider } from "@vibe-kit/cloudflare";

// This must be called within a Cloudflare Worker
const provider = createCloudflareProvider({
  env: env, // Your Worker's env object containing the Sandbox binding
  hostname: "your-worker.domain.workers.dev", // Your Worker's hostname
});

const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(provider);

// Generate and run code
const result = await vibeKit.generateCode({
  prompt: "Create a simple web server using Node.js on port 3000",
  mode: "code",
});

// Get the preview URL for the running server
const previewUrl = await vibeKit.getHost(3000);
console.log(`Server running at: ${previewUrl}`);

// Clean up
await vibeKit.kill();
```

## Worker Setup

Cloudflare sandboxes require specific Worker configuration:

### 1. Configure wrangler.json

```jsonc
{
  "name": "my-vibekit-worker",
  "main": "src/index.ts",
  "compatibility_date": "2024-01-01",
  "containers": [
    {
      "class_name": "Sandbox",
      "image": "./node_modules/@cloudflare/sandbox/Dockerfile",
      "max_instances": 1
    }
  ],
  "durable_objects": {
    "bindings": [
      {
        "class_name": "Sandbox",
        "name": "Sandbox"
      }
    ]
  },
  "migrations": [
    {
      "new_sqlite_classes": ["Sandbox"],
      "tag": "v1"
    }
  ]
}
```

### 2. Create your Worker

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createCloudflareProvider, proxyToSandbox } from "@vibe-kit/cloudflare";

// Export the Sandbox class for Durable Objects
export { Sandbox } from "@cloudflare/sandbox";

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Handle preview URL routing for exposed ports
    const proxyResponse = await proxyToSandbox(request, env);
    if (proxyResponse) return proxyResponse;

    // Handle VibeKit requests
    const provider = createCloudflareProvider({
      env,
      hostname: request.headers.get("host") || "localhost",
    });

    const vibeKit = new VibeKit()
      .withAgent({
        type: "claude",
        provider: "anthropic",
        apiKey: process.env.ANTHROPIC_API_KEY!,
        model: "claude-sonnet-4-20250514",
      })
      .withSandbox(provider);

    const result = await vibeKit.generateCode({
      prompt: "Create a Node.js web server",
      mode: "code",
    });

    return new Response(JSON.stringify(result), {
      headers: { "Content-Type": "application/json" },
    });
  },
};
```

## ENV variables and secrets

```bash
ANTHROPIC_API_KEY=your_anthropic_api_key_here
OPENAI_API_KEY=your_openai_api_key_here  # If using OpenAI models
GOOGLE_API_KEY=your_google_api_key_here  # If using Gemini models
```

In your Worker code:

```typescript
const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(provider);
```

## Configuration Options

The `createCloudflareProvider` function accepts these configuration options:

- **`env`** (required): Your Cloudflare Worker's environment object containing the `Sandbox` Durable Object binding
- **`hostname`** (required): Your Worker's hostname used for generating preview URLs when exposing ports

## Unique Features

### Preview URLs
Cloudflare sandboxes can generate public preview URLs when services are exposed on specific ports, making them accessible from anywhere on the internet.

### Edge-Native Execution
Sandboxes run on Cloudflare's global edge network, providing low-latency execution closest to your users.

### Durable Objects Integration
Built on Cloudflare's Durable Objects platform for strong consistency, automatic geographic distribution, and seamless Workers platform integration.

## Local Development

For local development with `wrangler dev`, only ports explicitly exposed in the Dockerfile are available for port forwarding. This is not an issue in production.

To test multiple ports locally, create a custom Dockerfile:

```dockerfile
FROM docker.io/cloudflare/sandbox:0.1.3

EXPOSE 3000
EXPOSE 8080
EXPOSE 3001

# Always end with the same command as the base image
CMD ["bun", "index.ts"]
```

Then update your wrangler.json to use the custom Dockerfile:

```jsonc
{
  "containers": [
    {
      "class_name": "Sandbox",
      "image": "./Dockerfile",  // Point to your custom Dockerfile
      "max_instances": 1
    }
  ]
}
```

## Requirements

- **Cloudflare Workers**: Must run within a Cloudflare Worker environment
- **Wrangler**: For local development and deployment
- **Docker**: For building sandboxes locally and deploying to Cloudflare
- **Node.js 18+**: For development tooling



================================================
FILE: docs/supported-sandboxes/dagger.mdx
================================================
---
title: 'Dagger (Local)'
description: 'Configure VibeKit with local Dagger sandboxes for fast, offline development'
---

Dagger provides containerized sandboxes that run locally on your machine using Docker and the Dagger engine. This enables fast, offline development with complete isolation and control. Perfect for local development, testing, and when you need the speed of local execution with the isolation of containers. Learn more about Dagger [here](https://dagger.io).

## Installation

First, install the Dagger CLI on your system:

**macOS:**
```bash
brew install dagger/tap/dagger
```

**Linux:**
```bash
curl -fsSL https://dl.dagger.io/dagger/install.sh | BIN_DIR=$HOME/.local/bin sh
```

**Windows:**
```bash
winget install Dagger.Cli
```

Then install the Dagger provider package:

```bash
npm install @vibe-kit/dagger
```

**Verify installation:**
```bash
dagger version
docker --version
```

## Configuration

VibeKit uses a builder pattern with method chaining for type safety and flexibility. Configure your Dagger provider and VibeKit instance:

Dagger supports multiple container registries for storing and sharing pre-built agent images. Choose the registry that best fits your infrastructure and security requirements.

### Default Configuration (Docker Hub)

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createLocalProvider } from "@vibe-kit/dagger";

const provider = createLocalProvider({
  preferRegistryImages: true,             // Use optimized images when available
  registryName: "dockerhub",              // Defaults to DockerHub
  registryUser: "your-dockerhub-username" // Optional: for pushing/pulling images
});

const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(provider);

// Generate code
const result = await vibeKit.generateCode({ 
  prompt: "Create a REST API with Express.js", 
  mode: "ask" 
});

// Run development server in background
await vibeKit.executeCommand("npm run dev", { background: true });

// Get local host URL
const host = await vibeKit.getHost(3000);
console.log(`Server running at: ${host}`);

// Clean up
await vibeKit.kill();
```

### Using GitHub Container Registry

GitHub Container Registry provides seamless integration with GitHub workflows:

```typescript
const provider = createLocalProvider({
  registryName: "ghcr",
  registryUser: "github-username",
  githubToken: process.env.GITHUB_TOKEN, // Required for GHCR
});
```

**Setting up GHCR:**
```bash
# Set GitHub token (requires packages:write permission)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx

# Login to GHCR
echo $GITHUB_TOKEN | docker login ghcr.io -u USERNAME --password-stdin

# Initialize with GHCR
vibekit init --providers dagger --agents claude,codex \
  --registry ghcr --registry-user github-username
```

### Using AWS ECR

AWS Elastic Container Registry for enterprise AWS deployments:

```typescript
const provider = createLocalProvider({
  registryName: "ecr",
  registryUser: process.env.AWS_ACCOUNT_ID,
  // AWS CLI must be configured with credentials
});
```

**Setting up AWS ECR:**
```bash
# Configure AWS credentials
aws configure

# Set environment variables
export AWS_ACCOUNT_ID=123456789012
export AWS_REGION=us-east-1

# Login to ECR
aws ecr get-login-password --region $AWS_REGION | \
  docker login --username AWS --password-stdin \
  $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

# Initialize with ECR
vibekit init --providers dagger --agents claude,codex \
  --registry ecr --registry-user $AWS_ACCOUNT_ID
```

## Quick Setup

Initialize with automatic dependency installation:

```bash
# Interactive setup with agent selection
vibekit init --providers dagger --agents claude,codex

# With Docker Hub image optimization (default)
docker login
vibekit init --providers dagger --agents claude,codex --upload-images

# With GitHub Container Registry
vibekit init --providers dagger --agents claude,codex \
  --registry ghcr --registry-user github-username --upload-images

# With AWS ECR
vibekit init --providers dagger --agents claude,codex \
  --registry ecr --registry-user $AWS_ACCOUNT_ID --upload-images
```

The setup will:
- Install Docker and Dagger CLI if needed
- Pre-build agent images for faster startup
- Optionally upload optimized images to your chosen registry
- Configure registry authentication



## ENV variables and secrets

Configure your Dagger provider using environment variables:

```bash
# GitHub integration (optional)
GITHUB_TOKEN=your_github_token_here

# Agent API keys
ANTHROPIC_API_KEY=your_anthropic_key
OPENAI_API_KEY=your_openai_key
GOOGLE_API_KEY=your_google_key
GEMINI_API_KEY=your_gemini_key
GROK_API_KEY=your_grok_key

# Registry configuration
VIBEKIT_REGISTRY_NAME=ghcr          # Registry type (dockerhub, ghcr, ecr)
VIBEKIT_REGISTRY_USER=myusername    # Registry username
VIBEKIT_PREFER_REGISTRY=true        # Use registry images when available
VIBEKIT_PUSH_IMAGES=true            # Auto-push built images

# Registry-specific authentication
GITHUB_TOKEN=ghp_xxxx               # For GitHub Container Registry
AWS_ACCOUNT_ID=123456789012         # For AWS ECR
AWS_REGION=us-east-1                # For AWS ECR

# Advanced configuration
VIBEKIT_RETRY_ATTEMPTS=3            # Registry operation retries
VIBEKIT_RETRY_DELAY=1000            # Retry delay in ms
VIBEKIT_CONNECTION_TIMEOUT=30000    # Connection timeout in ms
VIBEKIT_CONFIG_PATH=~/.vibekit      # Config directory path
VIBEKIT_LOG_LEVEL=debug              # Enable debug logging
```

Reference them in your code:

```typescript
// Dagger provider configuration
const provider = createLocalProvider({
  preferRegistryImages: true,
  dockerHubUser: "your-username",
  // All other config is auto-loaded from env vars
});

// GitHub configuration at SDK level
const vibeKit = new VibeKit()
  .withSandbox(provider)
  .withGithub({
    token: process.env.GITHUB_TOKEN,
    repository: "owner/repo-name",
  });
```

## Configuration Options

The `createLocalProvider` function accepts these configuration options:

- **`preferRegistryImages`** (optional): Use pre-built registry images for faster startup (default: `true`)
- **`registryUser`** (optional): Registry username for pulling/pushing custom images (works with any registry)
- **`registryName`** (optional): Which registry to use - supported values:
  - `"dockerhub"` - Docker Hub (default)
  - `"ghcr"` - GitHub Container Registry
  - `"ecr"` - AWS Elastic Container Registry
- **`dockerHubUser`** (optional, deprecated): Legacy Docker Hub username - use `registryUser` instead
- **`privateRegistry`** (optional): Alternative registry URL for enterprise setups
- **`pushImages`** (optional): Automatically push built images to registry (default: `true`)
- **`autoInstall`** (optional): Automatically install missing dependencies (default: `false`)
- **`retryAttempts`** (optional): Number of retry attempts for registry operations (default: `3`)
- **`retryDelayMs`** (optional): Delay between retry attempts in milliseconds (default: `1000`)

## Unique Features

### Local Execution
- **No internet required** - Everything runs on your machine
- **Zero usage fees** - No per-minute or per-execution costs
- **Offline development** - Work without network connectivity

### Performance Optimization
- **Local execution** - No network latency for container operations
- **Multi-registry support** - Choose the best registry for your infrastructure:
  - **Docker Hub** - Public registry, easy sharing
  - **GitHub Container Registry** - Integrated with GitHub workflows
  - **AWS ECR** - Enterprise AWS deployments
- **Automatic image caching** - Reuse images across sessions
- **Registry fallback** - Automatically falls back to local builds if registry is unavailable

## Registry Architecture

VibeKit's Dagger provider supports multiple container registries through a flexible factory pattern:

### Registry Selection
The registry is selected based on the `registryName` configuration:
- **`dockerhub`** (default) - Public Docker Hub registry
- **`ghcr`** - GitHub Container Registry (requires GitHub token)
- **`ecr`** - AWS Elastic Container Registry (requires AWS credentials)

### Image Resolution Strategy
1. **Check local cache** - Look for existing Docker images locally
2. **Pull from registry** - Attempt to pull pre-built images from configured registry
3. **Build from Dockerfile** - Fall back to building from source if needed

### Migration Guide

If you're upgrading from an older version that only supported Docker Hub:

```typescript
// Old configuration (still supported)
const provider = createLocalProvider({
  dockerHubUser: "myusername"
});

// New configuration (recommended)
const provider = createLocalProvider({
  registryUser: "myusername",     // Universal field
  registryName: "dockerhub"       // Explicit registry selection
});
```

The `dockerHubUser` field is maintained for backward compatibility but `registryUser` is now the recommended universal field that works with all registries.

## System Requirements

- **Docker** - Container runtime (automatically installed during setup)
- **Dagger CLI** - Container orchestration engine (automatically installed during setup)  
- **Node.js 18+** - Runtime environment
- **8GB RAM recommended** - For running multiple containers
- **Registry-specific requirements:**
  - **GitHub Container Registry**: GitHub account with packages:write permission
  - **AWS ECR**: AWS account with ECR permissions and configured AWS CLI

## Troubleshooting

**Docker not running:**
```bash
# Check Docker status
docker ps

# Start Docker (macOS)
open -a Docker

# Start Docker (Linux)
sudo systemctl start docker
```

**Dagger CLI not found:**
```bash
# Reinstall Dagger
curl -fsSL https://dl.dagger.io/install.sh | bash
dagger version
```

**Registry authentication issues:**

```bash
# Docker Hub
docker logout
docker login

# GitHub Container Registry
echo $GITHUB_TOKEN | docker login ghcr.io -u USERNAME --password-stdin

# AWS ECR
aws ecr get-login-password --region $AWS_REGION | \
  docker login --username AWS --password-stdin \
  $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com
```

**Permission errors (Linux):**
```bash
# Add user to docker group
sudo usermod -aG docker $USER
# Then log out and back in
```

**Registry image not found:**
```bash
# Rebuild and push images
vibekit prebuild --agents claude,codex --push
``` 


================================================
FILE: docs/supported-sandboxes/daytona.mdx
================================================
---
title: 'Daytona'
description: 'Configure VibeKit with a Daytona Sandbox'
---

Daytona is an open-source runtime for executing AI-generated code in secure cloud sandboxes. Made for agentic & AI use cases. You can read more about it [here](https://daytona.io).

## Installation

First, install the Daytona provider package:

```bash
npm install @vibe-kit/daytona
```

## How to use

To use Daytona with VibeKit, you need to create an image in the Daytona dashboard using the following DockerFile:

**Claude Codex Dockerfile**
```dockerfile
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git ripgrep

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install Claude Code globalliy
RUN npm install -g @anthropic-ai/claude-code
```                                                  

**OpenAI Codex Dockerfile**
```dockerfile
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install OpenAI Codex globally
RUN npm install -g @openai/codex@latest
```    

**Opencode Dockerfile**
```dockerfile
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install OpenAI Codex globally
RUN npm i -g opencode-ai@latest
```   


## Configuration

### Using the provider directly

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createDaytonaProvider } from "@vibe-kit/daytona";

const daytonaProvider = createDaytonaProvider({
  apiKey: process.env.DAYTONA_API_KEY!,
  image: "codex-image",
  serverUrl: "https://app.daytona.io/api",
});

const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(daytonaProvider);

// Generate code
const result = await vibeKit.generateCode({ 
  prompt: "Build a Python FastAPI application", 
  mode: "ask" 
});

// Get host URL (if applicable)
const host = await vibeKit.getHost(8000);

// Clean up
await vibeKit.kill();
```

### Using configuration object

```typescript
import { VibeKit, VibeConfig } from "@vibe-kit/sdk";

const config: VibeConfig = {
  ...,
  environment: {
    daytona: {
      // Required Daytona API key
      apiKey: "****",
      image: "codex-image",
      serverUrl: "https://app.daytona.io/api"
    },
  },
};
```

## ENV variables and secrets

You can use environment variables for your Daytona configuration:

```bash
DAYTONA_API_KEY=your_daytona_api_key_here
```

Then reference them in your code:

```typescript
const daytonaProvider = createDaytonaProvider({
  apiKey: process.env.DAYTONA_API_KEY!,
  image: "codex-image",
  serverUrl: "https://app.daytona.io/api",
});
```


================================================
FILE: docs/supported-sandboxes/e2b.mdx
================================================
---
title: 'E2B'
description: 'Configure VibeKit with an E2B sandbox'
---

E2B is an open-source runtime for executing AI-generated code in secure cloud sandboxes. Made for agentic & AI use cases. You can read more about it [here](https://e2b.dev).

## Installation

First, install the E2B provider package:

```bash
npm install @vibe-kit/e2b
```

## How to use

To use E2B with VibeKit, you need to configure E2B when creating a new VibeKit instance. You can get your API key from the E2B dashboard.

### Using the provider directly

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createE2BProvider } from "@vibe-kit/e2b";

const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY!,
  templateId: "vibekit-claude", // Optional custom template
});

const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(e2bProvider);

// Generate code
const result = await vibeKit.generateCode({ 
  prompt: "Create a simple web server", 
  mode: "ask" 
});

// Get host URL (if applicable)
const host = await vibeKit.getHost(3000);

// Clean up
await vibeKit.kill();
```

### Using configuration object

```typescript
import { VibeKit, VibeConfig } from "@vibe-kit/sdk";

const config: VibeConfig = {
  ...,
  environment: {
    e2b: {
      // Required E2B API key
      apiKey: "e2b_****",
      // Optional custom E2B template you want to use 
      // that has the codex CLI and Git installed.
      templateId: "super-codex" 
    },
  },
};
```

## ENV variables and secrets

You can use environment variables for your E2B configuration:

```bash
E2B_API_KEY=your_e2b_api_key_here
```

Then reference them in your code:

```typescript
const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY!,
  templateId: "vibekit-claude",
});
```


================================================
FILE: docs/supported-sandboxes/flyio.mdx
================================================
---
title: 'Fly.io'
description: 'Configure VibeKit with Fly.io'
---

Coming soon...


================================================
FILE: docs/supported-sandboxes/modal.mdx
================================================
---
title: 'Modal'
description: 'Configure VibeKit with Modal'
---

Coming soon...


================================================
FILE: docs/supported-sandboxes/northflank.mdx
================================================
---
title: 'Northflank'
description: 'Configure VibeKit with Northflank persistent sandboxes'
---

Northflank is a PaaS that allows you to run persistent sandboxes either on the Northflank infrastructure or your GCP/AWS. You can read more about it [here](https://northflank.com).

## Installation

First, install the Northflank provider package:

```bash
npm install @vibe-kit/northflank
```

## How to use

To use Northflank with VibeKit, you need to configure Northflank when creating a new VibeKit instance. Note that you must create a new project and API key in the Northflank dashboard.

### Using the provider directly

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createNorthflankProvider } from "@vibe-kit/northflank";

const northflankProvider = createNorthflankProvider({
  apiKey: process.env.NORTHFLANK_API_KEY!,
  projectId: "your-project-id",
  billingPlan: "nf-compute-200", // Optional: 2 vCPU & 4096GB RAM
  persistentVolumeStorage: 10240, // Optional: 10GiB
});

const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(northflankProvider);

// Generate code
const result = await vibeKit.generateCode({ 
  prompt: "Create a React application", 
  mode: "ask" 
});

// Get host URL (if applicable)
const host = await vibeKit.getHost(3000);

// Clean up
await vibeKit.kill();
```

### Using configuration object

```typescript
import { VibeKit, VibeConfig } from "@vibe-kit/sdk";

const config: VibeConfig = {
  ...,
  environment: {
    northflank: {
      // Required Northflank API key
      apiKey: "nf_****",
      // Optional custom image to override the inferred agent sandbox image
      image: "your-custom-image",
      // Optional project ID corresponding to the project you created
      projectId: "your-project-id",
      // Optional billing plan determining CPU & RAM (default: nf-compute-200 - 2 vCPU & 4096GB RAM)
      billingPlan: "nf-compute-200",
      // Optional persistent volume size in MB (default: 10240 - 10GiB)
      persistentVolumeStorage: 10240
    },
  },
};
```

## Configuration Options

- **`apiKey`** (required): The API token you generated in the Northflank dashboard for authentication
- **`image`** (optional): Override the inferred agent sandbox image with a custom image
- **`projectId`** (optional): The project name you created in the Northflank dashboard
- **`billingPlan`** (optional): Determines the CPU & RAM of the sandboxes (default: `nf-compute-200` which has 2 vCPU & 4096GB RAM)
- **`persistentVolumeStorage`** (optional): The persistent volume size in MB (default: `10240` for 10GiB)

## ENV variables and secrets

You can use environment variables for your Northflank configuration:

```bash
NORTHFLANK_API_KEY=your_northflank_api_key_here
```

Then reference them in your code:

```typescript
const northflankProvider = createNorthflankProvider({
  apiKey: process.env.NORTHFLANK_API_KEY!,
  projectId: "your-project-id",
});
```


================================================
FILE: packages/auth/README.md
================================================
# @vibe-kit/auth

Universal OAuth authentication library for AI providers' MAX subscriptions. Currently supports Claude AI with Gemini, Grok, and ChatGPT Max coming soon.

## Features

- **MAX Subscription Access**: Leverage your existing AI provider MAX subscriptions programmatically
- **Multiple Providers**: Claude AI (available), Gemini, Grok, ChatGPT Max (coming soon)
- **Environment-Specific Builds**: Separate Node.js and browser-compatible builds
- **OAuth 2.0 + PKCE**: Secure authentication with industry standards
- **Token Management**: Automatic token refresh and secure storage
- **Browser & Node.js**: Works in both web applications and server environments

## Installation

```bash
npm install @vibe-kit/auth
```

## Usage

### Node.js Environment

For Node.js applications (CLI tools, servers, etc.), use the Node.js-specific import:

```typescript
import { ClaudeAuth } from '@vibe-kit/auth/node';

// Start OAuth flow (opens browser automatically)
const token = await ClaudeAuth.authenticate();

// Check if authenticated
const isAuthenticated = await ClaudeAuth.isAuthenticated();

// Get valid token (auto-refresh if needed)
const accessToken = await ClaudeAuth.getValidToken();

// Verify authentication
const isValid = await ClaudeAuth.verify();

// Get authentication status
const status = await ClaudeAuth.getStatus();

// Logout
await ClaudeAuth.logout();
```

### Browser Environment

For browser/web applications, use the browser-safe import:

```typescript
import { ClaudeWebAuth, LocalStorageTokenStorage } from '@vibe-kit/auth/browser';
// OR use the default import which is browser-safe:
// import { ClaudeAuth, LocalStorageTokenStorage } from '@vibe-kit/auth';

// Create storage
const storage = new LocalStorageTokenStorage();
const auth = new ClaudeWebAuth(storage);

// Create authorization URL
const { url, state, codeVerifier } = ClaudeWebAuth.createAuthorizationUrl();

// Open URL in browser for user authentication
window.open(url, '_blank');

// After user authorizes and provides the code#state string:
const authCode = 'code123#state456'; // From user input
const token = await auth.authenticate(authCode, codeVerifier, state);

// Check authentication status
const isAuthenticated = await auth.isAuthenticated();

// Get valid token (auto-refresh if needed)
const accessToken = await auth.getValidToken();
```

### Using with AI Provider APIs

Once authenticated, use the access token with your MAX subscription to access AI APIs:

#### Claude AI (Available Now)

```typescript
import { ClaudeAuth } from '@vibe-kit/auth/node'; // For Node.js

// Authenticate and get token
let accessToken = await ClaudeAuth.getValidToken();
if (!accessToken) {
  await ClaudeAuth.authenticate();
  accessToken = await ClaudeAuth.getValidToken();
}

// Use with Claude Code CLI
// First, export the token as an environment variable:
// export CLAUDE_CODE_OAUTH_TOKEN=${accessToken}
// claude -p 'Hello, Claude!'
```

For browser applications:

```typescript
import { ClaudeWebAuth, LocalStorageTokenStorage } from '@vibe-kit/auth/browser';

const storage = new LocalStorageTokenStorage();
const auth = new ClaudeWebAuth(storage);

// Get token (assumes user is already authenticated)
const accessToken = await auth.getValidToken();
if (!accessToken) {
  // Handle authentication flow...
}

// Use with Claude Code CLI
// First, export the token as an environment variable:
// export CLAUDE_CODE_OAUTH_TOKEN=${accessToken}
// claude -p 'Hello!'
```

### Token Import/Export (Node.js only)

```typescript
import { ClaudeAuth } from '@vibe-kit/auth/node';

// Export token in different formats
const envToken = await ClaudeAuth.exportToken('env');
const jsonToken = await ClaudeAuth.exportToken('json');
const fullToken = await ClaudeAuth.exportToken('full');

// Import from various sources
await ClaudeAuth.importToken({ fromEnv: true });
await ClaudeAuth.importToken({ fromFile: './token.json' });
await ClaudeAuth.importToken({ refreshToken: 'your-refresh-token' });
```

## Types

```typescript
interface OAuthToken {
  access_token: string;
  token_type: string;
  expires_in?: number;
  refresh_token?: string;
  scope?: string;
  created_at: number;
}
```

## Storage Options

- **MemoryTokenStorage**: In-memory storage for server-side use
- **LocalStorageTokenStorage**: Browser localStorage (client-side only)
- **CookieTokenStorage**: Cookie-based storage for SSR applications

## Security

- Tokens are stored with restricted file permissions (CLI)
- Automatic token refresh prevents expired token usage
- PKCE (Proof Key for Code Exchange) for secure OAuth flows
- State parameter validation prevents CSRF attacks

## Environment Compatibility

- **Node.js**: Use `@vibe-kit/auth/node` for full functionality including file system access and browser launching
- **Browser**: Use `@vibe-kit/auth/browser` or default import for browser-safe functionality
- **Universal**: The default import provides browser-safe functionality that works everywhere

## Why Use MAX Subscriptions?

Instead of paying per API call, leverage the subscriptions you already have:

- **Cost Effective**: Use your existing MAX subscriptions instead of pay-per-use APIs
- **Higher Limits**: MAX subscriptions often have higher rate limits and priority access
- **Latest Models**: Access to the newest and most capable models in each provider's lineup
- **Consistent Experience**: Same interface across different AI providers

## Usage with Other Libraries

The auth package can be used with any Claude AI client library or direct API calls:

```typescript
// Node.js applications
import { authenticate, getValidToken } from '@vibe-kit/auth/node';

// Browser applications  
import { ClaudeWebAuth } from '@vibe-kit/auth/browser';
```

#### Coming Soon

- **Gemini Max**: Access Google's most advanced AI models with your subscription
- **Grok Max**: Leverage xAI's premium models through your subscription  
- **ChatGPT Max**: Use OpenAI's latest models with your existing subscription

### With Official SDKs

```typescript
// Claude AI with Anthropic SDK
import Anthropic from '@anthropic-ai/sdk';
import { ClaudeAuth } from '@vibe-kit/auth/node';

const accessToken = await ClaudeAuth.getValidToken();
const anthropic = new Anthropic({
  apiKey: '', // Leave empty for OAuth
  authToken: accessToken, // Use your MAX subscription token
});

const message = await anthropic.messages.create({
  model: 'claude-sonnet-4-20250514',
  max_tokens: 1000,
  messages: [{ role: 'user', content: 'Hello!' }]
});
```


================================================
FILE: packages/auth/package.json
================================================
{
  "name": "@vibe-kit/auth",
  "version": "0.0.5",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    },
    "./node": {
      "types": "./dist/node.d.ts",
      "import": "./dist/node.js",
      "require": "./dist/node.cjs"
    },
    "./browser": {
      "types": "./dist/browser.d.ts",
      "import": "./dist/browser.js",
      "require": "./dist/browser.cjs"
    }
  },
  "scripts": {
    "build": "tsup",
    "dev": "tsup src/index.ts --watch",
    "type-check": "tsc --noEmit"
  },
  "devDependencies": {
    "@types/node": "^22.15.18",
    "tsup": "^8.4.0",
    "typescript": "^5.8.3"
  },
  "dependencies": {
    "oauth4webapi": "^3.6.0"
  }
}



================================================
FILE: packages/auth/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ES2022", "DOM"],
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "allowJs": true,
    "strict": true,
    "skipLibCheck": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "dist",
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


================================================
FILE: packages/auth/tsup.config.ts
================================================
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts', 'src/node.ts', 'src/browser.ts'],
  format: ['esm', 'cjs'],
  dts: true,
  clean: true,
  sourcemap: true,
  splitting: false,
  treeshake: true,
  minify: false,
  target: 'node18',
  external: []
});


================================================
FILE: packages/auth/src/browser.ts
================================================
/**
 * Browser-specific OAuth authentication utilities for VibeKit
 * This module is safe for browser environments and excludes Node.js specific modules
 */

// Re-export all web-compatible exports
export {
  ClaudeWebAuth,
  type TokenStorage,
  MemoryTokenStorage,
  LocalStorageTokenStorage,
  CookieTokenStorage,
  type OAuthToken
} from './oauth-web.js';

// For convenience, re-export the main web auth class as ClaudeAuth as well
export { ClaudeWebAuth as ClaudeAuth } from './oauth-web.js';


================================================
FILE: packages/auth/src/index.ts
================================================
/**
 * OAuth authentication utilities for VibeKit
 * 
 * @example Node.js usage:
 * ```typescript
 * import { ClaudeAuth } from '@vibe-kit/auth/node';
 * 
 * // Authenticate and get token
 * const token = await ClaudeAuth.authenticate();
 * 
 * // Check if authenticated
 * const isAuthenticated = await ClaudeAuth.isAuthenticated();
 * ```
 * 
 * @example Browser usage:
 * ```typescript
 * import { ClaudeWebAuth, LocalStorageTokenStorage } from '@vibe-kit/auth/browser';
 * 
 * const storage = new LocalStorageTokenStorage();
 * const auth = new ClaudeWebAuth(storage);
 * 
 * // Create authorization URL
 * const { url, state, codeVerifier } = ClaudeWebAuth.createAuthorizationUrl();
 * 
 * // After user authorization, exchange code for token
 * const token = await auth.authenticate(authCode, codeVerifier, state);
 * ```
 */

// Default to browser-safe exports for maximum compatibility
// For Node.js specific functionality, import from '@vibe-kit/auth/node'
export type { OAuthToken, TokenStorage } from './oauth-web.js';
export { 
  ClaudeWebAuth, 
  MemoryTokenStorage, 
  LocalStorageTokenStorage, 
  CookieTokenStorage 
} from './oauth-web.js';

// Re-export ClaudeWebAuth as default ClaudeAuth for convenience
export { ClaudeWebAuth as ClaudeAuth } from './oauth-web.js';


================================================
FILE: packages/auth/src/node.ts
================================================
/**
 * Node.js-specific OAuth authentication utilities for VibeKit
 * This module includes Node.js specific features like file system access and child_process
 */

import {
  authenticate,
  getValidToken,
  loadToken,
  saveToken,
  clearToken,
  isTokenExpired,
  refreshToken,
  refreshTokenToAccessToken,
  type OAuthToken
} from './oauth.js';

export class ClaudeAuth {
  /**
   * Start OAuth authentication flow
   * Opens browser for user authentication
   */
  static async authenticate(): Promise<OAuthToken> {
    return authenticate();
  }

  /**
   * Check if currently authenticated
   */
  static async isAuthenticated(): Promise<boolean> {
    const token = await getValidToken();
    return token !== null;
  }

  /**
   * Get current authentication status
   */
  static async getStatus(): Promise<{
    authenticated: boolean;
    tokenType?: string;
    scope?: string;
    expiresAt?: Date;
    hasRefreshToken?: boolean;
  }> {
    const tokenData = await loadToken();
    
    if (!tokenData) {
      return { authenticated: false };
    }

    const validToken = await getValidToken();
    const status: any = {
      authenticated: !!validToken,
      tokenType: tokenData.token_type || 'Bearer',
      scope: tokenData.scope,
      hasRefreshToken: !!tokenData.refresh_token
    };

    if (tokenData.expires_in && tokenData.created_at) {
      status.expiresAt = new Date(tokenData.created_at + tokenData.expires_in * 1000);
    }

    return status;
  }

  /**
   * Get valid access token (auto-refreshes if expired)
   */
  static async getValidToken(): Promise<string | null> {
    return getValidToken();
  }

  /**
   * Export token in various formats
   * @param format - 'env', 'json', 'full', or 'refresh'
   */
  static async exportToken(format: 'env' | 'json' | 'full' | 'refresh' = 'env'): Promise<string | object> {
    const tokenData = await loadToken();
    if (!tokenData) {
      throw new Error('No authentication token found');
    }

    const accessToken = await getValidToken();
    if (!accessToken && format !== 'refresh') {
      throw new Error('Token is expired and could not be refreshed');
    }

    switch (format) {
      case 'env':
        return `export CLAUDE_CODE_OAUTH_TOKEN="${accessToken}"`;
        
      case 'json':
        return { access_token: accessToken };
        
      case 'full':
        return {
          access_token: tokenData.access_token,
          refresh_token: tokenData.refresh_token,
          token_type: tokenData.token_type || 'Bearer',
          expires_in: tokenData.expires_in,
          scope: tokenData.scope,
          created_at: tokenData.created_at
        };
        
      case 'refresh':
        if (!tokenData.refresh_token) {
          throw new Error('No refresh token available');
        }
        return tokenData.refresh_token;
        
      default:
        throw new Error(`Unknown format: ${format}`);
    }
  }

  /**
   * Import token from various sources
   */
  static async importToken(options: {
    accessToken?: string;
    refreshToken?: string;
    tokenData?: OAuthToken;
    fromEnv?: boolean;
    fromFile?: string;
  }): Promise<void> {
    let tokenData: OAuthToken;

    if (options.fromEnv) {
      const envToken = process.env.CLAUDE_CODE_OAUTH_TOKEN;
      if (!envToken) {
        throw new Error('No CLAUDE_CODE_OAUTH_TOKEN environment variable found');
      }
      tokenData = {
        access_token: envToken,
        token_type: 'Bearer',
        created_at: Date.now()
      };
    } else if (options.fromFile) {
      // Read token from file
      const fs = await import('fs/promises');
      try {
        const fileContent = await fs.readFile(options.fromFile, 'utf-8');
        const parsedData = JSON.parse(fileContent);
        
        // Validate required fields
        if (!parsedData.access_token) {
          throw new Error('Invalid token file: missing access_token');
        }
        
        tokenData = {
          ...parsedData,
          created_at: parsedData.created_at || Date.now()
        };
      } catch (error) {
        if ((error as any).code === 'ENOENT') {
          throw new Error(`File not found: ${options.fromFile}`);
        }
        throw error;
      }
    } else if (options.refreshToken) {
      tokenData = await refreshTokenToAccessToken(options.refreshToken);
    } else if (options.accessToken) {
      tokenData = {
        access_token: options.accessToken,
        token_type: 'Bearer',
        created_at: Date.now()
      };
    } else if (options.tokenData) {
      tokenData = {
        ...options.tokenData,
        created_at: options.tokenData.created_at || Date.now()
      };
    } else {
      throw new Error('No token source provided');
    }

    await saveToken(tokenData);
  }

  /**
   * Verify authentication by making a test API call
   */
  static async verify(): Promise<boolean> {
    const accessToken = await getValidToken();
    if (!accessToken) {
      return false;
    }

    try {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'content-type': 'application/json',
          'anthropic-version': '2023-06-01',
          'anthropic-beta': 'oauth-2025-04-20',
          'Authorization': `Bearer ${accessToken}`,
          'X-API-Key': '',
        },
        body: JSON.stringify({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 10,
          system: 'You are Claude Code, Anthropic\'s official CLI for Claude.',
          messages: [{
            role: 'user',
            content: 'Reply with OK only.'
          }]
        }),
      });

      return response.ok;
    } catch {
      return false;
    }
  }

  /**
   * Verify authentication with detailed response
   * @returns Detailed verification result including API response
   */
  static async verifyWithDetails(): Promise<{
    success: boolean;
    status?: number;
    response?: any;
    error?: string;
  }> {
    const accessToken = await getValidToken();
    if (!accessToken) {
      return { 
        success: false, 
        error: 'No valid authentication token found' 
      };
    }

    try {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'content-type': 'application/json',
          'anthropic-version': '2023-06-01',
          'anthropic-beta': 'oauth-2025-04-20',
          'Authorization': `Bearer ${accessToken}`,
          'X-API-Key': '',
        },
        body: JSON.stringify({
          model: 'claude-sonnet-4-20250514',
          max_tokens: 10,
          system: 'You are Claude Code, Anthropic\'s official CLI for Claude.',
          messages: [{
            role: 'user',
            content: 'Reply with OK only.'
          }]
        }),
      });

      if (response.ok) {
        const data = await response.json() as any;
        return { 
          success: true, 
          status: response.status,
          response: data.content[0].text 
        };
      } else {
        const error = await response.text();
        return { 
          success: false, 
          status: response.status,
          error: `API Error: ${response.status} ${error}` 
        };
      }
    } catch (error) {
      return { 
        success: false, 
        error: (error as Error).message 
      };
    }
  }

  /**
   * Clear authentication (logout)
   */
  static async logout(): Promise<void> {
    return clearToken();
  }

  /**
   * Get raw token data (for advanced use)
   */
  static async getRawToken(): Promise<OAuthToken | null> {
    return loadToken();
  }

  /**
   * Check if token is expired
   */
  static async isTokenExpired(): Promise<boolean> {
    const tokenData = await loadToken();
    if (!tokenData) return true;
    return isTokenExpired(tokenData);
  }

  /**
   * Manually refresh token
   */
  static async refreshToken(): Promise<OAuthToken | null> {
    const tokenData = await loadToken();
    if (!tokenData || !tokenData.refresh_token) {
      return null;
    }
    return refreshToken(tokenData);
  }
}

// Re-export types and functions for direct use
export type { OAuthToken } from './oauth.js';
export {
  authenticate,
  getValidToken,
  loadToken,
  saveToken,
  clearToken,
  isTokenExpired,
  refreshToken,
  refreshTokenToAccessToken
} from './oauth.js';


================================================
FILE: packages/auth/src/oauth-web.ts
================================================
import * as oauth from "oauth4webapi";
import type { OAuthToken } from "./oauth.js";

// Re-export OAuthToken for convenience
export type { OAuthToken };

// OAuth configuration
const OAUTH_CONFIG = {
  clientId: "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
  authorizationUrl: "https://claude.ai/oauth/authorize",
  tokenUrl: "https://console.anthropic.com/v1/oauth/token",
  redirectUri: "https://console.anthropic.com/oauth/code/callback",
  scope: "org:create_api_key user:profile user:inference",
  betaHeader: "oauth-2025-04-20",
};

/**
 * Token storage interface for web applications
 * Implementations can use cookies, localStorage, sessionStorage, or server-side sessions
 */
export interface TokenStorage {
  get(): Promise<OAuthToken | null>;
  set(token: OAuthToken): Promise<void>;
  remove(): Promise<void>;
}

/**
 * In-memory token storage (for server-side use)
 */
export class MemoryTokenStorage implements TokenStorage {
  private tokens = new Map<string, OAuthToken>();

  constructor(private sessionId: string) {}

  async get(): Promise<OAuthToken | null> {
    return this.tokens.get(this.sessionId) || null;
  }

  async set(token: OAuthToken): Promise<void> {
    this.tokens.set(this.sessionId, token);
  }

  async remove(): Promise<void> {
    this.tokens.delete(this.sessionId);
  }
}

/**
 * Web OAuth authentication helper
 * Designed for use in web applications with manual code input (like CLI)
 */
export class ClaudeWebAuth {
  private storage: TokenStorage;

  constructor(storage: TokenStorage) {
    this.storage = storage;
  }

  /**
   * Generate PKCE code verifier and challenge
   */
  static async generatePKCE() {
    const codeVerifier = oauth.generateRandomCodeVerifier();
    const codeChallenge = await oauth.calculatePKCECodeChallenge(codeVerifier);

    return { codeVerifier, codeChallenge };
  }

  /**
   * Generate random state for OAuth flow
   */
  static generateState() {
    return oauth.generateRandomState();
  }

  /**
   * Create authorization URL with ?code=true for manual code copying
   * @returns Authorization URL, state, and PKCE verifier
   */
  static async createAuthorizationUrl(): Promise<{
    url: string;
    state: string;
    codeVerifier: string;
    codeChallenge: string;
  }> {
    // Generate PKCE and state
    const { codeVerifier, codeChallenge } = await ClaudeWebAuth.generatePKCE();
    const state = ClaudeWebAuth.generateState();

    // Build authorization URL with ?code=true (like CLI)
    const authUrl = new URL(OAUTH_CONFIG.authorizationUrl);
    authUrl.searchParams.set("code", "true");
    authUrl.searchParams.set("client_id", OAUTH_CONFIG.clientId);
    authUrl.searchParams.set("response_type", "code");
    authUrl.searchParams.set("scope", OAUTH_CONFIG.scope);
    authUrl.searchParams.set("redirect_uri", OAUTH_CONFIG.redirectUri);
    authUrl.searchParams.set("code_challenge", codeChallenge);
    authUrl.searchParams.set("code_challenge_method", "S256");
    authUrl.searchParams.set("state", state);

    return {
      url: authUrl.toString(),
      state,
      codeVerifier,
      codeChallenge,
    };
  }

  /**
   * Exchange authorization code for access token
   * @param authCode - Authorization code in format "code#state" from Claude
   * @param codeVerifier - PKCE code verifier
   * @param expectedState - Expected state for validation
   */
  static async exchangeCodeForToken(
    authCode: string,
    codeVerifier: string,
    expectedState: string
  ): Promise<OAuthToken> {
    // Parse code and state from pasted string (format: code#state)
    const [code, pastedState] = authCode.split("#");

    if (!code || !pastedState) {
      throw new Error(
        "Invalid authentication code format. Expected: code#state"
      );
    }

    if (pastedState !== expectedState) {
      throw new Error("State mismatch. Authentication failed.");
    }

    const body = {
      grant_type: "authorization_code",
      code,
      state: pastedState,
      code_verifier: codeVerifier,
      redirect_uri: OAUTH_CONFIG.redirectUri,
      client_id: OAUTH_CONFIG.clientId,
    };

    const response = await fetch(OAUTH_CONFIG.tokenUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "anthropic-beta": OAUTH_CONFIG.betaHeader,
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to exchange code for token: ${error}`);
    }

    const tokenData = (await response.json()) as any;
    return {
      ...tokenData,
      created_at: Date.now(),
    } as OAuthToken;
  }

  /**
   * Refresh access token using refresh token
   * @param refreshToken - The refresh token
   */
  static async refreshAccessToken(refreshToken: string): Promise<OAuthToken> {
    const response = await fetch(OAUTH_CONFIG.tokenUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "anthropic-beta": OAUTH_CONFIG.betaHeader,
      },
      body: JSON.stringify({
        grant_type: "refresh_token",
        refresh_token: refreshToken,
        client_id: OAUTH_CONFIG.clientId,
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to refresh token: ${error}`);
    }

    const tokenData = (await response.json()) as any;
    return {
      ...tokenData,
      created_at: Date.now(),
      // Keep the refresh token if not provided in response
      refresh_token: tokenData.refresh_token || refreshToken,
    } as OAuthToken;
  }

  /**
   * Authenticate with OAuth using manual code input
   * @param authCode - Authorization code in format "code#state" from Claude
   * @param codeVerifier - PKCE verifier from createAuthorizationUrl
   * @param expectedState - Expected state from createAuthorizationUrl
   */
  async authenticate(
    authCode: string,
    codeVerifier: string,
    expectedState: string
  ): Promise<OAuthToken> {
    // Exchange code for token
    const token = await ClaudeWebAuth.exchangeCodeForToken(
      authCode,
      codeVerifier,
      expectedState
    );

    // Store token
    await this.storage.set(token);

    return token;
  }

  /**
   * Get current token from storage
   */
  async getToken(): Promise<OAuthToken | null> {
    return this.storage.get();
  }

  /**
   * Get valid access token (refresh if needed)
   */
  async getValidToken(): Promise<string | null> {
    const token = await this.storage.get();

    if (!token) {
      return null;
    }

    // Check if expired (with 1 hour buffer)
    if (token.expires_in && token.created_at) {
      const expiresAt = token.created_at + token.expires_in * 1000;
      const isExpired = Date.now() > expiresAt - 60 * 60 * 1000;

      if (isExpired && token.refresh_token) {
        try {
          const newToken = await ClaudeWebAuth.refreshAccessToken(
            token.refresh_token
          );
          await this.storage.set(newToken);
          return newToken.access_token;
        } catch (error) {
          console.error("Failed to refresh token:", error);
          return null;
        }
      }
    }

    return token.access_token;
  }

  /**
   * Check if currently authenticated
   */
  async isAuthenticated(): Promise<boolean> {
    const token = await this.getValidToken();
    return token !== null;
  }

  /**
   * Clear stored token (logout)
   */
  async logout(): Promise<void> {
    await this.storage.remove();
  }

  /**
   * Verify token with API call
   */
  async verify(): Promise<boolean> {
    const accessToken = await this.getValidToken();
    if (!accessToken) {
      return false;
    }

    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          "anthropic-version": "2023-06-01",
          "anthropic-beta": "oauth-2025-04-20",
          Authorization: `Bearer ${accessToken}`,
          "X-API-Key": "",
        },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 10,
          system: "You are Claude Code, Anthropic's official CLI for Claude.",
          messages: [
            {
              role: "user",
              content: "Reply with OK only.",
            },
          ],
        }),
      });

      return response.ok;
    } catch {
      return false;
    }
  }
}

/**
 * Browser localStorage token storage
 * Only use this for non-sensitive applications or with additional security measures
 */
export class LocalStorageTokenStorage implements TokenStorage {
  constructor(private key: string = "claude_oauth_token") {}

  async get(): Promise<OAuthToken | null> {
    if (typeof window === "undefined" || !window.localStorage) {
      return null;
    }

    const data = localStorage.getItem(this.key);
    if (!data) return null;

    try {
      return JSON.parse(data);
    } catch {
      return null;
    }
  }

  async set(token: OAuthToken): Promise<void> {
    if (typeof window === "undefined" || !window.localStorage) {
      throw new Error("localStorage not available");
    }

    window.localStorage.setItem(this.key, JSON.stringify(token));
  }

  async remove(): Promise<void> {
    if (typeof window === "undefined" || !window.localStorage) {
      return;
    }

    window.localStorage.removeItem(this.key);
  }
}

/**
 * Cookie-based token storage (for server-side rendering)
 * Note: This is a basic implementation. In production, use secure, httpOnly cookies
 */
export class CookieTokenStorage implements TokenStorage {
  constructor(
    private getCookie: (name: string) => string | undefined,
    private setCookie: (name: string, value: string, options?: any) => void,
    private removeCookie: (name: string) => void,
    private cookieName: string = "claude_oauth_token"
  ) {}

  async get(): Promise<OAuthToken | null> {
    const data = this.getCookie(this.cookieName);
    if (!data) return null;

    try {
      return JSON.parse(data);
    } catch {
      return null;
    }
  }

  async set(token: OAuthToken): Promise<void> {
    this.setCookie(this.cookieName, JSON.stringify(token), {
      httpOnly: true,
      secure: true,
      sameSite: "lax",
      maxAge: 30 * 24 * 60 * 60, // 30 days
    });
  }

  async remove(): Promise<void> {
    this.removeCookie(this.cookieName);
  }
}



================================================
FILE: packages/auth/src/oauth.ts
================================================
import crypto from "crypto";
import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs/promises";
import path from "path";
import os from "os";
import readline from "readline";

const execAsync = promisify(exec);

// OAuth configuration
const OAUTH_CONFIG = {
  clientId: "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
  authorizationUrl: "https://claude.ai/oauth/authorize",
  tokenUrl: "https://console.anthropic.com/v1/oauth/token",
  redirectUri: "https://console.anthropic.com/oauth/code/callback",
  scope: "org:create_api_key user:profile user:inference",
  betaHeader: "oauth-2025-04-20",
};

// Token storage path
const TOKEN_PATH = path.join(os.homedir(), ".vibekit", "claude-oauth-token.json");

export interface OAuthToken {
  access_token: string;
  token_type: string;
  expires_in?: number;
  refresh_token?: string;
  scope?: string;
  created_at: number;
}

/**
 * Generate PKCE code verifier and challenge
 */
function generatePKCE() {
  const codeVerifier = crypto.randomBytes(32).toString("base64url");
  const codeChallenge = crypto
    .createHash("sha256")
    .update(codeVerifier)
    .digest("base64url");
  
  return { codeVerifier, codeChallenge };
}

/**
 * Generate random state for OAuth flow
 */
function generateState() {
  return crypto.randomBytes(32).toString("base64url");
}

/**
 * Prompt user for authentication code
 */
async function promptForAuthCode(): Promise<string> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    rl.question("Authentication Code: ", (answer) => {
      rl.close();
      resolve(answer);
    });
  });
}

/**
 * Exchange authorization code for access token
 */
async function exchangeCodeForToken(code: string, codeVerifier: string, state: string): Promise<OAuthToken> {
  const body = JSON.stringify({
    grant_type: "authorization_code",
    code,
    state,
    code_verifier: codeVerifier,
    redirect_uri: OAUTH_CONFIG.redirectUri,
    client_id: OAUTH_CONFIG.clientId,
  });
  
  const response = await fetch(OAUTH_CONFIG.tokenUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "anthropic-beta": OAUTH_CONFIG.betaHeader,
    },
    body,
  });
  
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Failed to exchange code for token: ${error}`);
  }
  
  const tokenData = await response.json() as any;
  return {
    ...tokenData,
    created_at: Date.now(),
  } as OAuthToken;
}

/**
 * Save token to disk
 */
export async function saveToken(token: OAuthToken): Promise<void> {
  const tokenDir = path.dirname(TOKEN_PATH);
  await fs.mkdir(tokenDir, { recursive: true });
  await fs.writeFile(TOKEN_PATH, JSON.stringify(token, null, 2));
  // Set restrictive permissions
  await fs.chmod(TOKEN_PATH, 0o600);
}

/**
 * Load token from disk
 */
export async function loadToken(): Promise<OAuthToken | null> {
  try {
    const tokenData = await fs.readFile(TOKEN_PATH, "utf-8");
    return JSON.parse(tokenData);
  } catch {
    return null;
  }
}

/**
 * Check if token is expired
 */
export function isTokenExpired(token: OAuthToken): boolean {
  if (!token.expires_in) return false;
  
  const expiresAt = token.created_at + token.expires_in * 1000;
  // Add 1 hour buffer (refresh an hour early)
  return Date.now() > expiresAt - 60 * 60 * 1000;
}

/**
 * Refresh access token
 */
export async function refreshToken(token: OAuthToken): Promise<OAuthToken> {
  if (!token.refresh_token) {
    throw new Error("No refresh token available");
  }
  
  const body = JSON.stringify({
    grant_type: "refresh_token",
    refresh_token: token.refresh_token,
    client_id: OAUTH_CONFIG.clientId,
  });
  
  const response = await fetch(OAUTH_CONFIG.tokenUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "anthropic-beta": OAUTH_CONFIG.betaHeader,
    },
    body,
  });
  
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Failed to refresh token: ${error}`);
  }
  
  const newTokenData = await response.json() as any;
  const newToken: OAuthToken = {
    ...newTokenData,
    created_at: Date.now(),
    // Keep refresh token if not provided in response
    refresh_token: newTokenData.refresh_token || token.refresh_token,
  };
  
  await saveToken(newToken);
  return newToken;
}

/**
 * Authenticate with Claude using OAuth
 */
export async function authenticate(): Promise<OAuthToken> {
  console.log("ðŸš€ Starting Claude OAuth authentication flow...");
  
  // Generate PKCE parameters
  const { codeVerifier, codeChallenge } = generatePKCE();
  const state = generateState();
  
  // Build authorization URL with ?code=true
  const authUrl = new URL(OAUTH_CONFIG.authorizationUrl);
  authUrl.searchParams.set("code", "true");
  authUrl.searchParams.set("client_id", OAUTH_CONFIG.clientId);
  authUrl.searchParams.set("response_type", "code");
  authUrl.searchParams.set("scope", OAUTH_CONFIG.scope);
  authUrl.searchParams.set("redirect_uri", OAUTH_CONFIG.redirectUri);
  authUrl.searchParams.set("code_challenge", codeChallenge);
  authUrl.searchParams.set("code_challenge_method", "S256");
  authUrl.searchParams.set("state", state);
  
  // Open browser
  console.log("\nðŸ“‚ Opening Claude authentication page in your browser...");
  const openCommand = process.platform === "darwin" 
    ? "open" 
    : process.platform === "win32" 
    ? "start" 
    : "xdg-open";
  
  try {
    await execAsync(`${openCommand} "${authUrl.toString()}"`);
  } catch (error) {
    console.error("Failed to open browser automatically.");
    console.log("Please open this URL manually:", authUrl.toString());
  }
  
  // Prompt user to paste authentication code
  console.log("\nðŸ“‹ Click 'Authorize', copy the Authentication Code, then paste it below.");
  console.log("");
  
  const pastedCode = await promptForAuthCode();
  
  // Parse code and state from pasted string (format: code#state)
  const [code, pastedState] = pastedCode.split("#");
  
  if (!code || !pastedState) {
    throw new Error("Invalid authentication code format. Expected: code#state");
  }
  
  if (pastedState !== state) {
    throw new Error("State mismatch. Authentication failed.");
  }
  
  // Exchange code for token
  console.log("\nðŸ”„ Exchanging code for access token...");
  const token = await exchangeCodeForToken(code, codeVerifier, state);
  
  // Save token
  await saveToken(token);
  
  console.log("âœ… Authentication successful! Token saved.");
  return token;
}

/**
 * Get valid access token (refresh if needed)
 */
export async function getValidToken(): Promise<string | null> {
  const token = await loadToken();
  
  if (!token) {
    return null;
  }
  
  if (isTokenExpired(token)) {
    try {
      const newToken = await refreshToken(token);
      return newToken.access_token;
    } catch (error) {
      console.error("Failed to refresh token:", error);
      return null;
    }
  }
  
  return token.access_token;
}

/**
 * Clear saved token
 */
export async function clearToken(): Promise<void> {
  try {
    await fs.unlink(TOKEN_PATH);
    console.log("âœ… OAuth token cleared.");
  } catch (error) {
    // Ignore if file doesn't exist
  }
}

/**
 * Exchange refresh token for new access token (for import)
 */
export async function refreshTokenToAccessToken(refreshTokenString: string): Promise<OAuthToken> {
  const body = JSON.stringify({
    grant_type: "refresh_token",
    refresh_token: refreshTokenString,
    client_id: OAUTH_CONFIG.clientId,
  });
  
  const response = await fetch(OAUTH_CONFIG.tokenUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "anthropic-beta": OAUTH_CONFIG.betaHeader,
    },
    body,
  });
  
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Failed to exchange refresh token: ${error}`);
  }
  
  const tokenData = await response.json() as any;
  return {
    ...tokenData,
    created_at: Date.now(),
    refresh_token: tokenData.refresh_token || refreshTokenString,
  } as OAuthToken;
}


================================================
FILE: packages/cli/README.md
================================================
# Vibekit CLI

A CLI middleware for headless and TUI coding agents that provides logging and sandbox capabilities.

## Overview

Vibekit CLI wraps existing coding agents like Claude Code CLI, Gemini CLI, and others to provide:

- **Docker Security**: Agents run in isolated containers with no host system access
- **Logging**: Capture all agent interactions and commands
- **Safe Sandboxing**: Complete isolation with resource limits and network restrictions
- **Unified Interface**: Single CLI for multiple coding agents

## Installation

```bash
npm install -g vibekit-cli
```

Or install locally:

```bash
npm install
npm link
```

## Usage

### Basic Commands

```bash
# Run Claude with local sandbox (default, no dependencies required)
vibekit claude

# Run with different sandbox types
vibekit claude --sandbox local        # File isolation (default, fast)
vibekit claude --sandbox docker       # Container isolation (requires Docker)
vibekit claude --sandbox none         # No sandbox (dangerous!)

# Allow network access
vibekit claude --network              # Enable network access

# Pass arguments to the underlying agent  
vibekit claude --help
vibekit claude "Fix the bug in src/app.js"

# View logs
vibekit logs
vibekit logs --agent claude --lines 100

# Open analytics dashboard
vibekit dashboard                     # Start dashboard and open in browser
vibekit status                        # View dashboard status

# Sync changes from sandbox back to your project
vibekit sync

# Clean up
vibekit clean
vibekit clean --logs
vibekit clean --docker
```

### Sandbox Options

**Local (Default - Fast & Simple):**
- âš¡ **Instant startup** - No dependencies required
- ðŸ“ **File isolation** - Protects your main project files
- ðŸ’» **Full terminal UI support** - Colors, TUI, interactive prompts  
- ðŸƒ **Fast execution** - No container overhead
- ðŸ”„ **Easy sync** - Changes isolated until you decide to apply them
- âœ… **Works everywhere** - No Docker installation needed

**Docker (Maximum Security):**
- ðŸ”’ **Complete container isolation** - Agents can't access host system
- ðŸ’» **Full terminal UI support** - Colors, TUI, interactive prompts
- ðŸš« **No host system access** - True containerization
- ðŸ“Š **Resource limits** - Configurable CPU/memory limits
- âš™ï¸ **Requires Docker** - Must have Docker installed

**None (Dangerous):**
- âš¡ **No overhead** - Direct execution
- âš ï¸ **No protection** - Agent has full system access
- ðŸš¨ **Only use with trusted agents**

### Logging

All agent interactions are logged to `~/.vibekit/logs/`:
- Commands executed
- Agent responses  
- Errors and debugging info
- Execution time and metadata

Enable debug logging:
```bash
VIBEKIT_DEBUG=1 vibekit claude
```

### Analytics Dashboard

Vibekit includes a built-in analytics dashboard that provides real-time insights into your coding sessions:

```bash
# Start dashboard and open in browser
vibekit dashboard

# Check dashboard status
vibekit status
```

**Dashboard Features:**
- ðŸ“Š **Session Analytics** - Track coding session duration and productivity
- ðŸ” **Command History** - View all executed commands and their outcomes  
- âš¡ **Real-time Updates** - Live monitoring of agent activity
- ðŸ“ˆ **Performance Metrics** - Analyze agent response times and success rates
- ðŸŽ¯ **Project Insights** - Understand file modification patterns

The dashboard runs on `http://localhost:3001` by default and provides a clean, modern interface for monitoring your AI-assisted coding workflows.

## Configuration

Config file location: `~/.vibekit/config.json`

```json
{
  "agents": {
    "claude": {
      "command": "claude", 
      "args": [],
      "env": {},
      "sandbox": {
        "enabled": true,
        "autoBackup": true,
        "autoSync": true
      }
    }
  },
  "logging": {
    "level": "info",
    "debug": false,
    "retention": {
      "days": 30,
      "maxFiles": 100
    }
  },
  "sandbox": {
    "defaultEnabled": true,
    "backupOnStart": true,
    "syncOnExit": true
  }
}
```

## Supported Agents

- **Claude Code CLI**: `vibekit claude`
- **Gemini CLI**: `vibekit gemini` 
- More agents can be easily added

## Development

```bash
git clone <repo>
cd vibekit-cli
npm install
npm link
```

## Architecture

```
vibekit-cli/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ cli.js              # Main CLI entry point
â”‚   â”œâ”€â”€ agents/             # Agent wrapper modules
â”‚   â”‚   â”œâ”€â”€ base.js         # Base agent class
â”‚   â”‚   â”œâ”€â”€ claude.js       # Claude Code CLI wrapper
â”‚   â”‚   â””â”€â”€ gemini.js       # Gemini CLI wrapper
â”‚   â”œâ”€â”€ logging/            # Logging system
â”‚   â”œâ”€â”€ sandbox/            # Sandbox functionality
â”‚   â””â”€â”€ config/             # Configuration management
â””â”€â”€ bin/vibekit             # Executable
```


================================================
FILE: packages/cli/Dockerfile
================================================
FROM oven/bun:1

# Install system dependencies including build tools for native modules
RUN apt-get update && apt-get install -y \
    bash \
    curl \
    wget \
    git \
    python3 \
    python3-pip \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Set up Bun environment
ENV BUN_INSTALL="/home/.bun"
ENV PATH="$BUN_INSTALL/bin:$PATH"

# Install coding agents globally
RUN bun add -g @anthropic-ai/claude-code@latest || echo "Claude CLI install failed"
RUN bun add -g @openai/codex@latest || echo "Codex CLI install failed"  
RUN bun add -g @google/gemini-cli@latest || echo "Gemini CLI install failed"
RUN bun add -g opencode-ai@latest || echo "OpenCode CLI install failed"
RUN bun add -g @vibe-kit/grok-cli@latest || echo "Grok CLI install failed"

# Try alternative Claude installation
RUN curl -sSL https://install.anthropic.com | bash || echo "Alternative Claude install failed"
ENV PATH="/root/.local/bin:$BUN_INSTALL/bin:$PATH"

# Install vibekit CLI globally and create symlink
RUN bun add -g vibekit || echo "Vibekit install failed"

# Create workspace directory
RUN mkdir -p /workspace
WORKDIR /workspace

# Expose common local development ports
EXPOSE 3001
EXPOSE 8080

# Keep container running for persistent use
CMD ["tail", "-f", "/dev/null"]


================================================
FILE: packages/cli/package.json
================================================
{
  "name": "vibekit",
  "version": "0.0.2-rc.9",
  "description": "Run Claude Code, Gemini, Codex â€” or any coding agent â€” in a clean, isolated sandbox with sensitive data redaction and observability baked in.",
  "main": "dist/cli.js",
  "type": "module",
  "bin": {
    "vibekit": "./dist/cli.js"
  },
  "files": [
    "dist/**/*",
    "Dockerfile"
  ],
  "scripts": {
    "build": "tsup",
    "dev": "tsup src/cli.js --watch",
    "start": "node dist/cli.js",
    "type-check": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage"
  },
  "keywords": [
    "cli",
    "coding-agents",
    "claude",
    "gemini",
    "sandbox",
    "logging"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@vibe-kit/auth": "^0.0.5",
    "vibekit-proxy": "latest",
    "cfonts": "^3.3.0",
    "chalk": "^5.3.0",
    "commander": "^11.0.0",
    "fs-extra": "^11.1.1",
    "ink": "^6.1.0",
    "ink-text-input": "^6.0.0",
    "js-yaml": "^4.1.0",
    "open": "^8.4.0",
    "react": "^19.1.1",
    "redact-pii": "^3.4.0"
  },
  "devDependencies": {
    "@types/node": "^24.1.0",
    "@vitest/coverage-v8": "^2.1.0",
    "@vitest/ui": "^2.1.0",
    "tsup": "^8.5.0",
    "typescript": "^5.9.2",
    "vitest": "^2.1.9"
  }
}



================================================
FILE: packages/cli/tsup.config.ts
================================================
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/cli.js'],
  format: ['esm'],
  dts: false,
  splitting: false,
  sourcemap: true,
  clean: true,
  outDir: 'dist',
  target: 'node18',
  bundle: true,
  minify: false,
  shims: true,
  external: [],
  loader: {
    '.js': 'jsx'
  }
});


================================================
FILE: packages/cli/src/cli.js
================================================
#!/usr/bin/env node

import { Command } from 'commander';
import chalk from 'chalk';
import fs from 'fs-extra';
import path from 'path';
import os from 'os';
import { fileURLToPath } from 'url';
import ClaudeAgent from './agents/claude.js';
import GeminiAgent from './agents/gemini.js';
import CodexAgent from './agents/codex.js';
import CursorAgent from './agents/cursor.js';
import OpenCodeAgent from './agents/opencode.js';
import Logger from './logging/logger.js';
import Analytics from './analytics/analytics.js';
// Dashboard manager will be imported lazily when needed
import React from 'react';
import { render } from 'ink';
import Settings from './components/settings.js';
import { setupAliases } from './utils/aliases.js';
import SandboxEngine from './sandbox/sandbox-engine.js';
import { setupProxySettings } from './utils/claude-settings.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const pkg = JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8'));

const program = new Command();

// Settings cache to avoid repeated file I/O
let settingsCache = null;
let settingsCacheTime = 0;
const SETTINGS_CACHE_TTL = 30000; // 30 seconds cache


// Function to read user settings with caching
async function readSettings() {
  const now = Date.now();
  
  // Return cached settings if still valid
  if (settingsCache && (now - settingsCacheTime) < SETTINGS_CACHE_TTL) {
    return settingsCache;
  }
  
  const settingsPath = path.join(os.homedir(), '.vibekit', 'settings.json');
  const defaultSettings = {
    sandbox: { enabled: false, type: 'docker' },
    analytics: { enabled: true },
    aliases: { enabled: false }
  };
  
  try {
    if (await fs.pathExists(settingsPath)) {
      const userSettings = await fs.readJson(settingsPath);
      settingsCache = { ...defaultSettings, ...userSettings };
    } else {
      settingsCache = defaultSettings;
    }
  } catch (error) {
    // Use default settings if reading fails
    settingsCache = defaultSettings;
  }
  
  settingsCacheTime = now;
  return settingsCache;
}

program
  .name('vibekit')
  .description('CLI middleware for headless and TUI coding agents')
  .version(pkg.version)
  .option('--proxy <url>', 'HTTP/HTTPS proxy URL for all agents (e.g., http://proxy.example.com:8080)');


program
  .command('claude')
  .description('Run Claude Code CLI')
  .option('-s, --sandbox', 'Enable sandbox mode')
  .option('--sandbox-type <type>', 'Sandbox type: docker, podman, none')
  .allowUnknownOption()
  .allowExcessArguments()
  .action(async (options, command) => {
    const logger = new Logger('claude');
    const settings = await readSettings();
    
    // Get proxy from global option or environment variable
    let proxy = command.parent.opts().proxy || process.env.HTTP_PROXY || process.env.HTTPS_PROXY;
    
    const agentOptions = {
      proxy: proxy,
      settings: settings,
      sandboxOptions: {
        sandbox: options.sandbox,
        sandboxType: options.sandboxType
      }
    };
    const agent = new ClaudeAgent(logger, agentOptions);
    
    
    const args = command.args || [];
    await agent.run(args);
  });

program
  .command('gemini')
  .description('Run Gemini CLI')
  .option('-s, --sandbox', 'Enable sandbox mode')
  .option('--sandbox-type <type>', 'Sandbox type: docker, podman, none')
  .allowUnknownOption()
  .allowExcessArguments()
  .action(async (options, command) => {
    const logger = new Logger('gemini');
    const settings = await readSettings();
    
    // Get proxy from global option or environment variable
    let proxy = command.parent.opts().proxy || process.env.HTTP_PROXY || process.env.HTTPS_PROXY;
    
    const agentOptions = {
      proxy: proxy,
      settings: settings,
      sandboxOptions: {
        sandbox: options.sandbox,
        sandboxType: options.sandboxType
      }
    };
    const agent = new GeminiAgent(logger, agentOptions);
    
    
    const args = command.args || [];
    await agent.run(args);
  });

program
  .command('codex')
  .description('Run Codex CLI')
  .option('-s, --sandbox', 'Enable sandbox mode')
  .option('--sandbox-type <type>', 'Sandbox type: docker, podman, none')
  .allowUnknownOption()
  .allowExcessArguments()
  .action(async (options, command) => {
    const logger = new Logger('codex');
    const settings = await readSettings();
    
    // Get proxy from global option or environment variable
    let proxy = command.parent.opts().proxy || process.env.HTTP_PROXY || process.env.HTTPS_PROXY;
    
    // Set OPENAI_BASE_URL for codex instead of ANTHROPIC_BASE_URL
    if (proxy) {
      process.env.OPENAI_BASE_URL = proxy;
    }
    
    const agentOptions = {
      proxy: proxy,
      settings: settings,
      sandboxOptions: {
        sandbox: options.sandbox,
        sandboxType: options.sandboxType
      }
    };
    const agent = new CodexAgent(logger, agentOptions);
    
    
    const args = command.args || [];
    await agent.run(args);
  });

program
  .command('cursor-agent')
  .description('Run Cursor Agent')
  .option('-s, --sandbox', 'Enable sandbox mode')
  .option('--sandbox-type <type>', 'Sandbox type: docker, podman, none')
  .allowUnknownOption()
  .allowExcessArguments()
  .action(async (options, command) => {
    const logger = new Logger('cursor');
    const settings = await readSettings();
    
    // Get proxy from global option or environment variable
    let proxy = command.parent.opts().proxy || process.env.HTTP_PROXY || process.env.HTTPS_PROXY;
    
    const agentOptions = {
      proxy: proxy,
      settings: settings,
      sandboxOptions: {
        sandbox: options.sandbox,
        sandboxType: options.sandboxType
      }
    };
    const agent = new CursorAgent(logger, agentOptions);
    
    
    const args = command.args || [];
    await agent.run(args);
  });

program
  .command('opencode')
  .description('Run OpenCode CLI')
  .option('-s, --sandbox', 'Enable sandbox mode')
  .option('--sandbox-type <type>', 'Sandbox type: docker, podman, none')
  .allowUnknownOption()
  .allowExcessArguments()
  .action(async (options, command) => {
    const logger = new Logger('opencode');
    const settings = await readSettings();
    
    // Get proxy from global option or environment variable
    let proxy = command.parent.opts().proxy || process.env.HTTP_PROXY || process.env.HTTPS_PROXY;
    
    const agentOptions = {
      proxy: proxy,
      settings: settings,
      sandboxOptions: {
        sandbox: options.sandbox,
        sandboxType: options.sandboxType
      }
    };
    const agent = new OpenCodeAgent(logger, agentOptions);
    
    
    const args = command.args || [];
    await agent.run(args);
  });

// Sandbox management commands
const sandboxCommand = program
  .command('sandbox')
  .description('Manage sandbox environment');

sandboxCommand
  .command('status')
  .description('Show sandbox status and configuration')
  .option('-s, --sandbox', 'Enable sandbox mode')
  .option('--sandbox-type <type>', 'Sandbox type: docker, podman, none')
  .action(async (options) => {
    const logger = new Logger('sandbox');
    const settings = await readSettings();
    
    const sandboxEngine = new SandboxEngine(process.cwd(), logger);
    const status = await sandboxEngine.getStatus({
      sandbox: options.sandbox,
      sandboxType: options.sandboxType
    }, settings);

    console.log(chalk.blue('ðŸ“¦ Sandbox Status'));
    console.log(chalk.gray('â”€'.repeat(50)));
    
    if (!status.enabled) {
      console.log(`Status: ${chalk.red('DISABLED')}`);
      console.log(chalk.gray('Use --sandbox flag or set VIBEKIT_SANDBOX=true to enable'));
    } else {
      console.log(`Status: ${chalk.green('ENABLED')}`);
      console.log(`Type: ${chalk.cyan(status.type)}`);
      console.log(`Source: ${chalk.gray(status.source)}`);
      
      if (status.runtime) {
        console.log(`Runtime: ${chalk.cyan(status.runtime)}`);
        console.log(`Available: ${status.available ? chalk.green('YES') : chalk.red('NO')}`);
        
        if (status.imageName) {
          console.log(`Image: ${chalk.gray(status.imageName)}`);
          console.log(`Image Exists: ${status.imageExists ? chalk.green('YES') : chalk.yellow('NO (will be built)')}`);
        }
        
        console.log(`Ready: ${status.ready ? chalk.green('YES') : chalk.yellow('NO')}`);
        
      }
    }
  });

sandboxCommand
  .command('build')
  .description('Build sandbox container image')
  .action(async () => {
    const logger = new Logger('sandbox');
    const DockerSandbox = (await import('./sandbox/docker-sandbox.js')).default;
    
    try {
      const sandbox = new DockerSandbox(process.cwd(), logger);
      await sandbox.buildImage();
      console.log(chalk.green('âœ… Sandbox image built successfully'));
    } catch (error) {
      console.error(chalk.red('âŒ Failed to build sandbox image:'), error.message);
      process.exit(1);
    }
  });

sandboxCommand
  .command('clean')
  .description('Clean up sandbox containers and images')
  .action(async (options) => {
    const { spawn } = await import('child_process');
    
    console.log(chalk.blue('ðŸ§¹ Cleaning sandbox resources...'));
    
    
    // Remove vibekit sandbox image
    const cleanup = spawn('docker', ['rmi', '-f', 'vibekit-sandbox:latest'], { stdio: 'ignore' });
    
    cleanup.on('close', (code) => {
      if (code === 0) {
        console.log(chalk.green('âœ… Sandbox resources cleaned'));
      } else {
        console.log(chalk.yellow('âš ï¸  Some resources may not have been cleaned (this is normal if they didn\'t exist)'));
      }
    });
    
    cleanup.on('error', () => {
      console.log(chalk.yellow('âš ï¸  Docker not available for cleanup'));
    });
  });


// Auth commands
const authCommand = program
  .command('auth')
  .description('Manage authentication');

// Import AuthHelperFactory for agent status checks
async function getAuthHelperFactory() {
  const { default: AuthHelperFactory } = await import('./auth/auth-helper-factory.js');
  return AuthHelperFactory;
}

authCommand
  .command('login <agent>')
  .description('Authenticate with specific agent (claude, codex, grok, gemini)')
  .action(async (agent) => {
    const supportedAgents = ['claude'];
    const plannedAgents = ['codex', 'grok', 'gemini'];
    
    if (!supportedAgents.includes(agent) && !plannedAgents.includes(agent)) {
      console.log(chalk.red(`âŒ Unknown agent: ${agent}`));
      console.log(chalk.gray('Supported agents: claude'));
      console.log(chalk.gray('Planned agents: codex, grok, gemini'));
      process.exit(1);
    }
    
    if (plannedAgents.includes(agent)) {
      console.log(chalk.red(`âŒ Authentication for ${agent} is not yet implemented.`));
      console.log(chalk.blue(`ðŸ’¡ This agent is planned for future release.`));
      console.log(chalk.gray(`ðŸ“– Visit https://docs.vibekit.dev/agents/${agent} for updates.`));
      process.exit(1);
    }
    
    // Handle Claude authentication
    if (agent === 'claude') {
      try {
        const { ClaudeAuth } = await import('@vibe-kit/auth/node');
        console.log(chalk.blue('ðŸš€ Starting Claude authentication...'));
        console.log(chalk.blue('ðŸŒ Opening browser for OAuth flow...'));
        await ClaudeAuth.authenticate();
        console.log(chalk.green('âœ… Authentication successful!'));
        console.log(chalk.gray('ðŸ“ Credentials saved to ~/.vibekit/claude-oauth-token.json'));
      } catch (error) {
        console.error(chalk.red('âŒ Authentication failed:'), error.message);
        process.exit(1);
      }
    }
  });

authCommand
  .command('status [agent]')
  .description('Show authentication status for all agents or specific agent')
  .action(async (agent) => {
    const AuthHelperFactory = await getAuthHelperFactory();
    const allAgents = ['claude', 'codex', 'grok', 'gemini'];
    
    console.log(chalk.blue('ðŸ” Authentication Status'));
    console.log(chalk.gray('â”€'.repeat(50)));
    
    if (agent) {
      // Show status for specific agent
      if (!allAgents.includes(agent)) {
        console.log(chalk.red(`âŒ Unknown agent: ${agent}`));
        process.exit(1);
      }
      
      const status = await AuthHelperFactory.getAuthStatus(agent);
      
      if (status.supported) {
        if (status.authenticated) {
          let statusLine = `âœ… ${agent}    ${chalk.green('Authenticated')}  (OAuth)`;
          if (status.expiresAt) {
            const expireStr = status.expiresAt.toLocaleString();
            statusLine += `     Expires: ${expireStr}`;
          }
          console.log(statusLine);
        } else {
          console.log(`âŒ ${agent}    ${chalk.red('Not authenticated')}     ${status.message}`);
        }
      } else {
        console.log(`ðŸš§ ${agent}    ${chalk.yellow('Implementation pending')}`);
      }
    } else {
      // Show status for all agents
      for (const agentName of allAgents) {
        const status = await AuthHelperFactory.getAuthStatus(agentName);
        
        if (status.supported) {
          if (status.authenticated) {
            let statusLine = `âœ… ${agentName.padEnd(8)} ${chalk.green('Authenticated')}  (OAuth)`;
            if (status.expiresAt) {
              const expireStr = status.expiresAt.toLocaleString();
              statusLine += `     Expires: ${expireStr}`;
            }
            console.log(statusLine);
          } else {
            console.log(`âŒ ${agentName.padEnd(8)} ${chalk.red('Not authenticated')}     Run: vibekit auth login ${agentName}`);
          }
        } else {
          console.log(`ðŸš§ ${agentName.padEnd(8)} ${chalk.yellow('Implementation pending')}`);
        }
      }
      
      console.log('');
      console.log(chalk.blue('Commands:'));
      console.log(`  ${chalk.cyan('vibekit auth login <agent>')}    Authenticate with specific agent`);
      console.log(`  ${chalk.cyan('vibekit auth verify <agent>')}   Test authentication`);
      console.log(`  ${chalk.cyan('vibekit auth logout <agent>')}   Remove authentication`);
    }
  });

authCommand
  .command('verify <agent>')
  .description('Test authentication with API call for specific agent')
  .action(async (agent) => {
    const supportedAgents = ['claude'];
    
    if (!supportedAgents.includes(agent)) {
      console.log(chalk.red(`âŒ Authentication verification for ${agent} is not yet implemented.`));
      process.exit(1);
    }
    
    if (agent === 'claude') {
      try {
        const { ClaudeAuth } = await import('@vibe-kit/auth/node');
        console.log(chalk.blue('ðŸ§ª Testing Claude authentication...'));
        
        const result = await ClaudeAuth.verifyWithDetails();
        
        if (result.success) {
          console.log(chalk.green('âœ… Claude authentication verified successfully!'));
          console.log(`Response: ${chalk.gray(result.response)}`);
        } else {
          console.log(chalk.red('âŒ Claude authentication verification failed'));
          console.log(`Error: ${chalk.gray(result.error)}`);
          if (result.status) {
            console.log(`Status: ${chalk.gray(result.status)}`);
          }
        }
      } catch (error) {
        console.error(chalk.red('âŒ Verification failed:'), error.message);
        process.exit(1);
      }
    }
  });

authCommand
  .command('logout <agent>')
  .description('Clear stored authentication for specific agent')
  .option('--all', 'Logout all agents')
  .action(async (agent, options) => {
    const supportedAgents = ['claude'];
    
    if (options.all) {
      console.log(chalk.blue('ðŸšª Logging out all agents...'));
      
      // Logout Claude
      try {
        const { ClaudeAuth } = await import('@vibe-kit/auth/node');
        await ClaudeAuth.logout();
        console.log(chalk.green('âœ… Claude logged out successfully'));
      } catch (error) {
        console.log(chalk.yellow('âš ï¸  Claude logout failed:'), error.message);
      }
      
      console.log(chalk.green('âœ… All available agents logged out'));
      return;
    }
    
    if (!supportedAgents.includes(agent)) {
      console.log(chalk.red(`âŒ Logout for ${agent} is not yet implemented.`));
      process.exit(1);
    }
    
    if (agent === 'claude') {
      try {
        const { ClaudeAuth } = await import('@vibe-kit/auth/node');
        await ClaudeAuth.logout();
        console.log(chalk.green('âœ… Claude logged out successfully'));
      } catch (error) {
        console.error(chalk.red('âŒ Logout failed:'), error.message);
        process.exit(1);
      }
    }
  });

authCommand
  .command('import <agent>')
  .description('Import authentication token for specific agent')
  .option('--token <token>', 'Import access token directly')
  .option('--env', 'Import from environment variable')
  .option('--file <path>', 'Import from JSON file')
  .action(async (agent, options) => {
    const supportedAgents = ['claude'];
    
    if (!supportedAgents.includes(agent)) {
      console.log(chalk.red(`âŒ Token import for ${agent} is not yet implemented.`));
      process.exit(1);
    }
    
    if (agent === 'claude') {
      try {
        const { ClaudeAuth } = await import('@vibe-kit/auth/node');
        
        if (options.token) {
          await ClaudeAuth.importToken({ accessToken: options.token });
          console.log(chalk.green('âœ… Claude token imported successfully'));
        } else if (options.env) {
          await ClaudeAuth.importToken({ fromEnv: true });
          console.log(chalk.green('âœ… Claude token imported from CLAUDE_CODE_OAUTH_TOKEN environment variable'));
        } else if (options.file) {
          await ClaudeAuth.importToken({ fromFile: options.file });
          console.log(chalk.green('âœ… Claude token imported from file'));
        } else {
          console.log(chalk.yellow('Please specify import source: --token, --env, or --file'));
          console.log(chalk.gray('Example: vibekit auth import claude --token your-oauth-token'));
        }
      } catch (error) {
        console.error(chalk.red('âŒ Import failed:'), error.message);
        process.exit(1);
      }
    }
  });

program
  .command('logs')
  .description('View vibekit logs')
  .option('-a, --agent <agent>', 'Filter logs by agent (claude, gemini)')
  .option('-n, --lines <number>', 'Number of recent lines to show', '50')
  .action(async (options) => {
    const logger = new Logger();
    await logger.viewLogs(options);
  });




// Dashboard commands
const dashboardCommand = program
  .command('dashboard')
  .description('Manage analytics dashboard');

dashboardCommand
  .command('start')
  .description('Start analytics dashboard server')
  .option('-p, --port <number>', 'Port to run dashboard on', '3001')
  .option('--open', 'Open dashboard in browser automatically')
  .action(async (options) => {
    const port = parseInt(options.port) || 3001;
    const { default: dashboardManager } = await import('./dashboard/manager.ts');
    const dashboardServer = dashboardManager.getDashboardServer(port);
    
    try {
      await dashboardServer.start();
      
      if (options.open) {
        await dashboardServer.openInBrowser();
      }
    } catch (error) {
      console.error(chalk.red('Failed to start dashboard:'), error.message);
      process.exit(1);
    }
  });

// Default action for 'dashboard' without subcommand - start the server and open browser
dashboardCommand
  .option('-p, --port <number>', 'Port to run dashboard on', '3001')
  .option('--no-open', 'Do not open browser automatically')
  .action(async (options, command) => {
    // If no subcommand was provided, start the dashboard with default settings
    if (command.args.length === 0) {
      const port = parseInt(options.port) || 3001;
      const { default: dashboardManager } = await import('./dashboard/manager.ts');
      const dashboardServer = dashboardManager.getDashboardServer(port);
      
      try {
        await dashboardServer.start();
        
        // Open browser by default unless --no-open is specified
        if (options.open !== false) {
          await dashboardServer.openInBrowser();
        }
      } catch (error) {
        console.error(chalk.red('Failed to start dashboard:'), error.message);
        process.exit(1);
      }
    }
  });

dashboardCommand
  .command('stop')
  .description('Stop analytics dashboard server')
  .option('-p, --port <number>', 'Port to stop dashboard on', '3001')
  .action(async (options) => {
    const port = parseInt(options.port) || 3001;
    const { default: dashboardManager } = await import('./dashboard/manager.ts');
    dashboardManager.stop(port);
    console.log(chalk.green(`âœ… Dashboard stopped on port ${port}`));
  });

dashboardCommand
  .command('update')
  .description('Update the dashboard to the latest version')
  .action(async () => {
    const { default: dashboardManager } = await import('./dashboard/manager.ts');
    const dashboardServer = dashboardManager.getDashboardServer(3001);
    
    try {
      await dashboardServer.update();
    } catch (error) {
      console.error(chalk.red('Failed to update dashboard:'), error.message);
      process.exit(1);
    }
  });


program
  .command('setup-aliases')
  .description('Install or remove global aliases based on settings')
  .action(async () => {
    const settings = await readSettings();
    await setupAliases(settings.aliases.enabled);
  });

program
  .command('diagnose-aliases')
  .description('Diagnose alias setup and conflicts')
  .action(async () => {
    const { checkAliasesInCurrentShell } = await import('./utils/aliases.js');
    const settings = await readSettings();
    
    console.log(chalk.blue('ðŸ” VibeKit Alias Diagnosis'));
    console.log(chalk.gray('â”€'.repeat(50)));
    
    console.log(`Settings enabled: ${settings.aliases.enabled ? chalk.green('âœ“ YES') : chalk.red('âœ— NO')}`);
    
    // Check if vibekit command exists
    try {
      const { spawn } = await import('child_process');
      const vibekitCheck = spawn('which', ['vibekit'], { stdio: 'pipe' });
      let vibekitPath = '';
      
      vibekitCheck.stdout.on('data', (data) => {
        vibekitPath += data.toString().trim();
      });
      
      await new Promise((resolve) => {
        vibekitCheck.on('close', (code) => {
          if (code === 0 && vibekitPath) {
            console.log(`VibeKit command: ${chalk.green('âœ“ FOUND')} at ${vibekitPath}`);
          } else {
            console.log(`VibeKit command: ${chalk.red('âœ— NOT FOUND')}`);
            console.log(chalk.yellow('  Try: npm install -g @vibe-kit/cli'));
          }
          resolve();
        });
      });
    } catch (error) {
      console.log(`VibeKit command: ${chalk.red('âœ— ERROR')} - ${error.message}`);
    }
    
    // Check current shell aliases
    const shellWorking = await checkAliasesInCurrentShell();
    console.log(`Shell aliases: ${shellWorking ? chalk.green('âœ“ WORKING') : chalk.red('âœ— NOT WORKING')}`);
    
    if (!shellWorking) {
      console.log(chalk.yellow('\nðŸ’¡ To fix alias issues:'));
      console.log(chalk.yellow('   1. Run: vibekit (enable aliases)'));
      console.log(chalk.yellow('   2. Restart terminal or run: source ~/.zshrc'));
      console.log(chalk.yellow('   3. Test with: claude --help'));
    }
    
    // Show current aliases
    try {
      const { spawn } = await import('child_process');
      const aliasCheck = spawn('bash', ['-c', 'alias | grep -E "(claude|gemini)"'], { stdio: 'pipe' });
      let aliasOutput = '';
      
      aliasCheck.stdout.on('data', (data) => {
        aliasOutput += data.toString();
      });
      
      await new Promise((resolve) => {
        aliasCheck.on('close', () => {
          if (aliasOutput.trim()) {
            console.log(chalk.blue('\nðŸ“‹ Current aliases:'));
            console.log(aliasOutput.trim());
          }
          resolve();
        });
      });
    } catch (error) {
      // Ignore alias check errors
    }
  });

program
  .command('analytics')
  .description('View agent analytics and usage statistics')
  .option('-a, --agent <agent>', 'Filter analytics by agent (claude, gemini)')
  .option('-d, --days <number>', 'Number of days to include', '7')
  .option('--summary', 'Show summary statistics only')
  .option('--export <file>', 'Export analytics to JSON file')
  .action(async (options) => {
    try {
      const days = parseInt(options.days) || 7;
      const analytics = await Analytics.getAnalytics(options.agent, days);
      
      if (analytics.length === 0) {
        console.log(chalk.yellow('No analytics data found'));
        return;
      }
      
      if (options.export) {
        await fs.writeFile(options.export, JSON.stringify(analytics, null, 2));
        console.log(chalk.green(`âœ“ Analytics exported to ${options.export}`));
        return;
      }
      
      const summary = Analytics.generateSummary(analytics);
      
      console.log(chalk.blue('ðŸ“Š Agent Analytics Summary'));
      console.log(chalk.gray('â”€'.repeat(50)));
      
      console.log(`Total Sessions: ${chalk.cyan(summary.totalSessions)}`);
      console.log(`Total Duration: ${chalk.cyan(Math.round(summary.totalDuration / 1000))}s`);
      console.log(`Average Duration: ${chalk.cyan(Math.round(summary.averageDuration / 1000))}s`);
      console.log(`Success Rate: ${chalk.cyan(summary.successRate.toFixed(1))}%`);
      console.log(`Files Changed: ${chalk.cyan(summary.totalFilesChanged)}`);
      console.log(`Total Errors: ${chalk.cyan(summary.totalErrors)}`);
      console.log(`Total Warnings: ${chalk.cyan(summary.totalWarnings)}`);
      
      if (Object.keys(summary.agentBreakdown).length > 1) {
        console.log(chalk.blue('\nðŸ¤– Agent Breakdown'));
        console.log(chalk.gray('â”€'.repeat(50)));
        
        Object.entries(summary.agentBreakdown).forEach(([agentName, stats]) => {
          console.log(chalk.yellow(`${agentName}:`));
          console.log(`  Sessions: ${stats.sessions}`);
          console.log(`  Avg Duration: ${Math.round(stats.averageDuration / 1000)}s`);
          console.log(`  Success Rate: ${stats.successRate.toFixed(1)}%`);
        });
      }
      
      if (summary.topErrors.length > 0) {
        console.log(chalk.blue('\nâŒ Top Errors'));
        console.log(chalk.gray('â”€'.repeat(50)));
        
        summary.topErrors.forEach(({ error, count }) => {
          console.log(`${chalk.red(count)}x ${error.substring(0, 80)}${error.length > 80 ? '...' : ''}`);
        });
      }
      
      if (!options.summary) {
        console.log(chalk.blue('\nðŸ“‹ Recent Sessions'));
        console.log(chalk.gray('â”€'.repeat(50)));
        
        analytics.slice(0, 10).forEach(session => {
          const date = new Date(session.startTime).toLocaleString();
          const duration = Math.round((session.duration || 0) / 1000);
          const status = session.exitCode === 0 ? chalk.green('âœ“') : chalk.red('âœ—');
          
          console.log(`${status} ${chalk.cyan(session.agentName)} ${chalk.gray(date)} ${duration}s`);
          
          if (session.filesChanged && session.filesChanged.length > 0) {
            console.log(chalk.gray(`   Files: ${session.filesChanged.slice(0, 3).join(', ')}${session.filesChanged.length > 3 ? '...' : ''}`));
          }
          
          if (session.errors && session.errors.length > 0) {
            console.log(chalk.red(`   Errors: ${session.errors.length}`));
          }
        });
      }
      
    } catch (error) {
      console.error(chalk.red('Failed to retrieve analytics:'), error.message);
    }
  });

program
  .command('clean')
  .description('Clean logs and analytics')
  .option('--logs', 'Clean logs only')
  .option('--analytics', 'Clean analytics data only')
  .action(async (options) => {
    const logger = new Logger();
    
    if (options.logs || (!options.logs && !options.analytics)) {
      await logger.cleanLogs();
      console.log(chalk.green('âœ“ Logs cleaned'));
    }
    
    if (options.analytics || (!options.logs && !options.analytics)) {
      const os = await import('os');
      const analyticsDir = path.join(os.homedir(), '.vibekit', 'analytics');
      if (await fs.pathExists(analyticsDir)) {
        await fs.remove(analyticsDir);
        console.log(chalk.green('âœ“ Analytics cleaned'));
      }
    }
  });

// Show welcome screen when just 'vibekit' is typed
if (process.argv.length === 2) {
  render(React.createElement(Settings, { showWelcome: true }));
} else {
  program.parseAsync(process.argv).catch(error => {
    console.error(chalk.red('Error:'), error.message);
    process.exit(1);
  });
}


================================================
FILE: packages/cli/src/agents/base.js
================================================
import { spawn } from 'child_process';
import chalk from 'chalk';
import path from 'path';
import StatusDisplay from '../components/status-display.js';
import React from 'react';
import { render, Static } from 'ink';
import Analytics from '../analytics/analytics.js';
import fs from 'fs-extra';
import crypto from 'crypto';
import SandboxEngine from '../sandbox/sandbox-engine.js';
import SandboxConfig from '../sandbox/sandbox-config.js';

class BaseAgent {
  constructor(agentName, logger, options = {}) {
    this.agentName = agentName;
    this.logger = logger;
    
    // Proxy options
    this.proxy = options.proxy;
    
    // Settings for display
    this.settings = options.settings || {};
    
    // Sandbox options
    this.sandboxOptions = options.sandboxOptions || {};
    this.sandboxEngine = new SandboxEngine(process.cwd(), logger, {
      env: { ...process.env, HTTP_PROXY: this.proxy, HTTPS_PROXY: this.proxy }
    });
  }



  async run(args) {
    await this.logger.log('info', `Starting ${this.agentName} agent`, { 
      args
    });

    // Show status display on host before execution
    await this.showStatusDisplay();

    try {
      // Check if we're already inside a sandbox to prevent double execution
      if (process.env.VIBEKIT_SANDBOX_ACTIVE) {
        // We're already inside a sandbox, run directly
        return await this.runDirect(args);
      }

      // Try sandbox execution first
      const sandboxResult = await this.sandboxEngine.executeWithSandbox(
        this.getAgentCommand(),
        args,
        this.sandboxOptions,
        this.settings,
        this.agentName  // Pass agent name for simplified auth
      );

      // If sandbox execution succeeded, return result with analytics
      if (sandboxResult) {
        return await this.runWithAnalytics(this.getAgentCommand(), args, () => Promise.resolve(sandboxResult), 'sandbox');
      }

      // Otherwise, fall back to direct execution
      return await this.runDirect(args);
    } catch (error) {
      await this.logger.log('error', `${this.agentName} agent failed`, { 
        error: error.message,
        args
      });
      throw error;
    }
  }




  async showStatusDisplay() {
    // Get sandbox config for status display
    const sandboxConfig = await SandboxConfig.resolveSandboxConfig(this.sandboxOptions, this.settings);
    
    // Show status display and keep it visible
    render(React.createElement(Static, { items: [{ 
      key: 'status-display',
      agentName: this.agentName,
      options: { proxy: this.proxy },
      settings: this.settings,
      sandboxConfig: sandboxConfig
    }] }, (item) => React.createElement(StatusDisplay, item)));
  }

  async runDirect(args) {
    const startTime = Date.now();
    const result = await this.createChildProcess(this.getAgentCommand(), args);
    const duration = Date.now() - startTime;

    await this.logger.log('info', `${this.agentName} agent completed`, { 
      exitCode: result.code,
      duration 
    });

    return { ...result, duration };
  }

  async runWithAnalytics(command, args, executionFunction, executionMode = 'local') {
    const startTime = Date.now();
    
    // Always capture optimized file snapshot for full analytics
    let beforeSnapshot;
    let currentSnapshot;
    
    // File change callback for periodic updates
    const fileChangeCallback = async () => {
      if (!beforeSnapshot) return null;
      
      try {
        const newSnapshot = await this.captureFileSnapshot();
        const changes = await this.detectFileChanges(currentSnapshot || beforeSnapshot, newSnapshot);
        currentSnapshot = newSnapshot;
        return changes;
      } catch (error) {
        console.warn('Failed to detect file changes during periodic check:', error.message);
        return null;
      }
    };
    
    const analytics = new Analytics(this.agentName, this.logger, fileChangeCallback, executionMode);
    
    // Start periodic logging (every minute by default, configurable via options)
    const logInterval = 60000; // 60 seconds default
    analytics.startPeriodicLogging(logInterval);
    
    // Capture the command being executed
    analytics.captureCommand(command, args);
    
    // Capture initial file snapshot
    try {
      beforeSnapshot = await this.captureFileSnapshot();
    } catch (error) {
      console.warn('Failed to capture initial file snapshot:', error.message);
    }

    try {
      // Execute the provided function (sandbox or direct)
      const result = await executionFunction();
      
      const duration = Date.now() - startTime;
      
      // Detect final file changes
      if (beforeSnapshot) {
        try {
          const afterSnapshot = await this.captureFileSnapshot();
          const fileChanges = await this.detectFileChanges(beforeSnapshot, afterSnapshot);
          
          // Capture file operations in analytics
          analytics.captureFileChanges(fileChanges.changes);
          analytics.captureFileOperations(fileChanges.created, fileChanges.deleted);
        } catch (error) {
          console.warn('Failed to detect file changes:', error.message);
        }
      }
      
      // Finalize analytics
      const analyticsData = await analytics.finalize(result.code || 0, duration);
      
      await this.logger.log('info', `${this.agentName} agent completed`, { 
        exitCode: result.code || 0,
        duration,
        analyticsData: analyticsData ? analyticsData.sessionId : null
      });
      
      return { ...result, duration, analyticsData };
    } catch (error) {
      const duration = Date.now() - startTime;
      
      // Finalize analytics with error
      await analytics.finalize(-1, duration);
      
      throw error;
    }
  }

  getAgentCommand() {
    // Override in subclasses
    return this.agentName;
  }

  async executeAgent(args) {
    throw new Error('executeAgent must be implemented by subclass');
  }

  async captureFileSnapshot(dir = process.cwd()) {
    const snapshot = new Map();
    
    // Skip expensive directories that rarely contain user-modified code
    const skipDirs = new Set([
      'node_modules', '.git', '.next', 'dist', 'build', '.cache', 
      'coverage', '.nyc_output', 'tmp', 'temp', '.vscode', '.idea',
      '__pycache__', '.pytest_cache', 'venv', 'env', '.env',
      'target', 'bin', 'obj', '.gradle', '.maven'
    ]);
    
    // Only track common source code file extensions
    const trackExtensions = new Set([
      '.js', '.jsx', '.ts', '.tsx', '.vue', '.svelte',
      '.py', '.rb', '.php', '.go', '.rs', '.java', '.kt',
      '.c', '.cpp', '.h', '.hpp', '.cs', '.swift',
      '.html', '.css', '.scss', '.sass', '.less',
      '.json', '.yaml', '.yml', '.xml', '.md', '.txt',
      '.sh', '.bash', '.zsh', '.fish', '.ps1',
      '.sql', '.graphql', '.proto', '.dockerfile'
    ]);
    
    const walkDir = async (dirPath, relativePath = '', depth = 0) => {
      // Limit depth to prevent excessive traversal
      if (depth > 8) return;
      
      try {
        const items = await fs.readdir(dirPath);
        
        for (const item of items) {
          if (item.startsWith('.') && item !== '.gitignore') continue;
          if (skipDirs.has(item)) continue;
          
          const itemPath = path.join(dirPath, item);
          const relativeItemPath = path.join(relativePath, item);
          const stat = await fs.stat(itemPath);
          
          if (stat.isDirectory()) {
            await walkDir(itemPath, relativeItemPath, depth + 1);
          } else {
            // Only track files with relevant extensions
            const ext = path.extname(item).toLowerCase();
            if (trackExtensions.has(ext) || item === 'Dockerfile' || item.endsWith('.env')) {
              // Use file stats (mtime + size) instead of reading content for speed
              // This is much faster and catches most meaningful changes
              const fingerprint = `${stat.mtime.getTime()}-${stat.size}`;
              snapshot.set(relativeItemPath, fingerprint);
            }
          }
        }
      } catch (error) {
        // Skip directories that can't be read
      }
    };

    await walkDir(dir);
    return snapshot;
  }

  async detectFileChanges(beforeSnapshot, afterSnapshot) {
    const changes = [];
    const created = [];
    const deleted = [];

    // Check for new and modified files
    for (const [filePath, hash] of afterSnapshot) {
      if (!beforeSnapshot.has(filePath)) {
        created.push(filePath);
        changes.push(filePath);
      } else if (beforeSnapshot.get(filePath) !== hash) {
        changes.push(filePath);
      }
    }

    // Check for deleted files
    for (const [filePath] of beforeSnapshot) {
      if (!afterSnapshot.has(filePath)) {
        deleted.push(filePath);
      }
    }

    return { changes, created, deleted };
  }

  createChildProcess(command, args, options = {}) {
    const startTime = Date.now();
    
    // Always capture optimized file snapshot for full analytics
    let beforeSnapshot;
    let currentSnapshot;
    
    // File change callback for periodic updates
    const fileChangeCallback = async () => {
      if (!beforeSnapshot) return null;
      
      try {
        const newSnapshot = await this.captureFileSnapshot();
        const changes = await this.detectFileChanges(currentSnapshot || beforeSnapshot, newSnapshot);
        currentSnapshot = newSnapshot;
        return changes;
      } catch (error) {
        console.warn('Failed to detect file changes during periodic check:', error.message);
        return null;
      }
    };
    
    const analytics = new Analytics(this.agentName, this.logger, fileChangeCallback, 'local');
    
    // Start periodic logging (every minute by default, configurable via options)
    const logInterval = options.analyticsInterval || 60000; // 60 seconds default
    analytics.startPeriodicLogging(logInterval);
    
    // Capture the command being executed
    analytics.captureCommand(command, args);
    
    // Determine if this is likely an interactive session
    const isInteractive = args.length === 0 && process.stdin.isTTY;
    
    // Using standard child process for all sessions
    
    return new Promise(async (resolve, reject) => {
      // Track if analytics have been finalized to prevent double finalization
      let analyticsFinalized = false;
      
      // Capture initial file snapshot asynchronously (don't block spawn)
      const captureSnapshot = async () => {
        try {
          beforeSnapshot = await this.captureFileSnapshot();
          currentSnapshot = beforeSnapshot;
        } catch (error) {
          console.warn('Failed to capture file snapshot:', error.message);
        }
      };
      
      // Start snapshot capture in background - don't await
      captureSnapshot();
      
      let spawnOptions;
      
      // Prepare environment variables with proxy settings
      const env = { 
        ...process.env, 
        ...options.env 
      };
      
      // Add proxy settings to environment if specified
      if (this.proxy) {
        env.HTTP_PROXY = this.proxy;
        env.HTTPS_PROXY = this.proxy;
        env.http_proxy = this.proxy;
        env.https_proxy = this.proxy;
        
        // Pass through VIBEKIT_PROXY_TARGET_URL for proxy server
        if (process.env.VIBEKIT_PROXY_TARGET_URL) {
          env.VIBEKIT_PROXY_TARGET_URL = process.env.VIBEKIT_PROXY_TARGET_URL;
        }
      }
      
      if (isInteractive) {
        // For interactive mode, use inherit stdio but still capture analytics
        spawnOptions = {
          stdio: 'inherit',
          cwd: options.cwd || process.cwd(),
          env,
          ...options
        };
      } else {
        // For non-interactive mode, capture streams for detailed analytics
        spawnOptions = {
          stdio: ['pipe', 'pipe', 'pipe'],
          cwd: options.cwd || process.cwd(),
          env,
          ...options
        };
      }
      
      const child = spawn(command, args, spawnOptions);

      if (!isInteractive) {
        // Only set up stream interception for non-interactive mode
        
        // Intercept and forward stdout
        child.stdout.on('data', (data) => {
          analytics.captureOutput(data);
          process.stdout.write(data);
        });

        // Intercept and forward stderr
        child.stderr.on('data', (data) => {
          analytics.captureOutput(data);
          process.stderr.write(data);
        });

        // Forward stdin to child process
        const stdinHandler = (data) => {
          analytics.captureInput(data);
          if (child.stdin && !child.stdin.destroyed) {
            child.stdin.write(data);
          }
        };

        process.stdin.on('data', stdinHandler);

        // Handle process end
        process.stdin.on('end', () => {
          if (child.stdin && !child.stdin.destroyed) {
            child.stdin.end();
          }
        });

        // Cleanup function for non-interactive mode
        const cleanup = () => {
          process.stdin.removeListener('data', stdinHandler);
        };

        child.on('close', async (code) => {
          cleanup();
          
          const duration = Date.now() - startTime;
          
          // Detect file changes
          let fileChanges = { changes: [], created: [], deleted: [] };
          if (beforeSnapshot) {
            try {
              const afterSnapshot = await this.captureFileSnapshot();
              fileChanges = await this.detectFileChanges(beforeSnapshot, afterSnapshot);
              
              // Capture file operations in analytics
              analytics.captureFileChanges(fileChanges.changes);
              analytics.captureFileOperations(fileChanges.created, fileChanges.deleted);
            } catch (error) {
              console.warn('Failed to detect file changes:', error.message);
            }
          }
          
          // Finalize analytics
          if (!analyticsFinalized) {
            analyticsFinalized = true;
            const analyticsData = await analytics.finalize(code, duration);
            
            resolve({
              code,
              duration,
              analytics: analyticsData,
              changes: fileChanges.changes
            });
          } else {
            resolve({
              code,
              duration,
              analytics: null,
              changes: fileChanges.changes
            });
          }
        });

        child.on('error', async (error) => {
          cleanup();
          
          console.error(chalk.red(`[vibekit] Process error: ${error.message}`));
          
          // Finalize analytics with error
          if (!analyticsFinalized) {
            analyticsFinalized = true;
            await analytics.finalize(-1, Date.now() - startTime);
          }
          
          reject(error);
        });
      } else {
        // For interactive mode, capture stderr for error analysis
        if (child.stderr) {
          child.stderr.on('data', (data) => {
            const output = data.toString();
            analytics.parseOutputForMetrics(output);
          });
        }
        
        child.on('close', async (code) => {
          const duration = Date.now() - startTime;
          
          // Detect file changes
          let fileChanges = { changes: [], created: [], deleted: [] };
          if (beforeSnapshot) {
            try {
              const afterSnapshot = await this.captureFileSnapshot();
              fileChanges = await this.detectFileChanges(beforeSnapshot, afterSnapshot);
              
              // Capture file operations in analytics
              analytics.captureFileChanges(fileChanges.changes);
              analytics.captureFileOperations(fileChanges.created, fileChanges.deleted);
            } catch (error) {
              console.warn('Failed to detect file changes:', error.message);
            }
          }
          
          // Finalize analytics
          if (!analyticsFinalized) {
            analyticsFinalized = true;
            const analyticsData = await analytics.finalize(code, duration);
            
            resolve({
              code,
              duration,
              analytics: analyticsData,
              changes: fileChanges.changes
            });
          } else {
            resolve({
              code,
              duration,
              analytics: null,
              changes: fileChanges.changes
            });
          }
        });

        child.on('error', async (error) => {
          console.error(chalk.red(`[vibekit] Process error: ${error.message}`));
          
          // Finalize analytics with error
          if (!analyticsFinalized) {
            analyticsFinalized = true;
            await analytics.finalize(-1, Date.now() - startTime);
          }
          
          reject(error);
        });
      }

      // Handle signals
      const signalHandler = (signal) => {
        return () => {
          // Kill child process
          child.kill(signal);
          
          // Force finalize analytics synchronously for immediate save
          if (!analyticsFinalized) {
            analyticsFinalized = true;
            const duration = Date.now() - startTime;
            try {
              analytics.finalizeSync(-1, duration);
            } catch (error) {
              console.error('Failed to finalize analytics on signal:', error);
            }
          }
          
          // Exit immediately
          process.exit(signal === 'SIGINT' ? 130 : 1);
        };
      };

      process.on('SIGINT', signalHandler('SIGINT'));
      process.on('SIGTERM', signalHandler('SIGTERM'));
      process.on('SIGHUP', signalHandler('SIGHUP'));
      
      // Handle unexpected exits
      process.on('beforeExit', (code) => {
        if (!analyticsFinalized) {
          analyticsFinalized = true;
          const duration = Date.now() - startTime;
          try {
            analytics.finalizeSync(code || 0, duration);
          } catch (error) {
            console.error('Failed to finalize analytics on beforeExit:', error);
          }
        }
      });
      
      // Handle process exit - last chance to save
      process.on('exit', (code) => {
        if (!analyticsFinalized) {
          analyticsFinalized = true;
          const duration = Date.now() - startTime;
          try {
            analytics.finalizeSync(code || 0, duration);
          } catch (error) {
            console.error('Failed to finalize analytics on exit:', error);
          }
        }
      });
      
      // Handle uncaught exceptions
      process.on('uncaughtException', (error) => {
        console.error('Uncaught exception:', error);
        if (!analyticsFinalized) {
          analyticsFinalized = true;
          const duration = Date.now() - startTime;
          try {
            analytics.finalizeSync(-1, duration);
          } catch (err) {
            console.error('Failed to finalize analytics on uncaught exception:', err);
          }
        }
        process.exit(1);
      });
      
      // Handle unhandled promise rejections
      process.on('unhandledRejection', (reason) => {
        console.error('Unhandled promise rejection:', reason);
        if (!analyticsFinalized) {
          analyticsFinalized = true;
          const duration = Date.now() - startTime;
          try {
            analytics.finalizeSync(-1, duration);
          } catch (error) {
            console.error('Failed to finalize analytics on unhandled rejection:', error);
          }
        }
        process.exit(1);
      });
    });
  }

}

export default BaseAgent;


================================================
FILE: packages/cli/src/agents/claude.js
================================================
import BaseAgent from './base.js';
import { spawn } from 'child_process';
import chalk from 'chalk';

class ClaudeAgent extends BaseAgent {
  constructor(logger, options = {}) {
    super('claude', logger, options);
  }

  getAgentCommand() {
    return 'claude';
  }

  async executeAgent(args, cwd) {
    const command = 'claude';
    
    try {
      return await this.createChildProcess(command, args, { cwd });
    } catch (error) {
      if (error.code === 'ENOENT') {
        console.error(chalk.red('Error: Claude CLI not found. Please install it first:'));
        console.error(chalk.yellow('  curl -sSL https://install.anthropic.com | bash'));
        console.error(chalk.yellow('  or visit: https://docs.anthropic.com/en/docs/claude-code'));
        process.exit(1);
      }
      throw error;
    }
  }

  async checkInstallation() {
    return new Promise((resolve) => {
      const child = spawn('claude', ['--version'], { stdio: 'ignore' });
      child.on('close', (code) => {
        resolve(code === 0);
      });
      child.on('error', () => {
        resolve(false);
      });
    });
  }
}

export default ClaudeAgent;


================================================
FILE: packages/cli/src/agents/codex.js
================================================
import BaseAgent from './base.js';
import { spawn } from 'child_process';
import chalk from 'chalk';

class CodexAgent extends BaseAgent {
  constructor(logger, options = {}) {
    super('codex', logger, options);
  }

  getAgentCommand() {
    return 'codex';
  }

  async executeAgent(args, cwd) {
    const command = 'codex';
    
    try {
      return await this.createChildProcess(command, args, { cwd });
    } catch (error) {
      if (error.code === 'ENOENT') {
        console.error(chalk.red('Error: Codex CLI not found. Please install it first:'));
        console.error(chalk.yellow('  npm install -g @openai/codex'));
        console.error(chalk.yellow('  or visit: https://github.com/openai/codex'));
        process.exit(1);
      }
      throw error;
    }
  }

  async checkInstallation() {
    return new Promise((resolve) => {
      const child = spawn('codex', ['--version'], { stdio: 'ignore' });
      child.on('close', (code) => {
        resolve(code === 0);
      });
      child.on('error', () => {
        resolve(false);
      });
    });
  }
}

export default CodexAgent;


================================================
FILE: packages/cli/src/agents/cursor.js
================================================
import BaseAgent from './base.js';
import { spawn } from 'child_process';
import chalk from 'chalk';

class CursorAgent extends BaseAgent {
  constructor(logger, options = {}) {
    super('cursor', logger, options);
  }

  getAgentCommand() {
    return 'cursor-agent';
  }

  async executeAgent(args, cwd) {
    const command = 'cursor-agent';
    
    // Modify args to append proxy URL to --endpoint flag if proxy is enabled
    const modifiedArgs = this.modifyArgsForProxy(args);
    
    try {
      return await this.createChildProcess(command, modifiedArgs, { cwd });
    } catch (error) {
      if (error.code === 'ENOENT') {
        console.error(chalk.red('Error: Cursor Agent not found. Please install it first:'));
        console.error(chalk.yellow('  npm install -g cursor-agent'));
        console.error(chalk.yellow('  or visit: https://cursor.com/agent'));
        process.exit(1);
      }
      throw error;
    }
  }

  modifyArgsForProxy(args) {
    // If proxy is not enabled, return args unchanged
    if (!this.proxy || !this.settings?.proxy?.enabled) {
      console.log('[cursor-agent] Proxy not enabled:', { 
        proxy: this.proxy, 
        proxyEnabled: this.settings?.proxy?.enabled 
      });
      return args;
    }

    console.log('[cursor-agent] Modifying args for proxy:', this.proxy);

    const modifiedArgs = [...args];
    let endpointIndex = -1;
    
    // Find --endpoint flag
    for (let i = 0; i < modifiedArgs.length; i++) {
      if (modifiedArgs[i] === '--endpoint' || modifiedArgs[i].startsWith('--endpoint=')) {
        endpointIndex = i;
        break;
      }
    }
    
    if (endpointIndex !== -1) {
      // --endpoint flag found, replace with proxy URL
      if (modifiedArgs[endpointIndex].startsWith('--endpoint=')) {
        // Format: --endpoint=value
        modifiedArgs[endpointIndex] = `--endpoint=${this.proxy}`;
      } else {
        // Format: --endpoint value (next argument)
        if (endpointIndex + 1 < modifiedArgs.length) {
          modifiedArgs[endpointIndex + 1] = this.proxy;
        } else {
          // --endpoint flag exists but no value provided, add proxy as value
          modifiedArgs.push(this.proxy);
        }
      }
    } else {
      // --endpoint flag not found, add it with proxy URL
      modifiedArgs.push('--endpoint', this.proxy);
    }
    
    console.log('[cursor-agent] Final args:', modifiedArgs);
    return modifiedArgs;
  }

  async checkInstallation() {
    return new Promise((resolve) => {
      const child = spawn('cursor-agent', ['--version'], { stdio: 'ignore' });
      child.on('close', (code) => {
        resolve(code === 0);
      });
      child.on('error', () => {
        resolve(false);
      });
    });
  }
}

export default CursorAgent;


================================================
FILE: packages/cli/src/agents/gemini.js
================================================
import BaseAgent from './base.js';
import { spawn } from 'child_process';
import chalk from 'chalk';

class GeminiAgent extends BaseAgent {
  constructor(logger, options = {}) {
    super('gemini', logger, options);
  }

  getAgentCommand() {
    return 'gemini';
  }

  async executeAgent(args, cwd) {
    const command = 'gemini';
    
    try {
      return await this.createChildProcess(command, args, { cwd });
    } catch (error) {
      if (error.code === 'ENOENT') {
        console.error(chalk.red('Error: Gemini CLI not found. Please install it first.'));
        console.error(chalk.yellow('  Installation instructions may vary depending on the Gemini CLI implementation'));
        process.exit(1);
      }
      throw error;
    }
  }

  async checkInstallation() {
    return new Promise((resolve) => {
      const child = spawn('gemini', ['--version'], { stdio: 'ignore' });
      child.on('close', (code) => {
        resolve(code === 0);
      });
      child.on('error', () => {
        resolve(false);
      });
    });
  }
}

export default GeminiAgent;


================================================
FILE: packages/cli/src/agents/opencode.js
================================================
import BaseAgent from './base.js';
import { spawn } from 'child_process';
import chalk from 'chalk';

class OpenCodeAgent extends BaseAgent {
  constructor(logger, options = {}) {
    super('opencode', logger, options);
  }

  getAgentCommand() {
    return 'opencode';
  }

  async executeAgent(args, cwd) {
    const command = 'opencode';
    
    try {
      return await this.createChildProcess(command, args, { cwd });
    } catch (error) {
      if (error.code === 'ENOENT') {
        console.error(chalk.red('Error: OpenCode CLI not found. Please install it first:'));
        console.error(chalk.yellow('  Visit: https://opencode.ai/'));
        console.error(chalk.yellow('  Or install via npm: npm install -g opencode'));
        process.exit(1);
      }
      throw error;
    }
  }

  async checkInstallation() {
    return new Promise((resolve) => {
      const child = spawn('opencode', ['--version'], { stdio: 'ignore' });
      child.on('close', (code) => {
        resolve(code === 0);
      });
      child.on('error', () => {
        resolve(false);
      });
    });
  }
}

export default OpenCodeAgent;


================================================
FILE: packages/cli/src/analytics/analytics.js
================================================
import fs from 'fs-extra';
import path from 'path';
import os from 'os';
import { collectSystemInfo } from './system-info.js';

class Analytics {
  constructor(agentName, logger, fileChangeCallback = null, executionMode = 'local') {
    this.agentName = agentName;
    this.logger = logger;
    this.sessionId = Date.now().toString();
    this.startTime = Date.now();
    this.fileChangeCallback = fileChangeCallback;
    
    // Analytics data
    this.metrics = {
      sessionId: this.sessionId,
      agentName: this.agentName,
      startTime: this.startTime,
      endTime: null,
      duration: null,
      status: 'active', // active, terminated
      executionMode: executionMode, // sandbox, local
      
      // Input/Output metrics
      inputBytes: 0,
      outputBytes: 0,
      
      // Command & process metrics
      commands: [],
      exitCode: null,
      
      // File system metrics
      filesChanged: [],
      filesCreated: [],
      filesDeleted: [],
      
      // Error tracking
      errors: [],
      warnings: [],
      
      // System information
      systemInfo: null,
    };
    
    // Stream buffers for analysis
    this.inputBuffer = '';
    this.outputBuffer = '';
    
    this.analyticsDir = path.join(os.homedir(), '.vibekit', 'analytics');
    this.periodicInterval = null;
    this.initializeAnalytics();
  }

  async initializeAnalytics() {
    await fs.ensureDir(this.analyticsDir);
    
    // Collect system info at session start
    try {
      this.metrics.systemInfo = await collectSystemInfo();
    } catch (error) {
      this.logger.log('warn', 'Failed to collect system info', { error: error.message });
      this.metrics.systemInfo = null;
    }
  }

  captureInput(data) {
    const input = data.toString();
    this.metrics.inputBytes += Buffer.byteLength(input, 'utf8');
    this.inputBuffer += input;
  }

  captureOutput(data) {
    const output = data.toString();
    this.metrics.outputBytes += Buffer.byteLength(output, 'utf8');
    this.outputBuffer += output;
    
    // Parse for specific patterns
    this.parseOutputForMetrics(output);
  }

  parseOutputForMetrics(output) {
    // Look for error patterns
    const errorPatterns = [
      /Error:/i,
      /Exception:/i,
      /Failed:/i,
      /âŒ/,
    ];

    errorPatterns.forEach(pattern => {
      if (pattern.test(output)) {
        const lines = output.split('\n');
        const errorLine = lines.find(line => pattern.test(line));
        if (errorLine && !this.metrics.errors.includes(errorLine.trim())) {
          this.metrics.errors.push(errorLine.trim());
        }
      }
    });

    // Look for warning patterns
    const warningPatterns = [
      /Warning:/i,
      /âš /,
      /WARN/i,
    ];

    warningPatterns.forEach(pattern => {
      if (pattern.test(output)) {
        const lines = output.split('\n');
        const warningLine = lines.find(line => pattern.test(line));
        if (warningLine && !this.metrics.warnings.includes(warningLine.trim())) {
          this.metrics.warnings.push(warningLine.trim());
        }
      }
    });
  }

  captureCommand(command, args) {
    this.metrics.commands.push({
      command,
      args: args || [],
      timestamp: Date.now()
    });
    
    // Also capture command args as input for token estimation
    if (args && args.length > 0) {
      const argsText = args.join(' ');
      this.captureInput(argsText);
    }
  }

  captureFileChanges(changes) {
    if (Array.isArray(changes)) {
      this.metrics.filesChanged = [...new Set([...this.metrics.filesChanged, ...changes])];
    }
  }

  captureFileOperations(created = [], deleted = []) {
    this.metrics.filesCreated = [...new Set([...this.metrics.filesCreated, ...created])];
    this.metrics.filesDeleted = [...new Set([...this.metrics.filesDeleted, ...deleted])];
  }

  startPeriodicLogging(intervalMs = 20000) {
    if (this.periodicInterval) {
      return;
    }
    
    this.periodicInterval = setInterval(async () => {
      await this.updateSession();
    }, intervalMs);
  }

  stopPeriodicLogging() {
    if (this.periodicInterval) {
      clearInterval(this.periodicInterval);
      this.periodicInterval = null;
    }
  }

  async updateSession() {
    const currentTime = Date.now();
    const currentDuration = currentTime - this.startTime;
    
    // Check for file changes if callback is provided
    if (this.fileChangeCallback) {
      try {
        const fileChanges = await this.fileChangeCallback();
        if (fileChanges) {
          this.captureFileChanges(fileChanges.changes);
          this.captureFileOperations(fileChanges.created, fileChanges.deleted);
        }
      } catch (error) {
        this.logger.log('warn', 'Failed to check file changes during periodic update', { error: error.message });
      }
    }
    
    // Update git status to reflect current state
    if (this.metrics.systemInfo) {
      try {
        const { collectSystemInfo } = await import('./system-info.js');
        const updatedSystemInfo = await collectSystemInfo();
        // Only update git-related fields to avoid overwriting other system info
        this.metrics.systemInfo.gitStatus = updatedSystemInfo.gitStatus;
        this.metrics.systemInfo.gitBranch = updatedSystemInfo.gitBranch;
      } catch (error) {
        this.logger.log('warn', 'Failed to update git status during periodic update', { error: error.message });
      }
    }
    
    const sessionUpdate = {
      ...this.metrics,
      currentTime,
      duration: currentDuration,
      endTime: null,
      exitCode: null
    };
    
    this.refineTokenCounts();
    
    return this.saveSessionUpdate(sessionUpdate);
  }

  async saveSessionUpdate(sessionData) {
    const date = new Date().toISOString().split('T')[0];
    const analyticsFile = path.join(this.analyticsDir, `${this.agentName}-${date}.json`);
    
    try {
      let existingData = [];
      if (await fs.pathExists(analyticsFile)) {
        const content = await fs.readFile(analyticsFile, 'utf8');
        existingData = JSON.parse(content);
      }
      
      // Find existing session and update it, or add new one
      const existingIndex = existingData.findIndex(s => s.sessionId === sessionData.sessionId);
      if (existingIndex >= 0) {
        existingData[existingIndex] = sessionData;
      } else {
        existingData.push(sessionData);
      }
      
      await fs.writeFile(analyticsFile, JSON.stringify(existingData, null, 2));
      
      // Log session update
      await this.logger.log('debug', 'Session analytics updated', {
        sessionId: sessionData.sessionId,
        duration: sessionData.duration,
        inputBytes: sessionData.inputBytes,
        outputBytes: sessionData.outputBytes,
        filesChanged: sessionData.filesChanged.length
      });
      
      return sessionData;
    } catch (error) {
      return null;
    }
  }

  async finalize(exitCode, duration) {
    this.stopPeriodicLogging();
    
    this.metrics.endTime = Date.now();
    this.metrics.duration = duration || (this.metrics.endTime - this.metrics.startTime);
    this.metrics.exitCode = exitCode;
    this.metrics.status = 'terminated';
    
    // Update git status one final time before saving
    if (this.metrics.systemInfo) {
      try {
        const { collectSystemInfo } = await import('./system-info.js');
        const updatedSystemInfo = await collectSystemInfo();
        this.metrics.systemInfo.gitStatus = updatedSystemInfo.gitStatus;
        this.metrics.systemInfo.gitBranch = updatedSystemInfo.gitBranch;
      } catch (error) {
        this.logger.log('warn', 'Failed to update git status during session finalization', { error: error.message });
      }
    }
    
    // Final token count refinement from buffers
    this.refineTokenCounts();
    
    return this.saveAnalytics();
  }

  // Synchronous version for emergency finalization (e.g., on process exit)
  finalizeSync(exitCode, duration) {
    this.stopPeriodicLogging();
    
    this.metrics.endTime = Date.now();
    this.metrics.duration = duration || (this.metrics.endTime - this.metrics.startTime);
    this.metrics.exitCode = exitCode;
    this.metrics.status = 'terminated';
    
    // Final token count refinement from buffers
    this.refineTokenCounts();
    
    return this.saveAnalyticsSync();
  }

  refineTokenCounts() {
    // More sophisticated analytics could be added here
    // For now, use the basic metrics we collect
  }

  async saveAnalytics() {
    const date = new Date().toISOString().split('T')[0];
    const analyticsFile = path.join(this.analyticsDir, `${this.agentName}-${date}.json`);
    
    try {
      let existingData = [];
      if (await fs.pathExists(analyticsFile)) {
        const content = await fs.readFile(analyticsFile, 'utf8');
        existingData = JSON.parse(content);
      }
      
      // Find existing session and update it, or add new one
      const existingIndex = existingData.findIndex(s => s.sessionId === this.metrics.sessionId);
      if (existingIndex >= 0) {
        existingData[existingIndex] = this.metrics;
      } else {
        existingData.push(this.metrics);
      }
      
      await fs.writeFile(analyticsFile, JSON.stringify(existingData, null, 2));
      
      // Also log analytics summary
      await this.logger.log('info', 'Analytics captured', {
        sessionId: this.metrics.sessionId,
        duration: this.metrics.duration,
        inputBytes: this.metrics.inputBytes,
        outputBytes: this.metrics.outputBytes,
        filesChanged: this.metrics.filesChanged.length,
        errors: this.metrics.errors.length,
        warnings: this.metrics.warnings.length,
        exitCode: this.metrics.exitCode,
        machineId: this.metrics.systemInfo?.machineId,
        nodeVersion: this.metrics.systemInfo?.nodeVersion,
        projectLanguage: this.metrics.systemInfo?.projectLanguage
      });
      
      return this.metrics;
    } catch (error) {
      return null;
    }
  }

  // Synchronous version for emergency saves (e.g., on process exit)
  saveAnalyticsSync() {
    const date = new Date().toISOString().split('T')[0];
    const analyticsFile = path.join(this.analyticsDir, `${this.agentName}-${date}.json`);
    
    try {
      let existingData = [];
      if (fs.pathExistsSync(analyticsFile)) {
        const content = fs.readFileSync(analyticsFile, 'utf8');
        existingData = JSON.parse(content);
      }
      
      // Find existing session and update it, or add new one
      const existingIndex = existingData.findIndex(s => s.sessionId === this.metrics.sessionId);
      if (existingIndex >= 0) {
        existingData[existingIndex] = this.metrics;
      } else {
        existingData.push(this.metrics);
      }
      
      fs.writeFileSync(analyticsFile, JSON.stringify(existingData, null, 2));
      
      return this.metrics;
    } catch (error) {
      return null;
    }
  }

  // Static method to read analytics
  static async getAnalytics(agentName = null, days = 7) {
    const analyticsDir = path.join(os.homedir(), '.vibekit', 'analytics');
    
    if (!await fs.pathExists(analyticsDir)) {
      return [];
    }
    
    const files = await fs.readdir(analyticsDir);
    const targetFiles = agentName 
      ? files.filter(f => f.startsWith(`${agentName}-`))
      : files.filter(f => f.endsWith('.json'));
    
    // Filter by date range
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    
    const allAnalytics = [];
    
    for (const file of targetFiles) {
      try {
        const filePath = path.join(analyticsDir, file);
        const content = await fs.readFile(filePath, 'utf8');
        const data = JSON.parse(content);
        
        const filteredData = data.filter(session => {
          const sessionDate = new Date(session.startTime);
          return sessionDate >= cutoffDate;
        });
        
        allAnalytics.push(...filteredData);
      } catch (error) {
      }
    }
    
    return allAnalytics.sort((a, b) => b.startTime - a.startTime);
  }

  // Static method to get active sessions count
  static getActiveSessions(analytics) {
    return analytics.filter(session => session.status === 'active').length;
  }

  // Static method to generate analytics summary
  static generateSummary(analytics) {
    if (analytics.length === 0) {
      return {
        totalSessions: 0,
        activeSessions: 0,
        totalDuration: 0,
        averageDuration: 0,
        successRate: 0,
        topErrors: [],
        agentBreakdown: {},
        platformBreakdown: {},
        nodeVersionBreakdown: {},
        projectLanguageBreakdown: {},
        terminalBreakdown: {}
      };
    }

    const summary = {
      totalSessions: analytics.length,
      activeSessions: analytics.filter(a => a.status === 'active').length,
      totalDuration: analytics.reduce((sum, a) => sum + (a.duration || 0), 0),
      successfulSessions: analytics.filter(a => a.exitCode === 0).length,
      totalFilesChanged: analytics.reduce((sum, a) => sum + (a.filesChanged?.length || 0), 0),
      totalErrors: analytics.reduce((sum, a) => sum + (a.errors?.length || 0), 0),
      totalWarnings: analytics.reduce((sum, a) => sum + (a.warnings?.length || 0), 0),
    };

    summary.averageDuration = summary.totalDuration / summary.totalSessions;
    summary.successRate = (summary.successfulSessions / summary.totalSessions) * 100;

    // Top errors
    const errorCounts = {};
    analytics.forEach(a => {
      a.errors?.forEach(error => {
        errorCounts[error] = (errorCounts[error] || 0) + 1;
      });
    });
    summary.topErrors = Object.entries(errorCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([error, count]) => ({ error, count }));

    // Agent breakdown
    const agentBreakdown = {};
    analytics.forEach(a => {
      if (!agentBreakdown[a.agentName]) {
        agentBreakdown[a.agentName] = {
          sessions: 0,
          duration: 0,
          successRate: 0
        };
      }
      const agent = agentBreakdown[a.agentName];
      agent.sessions++;
      agent.duration += a.duration || 0;
      if (a.exitCode === 0) agent.successfulSessions = (agent.successfulSessions || 0) + 1;
    });

    Object.keys(agentBreakdown).forEach(agentName => {
      const agent = agentBreakdown[agentName];
      agent.successRate = ((agent.successfulSessions || 0) / agent.sessions) * 100;
      agent.averageDuration = agent.duration / agent.sessions;
    });

    summary.agentBreakdown = agentBreakdown;

    // System environment breakdowns
    const createBreakdown = (field) => {
      const breakdown = {};
      analytics.forEach(a => {
        const value = a.systemInfo?.[field];
        if (value) {
          breakdown[value] = (breakdown[value] || 0) + 1;
        }
      });
      return breakdown;
    };

    summary.machineBreakdown = createBreakdown('machineId');
    summary.hostnameBreakdown = createBreakdown('hostname');
    summary.platformBreakdown = createBreakdown('platform');
    summary.nodeVersionBreakdown = createBreakdown('nodeVersion');
    summary.projectLanguageBreakdown = createBreakdown('projectLanguage');
    summary.terminalBreakdown = createBreakdown('terminal');

    return summary;
  }
}

export default Analytics;


================================================
FILE: packages/cli/src/analytics/system-info.js
================================================
import os from 'os';
import fs from 'fs-extra';
import path from 'path';
import { execSync } from 'child_process';
import crypto from 'crypto';

/**
 * Collects system information for analytics
 * @returns {Promise<Object>} System information object
 */
export async function collectSystemInfo() {
  const systemInfo = {
    // Essential System Info
    machineId: getMachineId(),
    hostname: os.hostname(),
    platform: os.platform(),
    arch: os.arch(),
    release: os.release(),
    totalMemory: os.totalmem(),
    cpuCores: os.cpus().length,
    
    // Development Environment
    nodeVersion: process.version,
    shell: process.env.SHELL,
    terminal: process.env.TERM_PROGRAM,
    gitVersion: await getGitVersion(),
    
    // Project Context
    projectName: await getProjectName(),
    projectLanguage: await detectProjectLanguage(),
    projectType: await detectProjectType(),
    gitBranch: await getGitBranch(),
    gitStatus: await getGitStatus(),
    projectFileCount: await getProjectFileCount(),
  };

  return systemInfo;
}

/**
 * Generate a consistent machine identifier based on hostname and hardware
 */
function getMachineId() {
  try {
    const hostname = os.hostname();
    const platform = os.platform();
    const arch = os.arch();
    const cpus = os.cpus();
    const totalMem = os.totalmem();
    
    // Create a consistent identifier from machine characteristics
    const machineString = `${hostname}-${platform}-${arch}-${cpus.length}-${totalMem}`;
    
    // Hash it to create a shorter, consistent identifier
    const hash = crypto.createHash('sha256').update(machineString).digest('hex');
    return hash.substring(0, 16); // First 16 characters for readability
  } catch (error) {
    // Fallback to hostname + random if anything fails
    const hostname = os.hostname() || 'unknown';
    return `${hostname}-${Date.now().toString(36)}`;
  }
}

/**
 * Get project name from various sources
 */
async function getProjectName() {
  const cwd = process.cwd();
  
  try {
    // Try package.json first
    const packageJsonPath = path.join(cwd, 'package.json');
    if (await fs.pathExists(packageJsonPath)) {
      const packageJson = await fs.readJson(packageJsonPath);
      if (packageJson.name) {
        return packageJson.name;
      }
    }
    
    // Try Cargo.toml
    const cargoTomlPath = path.join(cwd, 'Cargo.toml');
    if (await fs.pathExists(cargoTomlPath)) {
      const cargoContent = await fs.readFile(cargoTomlPath, 'utf8');
      const nameMatch = cargoContent.match(/^name\s*=\s*["']([^"']+)["']/m);
      if (nameMatch) {
        return nameMatch[1];
      }
    }
    
    // Try composer.json
    const composerJsonPath = path.join(cwd, 'composer.json');
    if (await fs.pathExists(composerJsonPath)) {
      const composerJson = await fs.readJson(composerJsonPath);
      if (composerJson.name) {
        return composerJson.name;
      }
    }
    
    // Try pyproject.toml
    const pyprojectPath = path.join(cwd, 'pyproject.toml');
    if (await fs.pathExists(pyprojectPath)) {
      const pyprojectContent = await fs.readFile(pyprojectPath, 'utf8');
      const nameMatch = pyprojectContent.match(/^name\s*=\s*["']([^"']+)["']/m);
      if (nameMatch) {
        return nameMatch[1];
      }
    }
    
    // Try git repository name (only if in a git repo)
    if (isGitRepository()) {
      try {
        const remoteUrl = execSync('git config --get remote.origin.url', { 
          encoding: 'utf8', 
          timeout: 5000,
          cwd: process.cwd()
        }).trim();
        
        // Extract repo name from various git URL formats
        const urlMatch = remoteUrl.match(/\/([^/]+?)(\.git)?$/);
        if (urlMatch && urlMatch[1]) {
          return urlMatch[1];
        }
      } catch (error) {
        // Git command failed, continue to fallback
      }
    }
    
    // Fallback to directory name
    return path.basename(cwd);
    
  } catch (error) {
    // Final fallback
    return path.basename(cwd) || 'unknown';
  }
}

/**
 * Get Git version if available
 */
async function getGitVersion() {
  try {
    const version = execSync('git --version', { encoding: 'utf8', timeout: 5000 });
    return version.trim();
  } catch (error) {
    return null;
  }
}

/**
 * Detect project language from common files
 */
async function detectProjectLanguage() {
  const cwd = process.cwd();
  
  const languageIndicators = [
    { file: 'package.json', language: 'JavaScript/Node.js' },
    { file: 'Cargo.toml', language: 'Rust' },
    { file: 'pyproject.toml', language: 'Python' },
    { file: 'requirements.txt', language: 'Python' },
    { file: 'pom.xml', language: 'Java' },
    { file: 'build.gradle', language: 'Java/Kotlin' },
    { file: 'go.mod', language: 'Go' },
    { file: 'composer.json', language: 'PHP' },
    { file: 'Gemfile', language: 'Ruby' },
    { file: 'mix.exs', language: 'Elixir' },
    { file: 'pubspec.yaml', language: 'Dart/Flutter' },
    { file: 'Program.cs', language: 'C#' },
    { file: 'CMakeLists.txt', language: 'C/C++' },
  ];

  for (const indicator of languageIndicators) {
    if (await fs.pathExists(path.join(cwd, indicator.file))) {
      return indicator.language;
    }
  }

  // Check for common file extensions if no config files found
  try {
    const files = await fs.readdir(cwd);
    const extensions = files.map(f => path.extname(f).toLowerCase()).filter(Boolean);
    const extCount = {};
    
    extensions.forEach(ext => {
      extCount[ext] = (extCount[ext] || 0) + 1;
    });
    
    const topExt = Object.entries(extCount).sort(([,a], [,b]) => b - a)[0];
    if (topExt) {
      const extLangMap = {
        '.js': 'JavaScript',
        '.ts': 'TypeScript',
        '.py': 'Python',
        '.rs': 'Rust',
        '.go': 'Go',
        '.java': 'Java',
        '.php': 'PHP',
        '.rb': 'Ruby',
        '.cpp': 'C++',
        '.c': 'C',
        '.cs': 'C#',
        '.swift': 'Swift',
        '.kt': 'Kotlin',
        '.dart': 'Dart',
      };
      return extLangMap[topExt[0]] || null;
    }
  } catch (error) {
    // Ignore errors when reading directory
  }

  return null;
}

/**
 * Detect project type from build tools/package managers
 */
async function detectProjectType() {
  const cwd = process.cwd();
  
  const typeIndicators = [
    { file: 'package.json', type: 'npm' },
    { file: 'yarn.lock', type: 'yarn' },
    { file: 'pnpm-lock.yaml', type: 'pnpm' },
    { file: 'Cargo.toml', type: 'cargo' },
    { file: 'pom.xml', type: 'maven' },
    { file: 'build.gradle', type: 'gradle' },
    { file: 'go.mod', type: 'go-modules' },
    { file: 'composer.json', type: 'composer' },
    { file: 'Gemfile', type: 'bundler' },
    { file: 'mix.exs', type: 'mix' },
    { file: 'requirements.txt', type: 'pip' },
    { file: 'pyproject.toml', type: 'poetry' },
    { file: 'Pipfile', type: 'pipenv' },
  ];

  for (const indicator of typeIndicators) {
    if (await fs.pathExists(path.join(cwd, indicator.file))) {
      return indicator.type;
    }
  }

  return null;
}

/**
 * Check if current directory is a git repository
 */
function isGitRepository() {
  try {
    execSync('git rev-parse --git-dir', { 
      encoding: 'utf8', 
      timeout: 5000,
      cwd: process.cwd(),
      stdio: 'ignore'
    });
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Get current git branch
 */
async function getGitBranch() {
  if (!isGitRepository()) {
    return null;
  }
  
  try {
    const branch = execSync('git rev-parse --abbrev-ref HEAD', { 
      encoding: 'utf8', 
      timeout: 5000,
      cwd: process.cwd()
    });
    return branch.trim();
  } catch (error) {
    return null;
  }
}

/**
 * Get git working tree status
 */
async function getGitStatus() {
  if (!isGitRepository()) {
    return null;
  }
  
  try {
    const status = execSync('git status --porcelain', { 
      encoding: 'utf8', 
      timeout: 5000,
      cwd: process.cwd()
    });
    return status.trim() === '' ? 'clean' : 'dirty';
  } catch (error) {
    return null;
  }
}

/**
 * Get approximate project file count (excluding common ignore patterns)
 */
async function getProjectFileCount() {
  try {
    const cwd = process.cwd();
    
    // Common patterns to ignore
    const ignorePatterns = [
      'node_modules',
      '.git',
      'target',
      'dist',
      'build',
      '.next',
      '.nuxt',
      '__pycache__',
      '.venv',
      'venv',
      '.DS_Store',
    ];

    async function countFiles(dir, depth = 0) {
      if (depth > 3) return 0; // Limit depth to avoid deep traversal
      
      let count = 0;
      try {
        const entries = await fs.readdir(dir, { withFileTypes: true });
        
        for (const entry of entries) {
          if (ignorePatterns.some(pattern => entry.name.includes(pattern))) {
            continue;
          }
          
          if (entry.isFile()) {
            count++;
          } else if (entry.isDirectory()) {
            count += await countFiles(path.join(dir, entry.name), depth + 1);
          }
        }
      } catch (error) {
        // Ignore permission errors or other issues
      }
      
      return count;
    }

    return await countFiles(cwd);
  } catch (error) {
    return null;
  }
}


================================================
FILE: packages/cli/src/auth/auth-helper-factory.js
================================================
import ClaudeAuthHelper from './claude-auth-helper.js';

/**
 * Factory for creating agent-specific auth helpers.
 * Implements early detection pattern to avoid unnecessary processing.
 */
export class AuthHelperFactory {
  
  /**
   * Get auth helper for agent if supported and has credentials
   * @param {string} agentName - Name of the agent
   * @returns {Promise<Object|null>} Auth helper class or null
   */
  static async getAuthHelper(agentName) {
    switch (agentName) {
      case 'claude':
        if (await ClaudeAuthHelper.hasCredentials()) {
          return ClaudeAuthHelper;
        }
        return null;
        
      // Future agents can be added here:
      // case 'gemini':
      //   if (await GeminiAuthHelper.hasCredentials()) {
      //     return GeminiAuthHelper;
      //   }
      //   return null;
        
      default:
        return null;
    }
  }
  
  /**
   * Check if agent supports authentication
   * @param {string} agentName - Name of the agent
   * @returns {boolean} True if agent supports auth
   */
  static supportsAuthentication(agentName) {
    return ['claude'].includes(agentName);
    // Future: return ['claude', 'gemini', 'openai'].includes(agentName);
  }
  
  /**
   * Get authentication status for any agent
   * @param {string} agentName - Name of the agent
   * @returns {Promise<Object>} Status information
   */
  static async getAuthStatus(agentName) {
    if (!this.supportsAuthentication(agentName)) {
      return {
        supported: false,
        authenticated: false,
        message: `Authentication not yet implemented for ${agentName}`
      };
    }
    
    const authHelper = await this.getAuthHelper(agentName);
    if (!authHelper) {
      return {
        supported: true,
        authenticated: false,
        message: 'Not authenticated'
      };
    }
    
    return await authHelper.getAuthStatus();
  }
}

export default AuthHelperFactory;


================================================
FILE: packages/cli/src/auth/claude-auth-helper.js
================================================
import chalk from 'chalk';
import { ClaudeAuth } from '@vibe-kit/auth/node';
import crypto from 'crypto';
import fs from 'fs-extra';
import path from 'path';
import os from 'os';

/**
 * Claude-specific authentication helper.
 * Handles OAuth token management and container credential injection.
 */
export class ClaudeAuthHelper {
  
  /**
   * Check if credentials are available for Claude
   * @returns {Promise<boolean>} True if Claude auth is available
   */
  static async hasCredentials() {
    try {
      const token = await ClaudeAuth.getValidToken();
      return !!token;
    } catch (error) {
      return false;
    }
  }
  
  /**
   * Inject Claude credentials into container arguments
   * @param {string[]} containerArgs - Container arguments to modify
   * @param {string} command - The command being executed
   * @param {string[]} args - The command arguments
   * @returns {Promise<Object|null>} - Command modification object or null
   */
  static async injectCredentials(containerArgs, command = null, args = []) {
    try {
      const credentials = await this.getClaudeCredentials();
      if (!credentials) {
        return null;
      }
      
      // Inject credentials into container
      this.injectClaudeCredentials(credentials, containerArgs);
      
      // Create command wrapper if it's a Claude command
      let commandModification = null;
      if (command === 'claude') {
        commandModification = this.createClaudeWrapper(credentials, args);
      }
      
      console.log(chalk.blue('[auth] âœ… Claude credentials injected into Docker container'));
      return commandModification;
      
    } catch (error) {
      console.log(chalk.yellow(`[auth] âš ï¸  Failed to inject Claude credentials: ${error.message}`));
      return null;
    }
  }
  
  /**
   * Get Claude credentials (OAuth token + settings)
   * @returns {Promise<Object|null>} Credential object or null
   */
  static async getClaudeCredentials() {
    try {
      // Get valid OAuth token and raw token data
      const token = await ClaudeAuth.getValidToken();
      const tokenData = await ClaudeAuth.getRawToken();
      
      if (!token || !tokenData) {
        return null;
      }
      
      // Generate settings for onboarding bypass (now includes MCP servers from host)
      const settings = await this.generateClaudeSettings(tokenData);
      
      return {
        oauthToken: token,
        settings: settings,
        tokenData: tokenData
      };
      
    } catch (error) {
      // Return null if auth fails - this is expected when not authenticated
      return null;
    }
  }
  
  /**
   * Inject Claude credentials into container arguments
   * @param {Object} credentials - Credential object from getClaudeCredentials()
   * @param {string[]} containerArgs - Container arguments to modify
   */
  static injectClaudeCredentials(credentials, containerArgs) {
    // Inject OAuth token as environment variable
    containerArgs.push('-e', `CLAUDE_CODE_OAUTH_TOKEN=${credentials.oauthToken}`);
    
    // Inject settings as environment variable - properly escape for shell
    const settingsJson = JSON.stringify(credentials.settings);
    // Escape quotes and special characters for shell safety
    const escapedSettings = settingsJson.replace(/"/g, '\\"');
    containerArgs.push('-e', `CLAUDE_SETTINGS="${escapedSettings}"`);
  }
  
  /**
   * Create wrapper command for Claude with settings injection
   * @param {Object} credentials - Credential object from getClaudeCredentials()
   * @param {string[]} args - Original command arguments
   * @returns {Object} Command modification object
   */
  static createClaudeWrapper(credentials, args) {
    // Create bash wrapper that deep merges our settings into /root/.claude.json
    const settingsJson = JSON.stringify(credentials.settings);
    const mergeScript = `
      # Write our settings to temp file
      echo '${settingsJson}' > /tmp/vibekit-settings.json
      
      # Create merge script using Node.js (available in Claude container)
      cat > /tmp/merge-settings.js << 'MERGE_EOF'
const fs = require('fs');
const path = '/root/.claude.json';
const tempPath = '/tmp/vibekit-settings.json';

// Deep merge function
function deepMerge(target, source) {
  const result = { ...target };
  for (const key in source) {
    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
      result[key] = deepMerge(result[key] || {}, source[key]);
    } else {
      result[key] = source[key];
    }
  }
  return result;
}

try {
  // Read existing config or start with empty object
  let existingConfig = {};
  if (fs.existsSync(path)) {
    existingConfig = JSON.parse(fs.readFileSync(path, 'utf8'));
  }
  
  // Read our settings
  const newSettings = JSON.parse(fs.readFileSync(tempPath, 'utf8'));
  
  // Deep merge and write back
  const mergedConfig = deepMerge(existingConfig, newSettings);
  fs.writeFileSync(path, JSON.stringify(mergedConfig, null, 2));
  
  console.log('[vibekit] Settings merged successfully');
} catch (error) {
  console.error('[vibekit] Settings merge failed:', error.message);
  process.exit(1);
}
MERGE_EOF

      # Run merge script then start claude
      node /tmp/merge-settings.js && claude ${args.join(' ')}
    `;
    
    return {
      command: 'bash',
      args: ['-c', mergeScript.trim()]
    };
  }
  
  /**
   * Extract MCP server configurations from host .claude.json file
   * @returns {Object} MCP server configurations or empty object
   */
  static async extractHostMcpServers() {
    try {
      const homeDir = os.homedir();
      const claudeAuthFile = path.join(homeDir, '.claude.json');
      
      console.log(chalk.blue(`[auth] ðŸ” Looking for MCP servers in: ${claudeAuthFile}`));
      
      if (await fs.pathExists(claudeAuthFile)) {
        console.log(chalk.blue('[auth] ðŸ“ Host .claude.json file exists, reading...'));
        const hostConfig = await fs.readJson(claudeAuthFile);
        
        console.log(chalk.blue(`[auth] ðŸ“‹ Host config keys: ${Object.keys(hostConfig).join(', ')}`));
        
        // Extract user-scope MCP server configs
        if (hostConfig.mcpServers && typeof hostConfig.mcpServers === 'object') {
          console.log(chalk.green(`[auth] âœ… Found root-level mcpServers: ${JSON.stringify(hostConfig.mcpServers)}`));
          return hostConfig.mcpServers;
        } else {
          console.log(chalk.yellow('[auth] âš ï¸  No root-level mcpServers found in host .claude.json'));
          if (hostConfig.mcpServers === undefined) {
            console.log(chalk.blue('[auth] ðŸ“ mcpServers key is undefined'));
          } else {
            console.log(chalk.blue(`[auth] ðŸ“ mcpServers value: ${JSON.stringify(hostConfig.mcpServers)}`));
          }
        }
      } else {
        console.log(chalk.yellow(`[auth] âš ï¸  Host .claude.json file does not exist at: ${claudeAuthFile}`));
      }
    } catch (error) {
      // Log more detailed error information
      console.log(chalk.red(`[auth] âŒ Error extracting MCP servers from host .claude.json: ${error.message}`));
      console.log(chalk.red(`[auth] ðŸ“ Error stack: ${error.stack}`));
    }
    
    console.log(chalk.blue('[auth] ðŸ“¤ Returning empty mcpServers object: {}'));
    return {};
  }

  /**
   * Generate Claude CLI settings for onboarding bypass
   * @param {Object} tokenData - Raw token data from ClaudeAuth
   * @returns {Promise<Object>} Settings object for Claude CLI
   */
  static async generateClaudeSettings(tokenData) {
    // Extract MCP server configurations from host file
    const hostMcpServers = await this.extractHostMcpServers();
    
    return {
      hasCompletedOnboarding: true, // Skip first-time setup
      numStartups: 2, // Indicate it's been started before
      installMethod: 'vibekit-oauth', // Custom install method identifier
      autoUpdates: true,
      userID: this.generateUserIdFromToken(tokenData),
      tipsHistory: {
        'new-user-warmup': 1
      },
      firstStartTime: new Date().toISOString(),
      // Always inject user-scope MCP server configurations from host (even if empty)
      mcpServers: hostMcpServers,
      // Project-level configuration for /workspace
      projects: {
        "/workspace": {
          allowedTools: [],
          history: [],
          mcpContextUris: [],
          mcpServers: {},
          enabledMcpjsonServers: [],
          disabledMcpjsonServers: [],
          hasTrustDialogAccepted: true, // Skip trust dialog prompts
          hasTrustDialogHooksAccepted: false,
          projectOnboardingSeenCount: 1,
          hasClaudeMdExternalIncludesApproved: false,
          hasClaudeMdExternalIncludesWarningShown: false
        }
      },
      // Add OAuth account info if available
      ...(tokenData.account && {
        oauthAccount: {
          uuid: tokenData.account.uuid,
          email_address: tokenData.account.email_address
        }
      }),
      // Add organization info if available  
      ...(tokenData.organization && {
        organization: {
          uuid: tokenData.organization.uuid,
          name: tokenData.organization.name
        }
      })
    };
  }
  
  /**
   * Generate consistent user ID from token data
   * @param {Object} tokenData - Raw token data from ClaudeAuth
   * @returns {string} SHA256 hash of user identifier
   */
  static generateUserIdFromToken(tokenData) {
    // Use account UUID if available, otherwise generate from token
    if (tokenData.account && tokenData.account.uuid) {
      return crypto
        .createHash('sha256')
        .update(tokenData.account.uuid)
        .digest('hex');
    }
    
    // Fallback: generate from access token (consistent per user)
    return crypto
      .createHash('sha256')
      .update(tokenData.access_token.substring(0, 50)) // Use first 50 chars for consistency
      .digest('hex');
  }
  
  /**
   * Get authentication status for display
   * @returns {Promise<Object>} Status information
   */
  static async getAuthStatus() {
    try {
      const credentials = await this.getClaudeCredentials();
      
      if (!credentials) {
        return {
          supported: true,
          authenticated: false,
          message: 'Not authenticated'
        };
      }
      
      // Check for expiration information in token data
      let expiresAt = null;
      const tokenData = credentials.tokenData;
      
      if (tokenData) {
        // Log token data for debugging (uncomment if needed)
        // console.log('Debug - tokenData keys:', Object.keys(tokenData));
        
        // Check for various possible expiration fields
        if (tokenData.expires_at) {
          // Handle both seconds and milliseconds timestamps
          const timestamp = tokenData.expires_at;
          expiresAt = timestamp > 1e12 ? new Date(timestamp) : new Date(timestamp * 1000);
        } else if (tokenData.expires_in && tokenData.created_at) {
          const createdTimestamp = tokenData.created_at > 1e12 ? tokenData.created_at : tokenData.created_at * 1000;
          expiresAt = new Date(createdTimestamp + (tokenData.expires_in * 1000));
        } else if (tokenData.expires_in) {
          // Use current time as base if no created_at
          expiresAt = new Date(Date.now() + (tokenData.expires_in * 1000));
        }
        
        // Check if the calculated date seems unreasonable (more than 10 years in future)
        if (expiresAt && expiresAt.getFullYear() > new Date().getFullYear() + 10) {
          // Probably a parsing error, don't show expiration
          expiresAt = null;
        }
        
        // Check if token is expired
        if (expiresAt && expiresAt < new Date()) {
          return {
            supported: true,
            authenticated: false,
            message: 'Token expired',
            expiresAt: expiresAt
          };
        }
      }
      
      return {
        supported: true,
        authenticated: true,
        message: 'Authenticated with Claude',
        expiresAt: expiresAt
      };
    } catch (error) {
      return {
        supported: true,
        authenticated: false,
        message: `Authentication error: ${error.message}`
      };
    }
  }
}

export default ClaudeAuthHelper;


================================================
FILE: packages/cli/src/components/settings.js
================================================
import React, { useState, useEffect } from 'react';
import { render, Box, Text, useInput, useApp } from 'ink';
import TextInput from 'ink-text-input';
import fs from 'fs-extra';
import path from 'path';
import os from 'os';
import { setupAliases } from '../utils/aliases.js';
import dashboardManager from '../dashboard/manager.js';
import CFonts from 'cfonts';

const Settings = ({ showWelcome = false }) => {
  const [settings, setSettings] = useState({
    sandbox: {
      type: 'none'
    },
    analytics: {
      enabled: true
    },
    aliases: {
      enabled: false
    }
  });
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [loading, setLoading] = useState(true);
  const [currentMenu, setCurrentMenu] = useState('main'); // 'main', 'analytics', 'sandbox', 'ide', 'auth', 'auth-status'
  const [logoRendered, setLogoRendered] = useState(false);
  const [authStatus, setAuthStatus] = useState(null);
  const { exit } = useApp();

  const settingsPath = path.join(os.homedir(), '.vibekit', 'settings.json');

  const getMenuItems = () => {
    switch (currentMenu) {
      case 'main':
        return [
          {
            label: 'Analytics',
            description: 'Configure analytics and logging settings',
            action: 'open-analytics'
          },
          {
            label: 'Sandbox',
            description: 'Configure sandbox isolation settings',
            action: 'open-sandbox'
          },
          {
            label: 'IDE',
            description: 'Configure IDE integrations and aliases',
            action: 'open-ide'
          },
          {
            label: 'Authentication',
            description: 'Manage authentication for agents',
            action: 'open-auth'
          },
          {
            label: 'Discord',
            description: 'Join our Discord community',
            action: 'open-discord'
          },
          {
            label: 'Exit',
            description: 'Exit settings menu',
            action: 'exit'
          }
        ];
      case 'analytics':
        return [
          {
            label: `Analytics: ${settings.analytics.enabled ? 'âœ“ ON' : 'âœ— OFF'}`,
            description: 'Enable or disable analytics collection and logging',
            action: 'toggle-analytics'
          },
          {
            label: 'View Dashboard',
            description: 'Open analytics dashboard and usage statistics',
            action: 'view-dashboard'
          },
          {
            label: 'Back to Main Menu',
            description: 'Return to main settings menu',
            action: 'back-to-main'
          }
        ];
      case 'sandbox':
        return [
          {
            label: `Sandbox: ${settings.sandbox.type}`,
            description: 'Sandbox isolation method (none/docker/sandbox-exec)',
            action: 'cycle-sandbox-type',
            color: 'green'
          },
          {
            label: 'Back to Main Menu',
            description: 'Return to main settings menu',
            action: 'back-to-main'
          }
        ];
      case 'ide':
        return [
          {
            label: `Global Aliases: ${settings.aliases.enabled ? 'âœ“ ON (requires restart)' : 'âœ— OFF (requires restart)'}`,
            description: 'Create global "claude", "gemini" and "codex" commands',
            action: 'toggle-aliases'
          },
          {
            label: 'Back to Main Menu',
            description: 'Return to main settings menu',
            action: 'back-to-main'
          }
        ];
      case 'auth':
        return [
          {
            label: 'Login to Claude',
            description: 'Authenticate with Claude using OAuth',
            action: 'auth-login-claude'
          },
          {
            label: 'View Auth Status',
            description: 'Check authentication status for all agents',
            action: 'auth-status'
          },
          {
            label: 'Back to Main Menu',
            description: 'Return to main settings menu',
            action: 'back-to-main'
          }
        ];
      case 'auth-status':
        const statusItems = [];
        
        if (authStatus) {
          authStatus.forEach(({ agent, status }) => {
            let statusText = '';
            let color = 'white';
            
            if (status.supported) {
              if (status.authenticated) {
                statusText = `${agent.padEnd(8)} Authenticated (OAuth)`;
                color = 'green';
                if (status.expiresAt) {
                  statusText += ` - Expires: ${status.expiresAt.toLocaleString()}`;
                }
              } else {
                statusText = `${agent.padEnd(8)} Not authenticated`;
                color = 'red';
              }
            } else {
              statusText = `${agent.padEnd(8)} (coming soon)`;
              color = 'gray';
            }
            
            statusItems.push({
              label: statusText,
              description: '',
              action: 'no-action',
              color: color
            });
          });
        } else {
          statusItems.push({
            label: 'Loading authentication status...',
            description: '',
            action: 'no-action',
            color: 'gray'
          });
        }
        
        statusItems.push({
          label: 'Back',
          description: 'Return to authentication menu',
          action: 'back-to-auth'
        });
        
        return statusItems;
      default:
        return [];
    }
  };

  const menuItems = getMenuItems();

  useEffect(() => {
    const loadSettings = async () => {
      try {
        await fs.ensureDir(path.dirname(settingsPath));
        
        if (await fs.pathExists(settingsPath)) {
          const loadedSettings = await fs.readJson(settingsPath);
          setSettings(prevSettings => ({...prevSettings, ...loadedSettings}));
        }
      } catch (error) {
        // Use default settings if loading fails
      } finally {
        setLoading(false);
      }
    };

    loadSettings();
  }, [settingsPath]);

  useEffect(() => {
    if (showWelcome && !logoRendered) {
      // Render the cfonts logo directly to stdout
      CFonts.say('VIBEKIT', {
        font: 'tiny',
        align: 'center',
        colors: ['gray'],
        background: 'transparent',
        letterSpacing: 1,
        lineHeight: 0,  // Minimize line height
        space: false,  // Disable extra space around the logo
        maxLength: '0',
        env: 'node'
      });
      setLogoRendered(true);
    }
  }, [showWelcome, logoRendered]);

  const saveSettings = async (newSettings) => {
    try {
      await fs.writeJson(settingsPath, newSettings, { spaces: 2 });
      setSettings(newSettings);
    } catch (error) {
      console.error('Failed to save settings:', error.message);
    }
  };


  // Check if we're in a TTY environment
  const isRawModeSupported = process.stdin.isTTY;

  if (isRawModeSupported) {
    useInput(async (input, key) => {
      if (loading) return;
      

      if (key.upArrow || input === 'k') {
        setSelectedIndex(prev => (prev > 0 ? prev - 1 : menuItems.length - 1));
      } else if (key.downArrow || input === 'j') {
        setSelectedIndex(prev => (prev < menuItems.length - 1 ? prev + 1 : 0));
      } else if (key.leftArrow) {
        if (currentMenu !== 'main') {
          setCurrentMenu('main');
          setSelectedIndex(0);
        }
      } else if (key.return || input === ' ') {
      const selectedItem = menuItems[selectedIndex];
      
      switch (selectedItem.action) {
        case 'open-analytics':
          setCurrentMenu('analytics');
          setSelectedIndex(0);
          break;
        case 'open-sandbox':
          setCurrentMenu('sandbox');
          setSelectedIndex(0);
          break;
        case 'open-ide':
          setCurrentMenu('ide');
          setSelectedIndex(0);
          break;
        case 'open-auth':
          setCurrentMenu('auth');
          setSelectedIndex(0);
          break;
        case 'open-discord':
          // Open Discord invite link
          import('child_process').then(({ exec }) => {
            const openCmd = process.platform === 'darwin' ? 'open' : 
                           process.platform === 'win32' ? 'start' : 'xdg-open';
            exec(`${openCmd} https://discord.gg/spZ7MnqFT4`);
          });
          break;
        case 'back-to-main':
          setCurrentMenu('main');
          setSelectedIndex(0);
          break;
        case 'view-dashboard':
          // Exit settings and start analytics dashboard server
          exit();
          console.log('\nðŸ“Š Starting analytics dashboard server...');
          
          try {
            const dashboardServer = dashboardManager.getDashboardServer(3001);
            await dashboardServer.start();
            const status = dashboardServer.getStatus();
            
            if (status.running && status.url) {
              console.log(`Dashboard available at: ${status.url}`);
              
              // Open browser
              import('child_process').then(({ exec }) => {
                const openCmd = process.platform === 'darwin' ? 'open' : 
                               process.platform === 'win32' ? 'start' : 'xdg-open';
                exec(`${openCmd} ${status.url}`);
              });
            }
          } catch (error) {
            console.error('âŒ Failed to start dashboard server:', error.message);
          }
          break;
        case 'toggle-analytics':
          const newAnalyticsSettings = {
            ...settings,
            analytics: {
              ...settings.analytics,
              enabled: !settings.analytics.enabled
            }
          };
          saveSettings(newAnalyticsSettings);
          break;
        case 'cycle-sandbox-type':
          const types = ['none', 'docker', 'sandbox-exec'];
          const currentIndex = types.indexOf(settings.sandbox.type);
          const nextType = types[(currentIndex + 1) % types.length];
          const newSandboxTypeSettings = {
            ...settings,
            sandbox: {
              ...settings.sandbox,
              type: nextType
            }
          };
          saveSettings(newSandboxTypeSettings);
          break;
        case 'toggle-aliases':
          const newAliasSettings = {
            ...settings,
            aliases: {
              ...settings.aliases,
              enabled: !settings.aliases.enabled
            }
          };
          saveSettings(newAliasSettings);
          
          // Automatically setup aliases based on new setting
          setupAliases(newAliasSettings.aliases.enabled).catch(error => {
            console.error('Failed to setup aliases:', error.message);
          });
          break;
        case 'auth-login-claude':
          // Exit settings and run Claude login
          exit();
          try {
            const { ClaudeAuth } = await import('@vibe-kit/auth/node');
            await ClaudeAuth.authenticate();
            console.log('âœ… Authentication successful!');
            console.log('ðŸ“ Credentials saved to ~/.vibekit/claude-oauth-token.json');
          } catch (error) {
            console.error('âŒ Authentication failed:', error.message);
          }
          break;
        case 'auth-status':
          // Load auth status and switch to auth-status menu
          try {
            const { default: AuthHelperFactory } = await import('../auth/auth-helper-factory.js');
            const allAgents = ['claude', 'codex', 'grok', 'gemini'];
            const statusData = [];
            
            for (const agentName of allAgents) {
              const status = await AuthHelperFactory.getAuthStatus(agentName);
              statusData.push({ agent: agentName, status });
            }
            
            setAuthStatus(statusData);
          } catch (error) {
            setAuthStatus([{ 
              agent: 'error', 
              status: { 
                supported: false, 
                authenticated: false, 
                message: `Failed to retrieve auth status: ${error.message}` 
              } 
            }]);
          }
          setCurrentMenu('auth-status');
          setSelectedIndex(0);
          break;
        case 'back-to-auth':
          setCurrentMenu('auth');
          setSelectedIndex(0);
          break;
        case 'no-action':
          // Do nothing for display-only items
          break;
        case 'exit':
          exit();
          break;
      }
      } else if (key.escape || input === 'q') {
        if (currentMenu !== 'main') {
          setCurrentMenu('main');
          setSelectedIndex(0);
        } else {
          exit();
        }
      }
    });
  }

  if (loading) {
    return (
      <Box flexDirection="column" padding={1}>
        <Text color="blue">âš™ï¸  Loading settings...</Text>
      </Box>
    );
  }

  const getMenuTitle = () => {
    switch (currentMenu) {
      case 'main':
        return 'ðŸ–– VibeKit Settings';
      case 'analytics':
        return 'ðŸ“Š Analytics Settings';
      case 'sandbox':
        return 'ðŸ“¦ Sandbox Settings';
      case 'ide':
        return 'ðŸ’» IDE Settings';
      case 'auth':
        return 'ðŸ” Authentication Settings';
      case 'auth-status':
        return 'ðŸ” Authentication Status';
      default:
        return 'ðŸ–– VibeKit Settings';
    }
  };

  const getNavigationText = () => {
    if (!isRawModeSupported) {
      return 'Run with a terminal to enable interactive mode';
    }
    if (currentMenu === 'main') {
      return 'Use â†‘/â†“/â†/â†’ to navigate, Enter/Space to select, q/Esc to exit';
    } else {
      return 'Use â†‘/â†“/â†/â†’ to navigate, â† or q/Esc to go back, Enter/Space to select';
    }
  };


  return (
    <Box flexDirection="column" padding={1} alignItems={showWelcome ? "center" : undefined}>
      {showWelcome && (
        <>
          <Box justifyContent="center" marginBottom={2}>
            <Text color="gray">The safety layer for coding agents</Text>
          </Box>
        </>
      )}
      
      <Box flexDirection="column" alignItems={showWelcome ? "center" : undefined}>
        {!showWelcome && (
          <>
            <Text color="blue" bold>{getMenuTitle()}</Text>
            <Text> </Text>
          </>
        )}
        
        <Box flexDirection="column">
          {menuItems.map((item, index) => (
            <Box key={index} marginY={0}>
              {item.label.includes('Not authenticated') ? (
                <Text color={index === selectedIndex ? 'cyan' : 'white'}>
                  {index === selectedIndex ? 'â¯ ' : '  '}
                  {item.label.replace('Not authenticated', '')}
                  <Text color="red">Not authenticated</Text>
                </Text>
              ) : item.label.includes('(coming soon)') ? (
                <Text color={index === selectedIndex ? 'cyan' : 'white'}>
                  {index === selectedIndex ? 'â¯ ' : '  '}
                  {item.label.replace('(coming soon)', '')}
                  <Text color="gray" dimColor>(coming soon)</Text>
                </Text>
              ) : item.label.includes('Authenticated (OAuth)') ? (
                <Text color={index === selectedIndex ? 'cyan' : 'white'}>
                  {index === selectedIndex ? 'â¯ ' : '  '}{item.label}
                </Text>
              ) : (
                <Text color={index === selectedIndex ? 'cyan' : (item.color || 'white')}>
                  {index === selectedIndex ? 'â¯ ' : '  '}
                  {item.label.includes('âœ“ ON') ? (
                    <>
                      {item.label.replace(/âœ“ ON.*/, '')}
                      <Text color="green">âœ“ ON</Text>
                      {item.label.includes('(requires restart)') && (
                        <Text color="gray" dimColor> (requires restart)</Text>
                      )}
                    </>
                  ) : item.label.includes('âœ— OFF') ? (
                    <>
                      {item.label.replace(/âœ— OFF.*/, '')}
                      <Text color="red">âœ— OFF</Text>
                      {item.label.includes('(requires restart)') && (
                        <Text color="gray" dimColor> (requires restart)</Text>
                      )}
                    </>
                  ) : item.label.includes('Sandbox: ') ? (
                    <>
                      Sandbox: <Text color="green">{settings.sandbox.type}</Text>
                    </>
                  ) : (
                    item.label
                  )}
                </Text>
              )}
            </Box>
          ))}
        </Box>

        {!showWelcome && (
          <>
            <Text> </Text>
            <Text color="gray">{getNavigationText()}</Text>
          </>
        )}
        
        {showWelcome && (
          <>
            <Text> </Text>
            <Box flexDirection="column" alignItems="center" marginTop={1}>
              <Text color="gray" dimColor>Quick Commands:</Text>
              <Box flexDirection="column" marginTop={1}>
                <Text color="gray" dimColor>  vibekit claude        Run Claude Code CLI</Text>
                <Text color="gray" dimColor>  vibekit gemini        Run Gemini CLI</Text>
                <Text color="gray" dimColor>  vibekit codex         Run Codex CLI</Text>
                <Text color="gray" dimColor>  vibekit cursor-agent  Run Cursor Agent</Text>
                <Text color="gray" dimColor>  vibekit opencode      Run OpenCode CLI</Text>
                <Text color="gray" dimColor>  vibekit              Configure settings</Text>
                <Text color="gray" dimColor>  vibekit dashboard     Open analytics dashboard</Text>
              </Box>
            </Box>
          </>
        )}
      </Box>
    </Box>
  );
};

export default Settings;


================================================
FILE: packages/cli/src/components/status-display.js
================================================
import React from 'react';
import {Text, Box} from 'ink';

const StatusDisplay = ({agentName, options = {}, settings = {}, sandboxConfig = {}}) => {
  const getSandboxStatus = () => {
    if (!sandboxConfig.enabled) return { text: 'OFF', color: 'red' };
    return { text: `ON (${sandboxConfig.type})`, color: 'green' };
  };
  
  const sandboxStatus = getSandboxStatus();

  return (
    <Box flexDirection="column" marginTop={1}>
      <Text dimColor>
        ðŸ–– VibeKit | Sandbox: <Text color={sandboxStatus.color}>{sandboxStatus.text}</Text>
      </Text>
    </Box>
  );
};

export default StatusDisplay;



================================================
FILE: packages/cli/src/config/config.js
================================================
import fs from 'fs-extra';
import path from 'path';
import os from 'os';

class Config {
  constructor() {
    this.configDir = path.join(os.homedir(), '.vibekit');
    this.configFile = path.join(this.configDir, 'config.json');
    this.defaultConfig = {
      agents: {
        claude: {
          command: 'claude',
          args: [],
          env: {}
        },
        gemini: {
          command: 'gemini',
          args: [],
          env: {}
        },
        codex: {
          command: 'codex',
          args: [],
          env: {}
        }
      },
      logging: {
        level: 'info',
        debug: false,
        retention: {
          days: 30,
          maxFiles: 100
        }
      },
      ui: {
        colors: true,
        verbose: false,
        showProgress: true
      }
    };
    this.config = null;
  }

  async load() {
    await fs.ensureDir(this.configDir);
    
    if (await fs.pathExists(this.configFile)) {
      try {
        this.config = await fs.readJson(this.configFile);
        this.config = this.mergeConfig(this.defaultConfig, this.config);
      } catch (error) {
        console.warn('Failed to parse config file, using defaults');
        this.config = this.defaultConfig;
      }
    } else {
      this.config = this.defaultConfig;
      await this.save();
    }

    return this.config;
  }

  async save() {
    if (!this.config) {
      this.config = this.defaultConfig;
    }
    
    await fs.ensureDir(this.configDir);
    await fs.writeJson(this.configFile, this.config, { spaces: 2 });
  }

  get(key) {
    if (!this.config) {
      throw new Error('Config not loaded. Call load() first.');
    }
    
    const keys = key.split('.');
    let value = this.config;
    
    for (const k of keys) {
      if (value && typeof value === 'object' && k in value) {
        value = value[k];
      } else {
        return undefined;
      }
    }
    
    return value;
  }

  set(key, value) {
    if (!this.config) {
      throw new Error('Config not loaded. Call load() first.');
    }
    
    const keys = key.split('.');
    let current = this.config;
    
    for (let i = 0; i < keys.length - 1; i++) {
      const k = keys[i];
      if (!(k in current) || typeof current[k] !== 'object') {
        current[k] = {};
      }
      current = current[k];
    }
    
    current[keys[keys.length - 1]] = value;
  }

  getAgentConfig(agentName) {
    return this.get(`agents.${agentName}`) || {
      command: agentName,
      args: [],
      env: {}
    };
  }

  setAgentConfig(agentName, config) {
    this.set(`agents.${agentName}`, config);
  }

  mergeConfig(defaults, userConfig) {
    const result = { ...defaults };
    
    for (const key in userConfig) {
      if (userConfig[key] && typeof userConfig[key] === 'object' && !Array.isArray(userConfig[key])) {
        result[key] = this.mergeConfig(defaults[key] || {}, userConfig[key]);
      } else {
        result[key] = userConfig[key];
      }
    }
    
    return result;
  }

  async reset() {
    this.config = this.defaultConfig;
    await this.save();
  }

  getConfigPath() {
    return this.configFile;
  }

  validate() {
    if (!this.config) {
      throw new Error('Config not loaded');
    }

    const requiredKeys = ['agents', 'logging', 'ui'];
    
    for (const key of requiredKeys) {
      if (!(key in this.config)) {
        throw new Error(`Missing required config key: ${key}`);
      }
    }

    for (const agentName in this.config.agents) {
      const agent = this.config.agents[agentName];
      
      if (!agent.command) {
        throw new Error(`Agent ${agentName} missing command`);
      }
      
      if (!Array.isArray(agent.args)) {
        throw new Error(`Agent ${agentName} args must be an array`);
      }
    }

    return true;
  }
}

export default Config;


================================================
FILE: packages/cli/src/dashboard/manager.ts
================================================
import { spawn, ChildProcess } from "child_process";
import { join } from "path";
import chalk from "chalk";
import fs from "fs-extra";
import os from "os";
import { execSync } from "child_process";

interface DashboardStatus {
  running: boolean;
  port: number;
  url: string | null;
}

class DashboardServer {
  private port: number;
  private process: ChildProcess | null;
  private isRunning: boolean;
  private dashboardDir: string;
  private packageName: string = "@vibe-kit/dashboard";

  constructor(port: number = 3001) {
    this.port = port;
    this.process = null;
    this.isRunning = false;
    this.dashboardDir = join(os.homedir(), ".vibekit", "dashboard");
  }

  private async ensureDashboardInstalled(): Promise<void> {
    if (!(await fs.pathExists(this.dashboardDir))) {
      console.log(chalk.blue("ðŸ“¦ Dashboard not found. Installing..."));
      
      await fs.ensureDir(join(os.homedir(), ".vibekit"));
      await fs.ensureDir(this.dashboardDir);
      
      try {
        console.log(chalk.gray(`Installing ${this.packageName}...`));
        execSync(`npm init -y && npm install ${this.packageName}@latest`, {
          cwd: this.dashboardDir,
          stdio: "inherit",
        });
        
        console.log(chalk.green("âœ… Dashboard installed successfully!"));
      } catch (error) {
        await fs.remove(this.dashboardDir);
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new Error(`Failed to install dashboard: ${errorMessage}`);
      }
    } else {
      const packagePath = join(this.dashboardDir, "node_modules", "@vibe-kit", "dashboard");
      
      if (!(await fs.pathExists(packagePath))) {
        console.log(chalk.blue("ðŸ“¦ Installing dashboard package..."));
        execSync(`npm install ${this.packageName}@latest`, {
          cwd: this.dashboardDir,
          stdio: "inherit",
        });
      } else {
        // Check for updates every time dashboard starts
        await this.checkAndUpdateDashboard();
      }
    }
  }

  private async checkAndUpdateDashboard(): Promise<void> {
    try {
      console.log(chalk.blue("ðŸ” Checking for dashboard updates..."));
      
      // Get current installed version
      const packageJsonPath = join(this.dashboardDir, "node_modules", "@vibe-kit", "dashboard", "package.json");
      if (!(await fs.pathExists(packageJsonPath))) {
        console.log(chalk.yellow("âš ï¸ Dashboard package.json not found, reinstalling..."));
        execSync(`npm install ${this.packageName}@latest`, {
          cwd: this.dashboardDir,
          stdio: "inherit",
        });
        return;
      }

      const packageJson = await fs.readJson(packageJsonPath);
      const currentVersion = packageJson.version;

      // Get latest version from npm
      const result = execSync(`npm view ${this.packageName} version`, {
        cwd: this.dashboardDir,
        encoding: 'utf8'
      });
      const latestVersion = result.trim();

      if (currentVersion !== latestVersion) {
        console.log(chalk.blue(`ðŸ”„ Updating dashboard from v${currentVersion} to v${latestVersion}...`));
        execSync(`npm install ${this.packageName}@latest`, {
          cwd: this.dashboardDir,
          stdio: "inherit",
        });
        console.log(chalk.green("âœ… Dashboard updated successfully!"));
      } else {
        console.log(chalk.gray(`âœ“ Dashboard is up-to-date (v${currentVersion})`));
      }
    } catch (error) {
      // Don't fail the start process if update check fails
      console.log(chalk.yellow("âš ï¸ Could not check for dashboard updates, continuing with current version..."));
    }
  }


  async start(): Promise<void> {
    if (this.isRunning) {
      console.log(
        chalk.yellow(`ðŸ“Š Dashboard already running on port ${this.port}`)
      );
      return;
    }

    await this.ensureDashboardInstalled();

    return new Promise<void>(async (resolve, reject) => {
      console.log(
        chalk.blue(`ðŸš€ Starting analytics dashboard on port ${this.port}...`)
      );

      const packagePath = join(this.dashboardDir, "node_modules", "@vibe-kit", "dashboard");
      const standalonePath = join(packagePath, ".next", "standalone", "packages", "dashboard", "server.js");
      
      if (!(await fs.pathExists(standalonePath))) {
        reject(new Error("Dashboard build not found. Package may be corrupted."));
        return;
      }

      // Copy static assets to the correct location for standalone build
      const staticSourcePath = join(packagePath, ".next", "static");
      const staticTargetPath = join(packagePath, ".next", "standalone", "packages", "dashboard", ".next", "static");
      const publicSourcePath = join(packagePath, "public");
      const publicTargetPath = join(packagePath, ".next", "standalone", "packages", "dashboard", "public");
      
      try {
        if (await fs.pathExists(staticSourcePath)) {
          await fs.copy(staticSourcePath, staticTargetPath, { overwrite: true });
        }
        if (await fs.pathExists(publicSourcePath)) {
          await fs.copy(publicSourcePath, publicTargetPath, { overwrite: true });
        }
      } catch (error) {
        console.log(chalk.yellow("âš ï¸ Could not copy static assets:", error instanceof Error ? error.message : String(error)));
      }

      this.process = spawn(
        "node",
        ["server.js"],
        {
          cwd: join(packagePath, ".next", "standalone", "packages", "dashboard"),
          stdio: ["pipe", "pipe", "pipe"],
          env: {
            ...process.env,
            PORT: this.port.toString(),
            HOSTNAME: "localhost",
            NODE_ENV: "production",
          },
        }
      );

      let hasStarted = false;

      this.process.stdout?.on("data", (data: Buffer) => {
        const output = data.toString();
        console.log(chalk.gray(`[Dashboard] ${output.trim()}`));

        if (
          !hasStarted &&
          (output.includes("Ready in") ||
            output.includes("Local:") ||
            output.includes(`localhost:${this.port}`) ||
            output.includes("server started on") ||
            output.includes("ready on"))
        ) {
          hasStarted = true;
          this.isRunning = true;
          console.log(chalk.green(`âœ… Dashboard started successfully!`));
          console.log(
            chalk.cyan(`ðŸ“Š Analytics Dashboard: http://localhost:${this.port}`)
          );
          resolve();
        }
      });

      this.process.stderr?.on("data", (data: Buffer) => {
        const output = data.toString();
        console.log(chalk.yellow(`[Dashboard Error] ${output.trim()}`));

        if (output.includes("Error:") || output.includes("EADDRINUSE")) {
          if (!hasStarted) {
            console.error(chalk.red("âŒ Failed to start dashboard:"), output);
            reject(new Error(`Dashboard startup failed: ${output}`));
          }
        }
      });

      this.process.on("exit", (code: number | null) => {
        this.isRunning = false;
        this.process = null;

        if (code !== 0 && !hasStarted) {
          reject(new Error(`Dashboard process exited with code ${code}`));
        } else if (code !== 0) {
          console.log(chalk.yellow(`ðŸ“Š Dashboard stopped (code: ${code})`));
        }
      });

      this.process.on("error", (error: NodeJS.ErrnoException) => {
        this.isRunning = false;
        this.process = null;

        if (!hasStarted) {
          if (error.code === "ENOENT") {
            reject(
              new Error(
                "Node.js not found. Please ensure Node.js is installed."
              )
            );
          } else {
            reject(new Error(`Failed to start dashboard: ${error.message}`));
          }
        }
      });

      setTimeout(() => {
        if (!hasStarted) {
          this.stop();
          reject(new Error("Dashboard startup timeout"));
        }
      }, 30000);

      const cleanup = () => {
        this.stop();
      };

      process.on("SIGINT", cleanup);
      process.on("SIGTERM", cleanup);
    });
  }

  stop(): void {
    if (this.process && this.isRunning) {
      console.log(chalk.blue("ðŸ›‘ Stopping dashboard..."));

      this.process.kill("SIGTERM");

      setTimeout(() => {
        if (this.process && !this.process.killed) {
          this.process.kill("SIGKILL");
        }
      }, 5000);

      this.isRunning = false;
      this.process = null;
      console.log(chalk.green("âœ… Dashboard stopped"));
    }
  }

  getStatus(): DashboardStatus {
    return {
      running: this.isRunning,
      port: this.port,
      url: this.isRunning ? `http://localhost:${this.port}` : null,
    };
  }

  async openInBrowser(): Promise<void> {
    const url = `http://localhost:${this.port}`;

    try {
      const platform = process.platform;
      let command: string;

      if (platform === "darwin") {
        command = `open "${url}"`;
      } else if (platform === "win32") {
        command = `start "" "${url}"`;
      } else {
        command = `xdg-open "${url}"`;
      }

      execSync(command);
      console.log(chalk.green(`ðŸŒ Opened dashboard in browser`));
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";
      console.log(
        chalk.yellow(`âš ï¸ Could not open browser automatically: ${errorMessage}`)
      );
      console.log(chalk.blue(`ðŸ“Š Please open manually: ${url}`));
    }
  }

  async update(): Promise<void> {
    console.log(chalk.blue("ðŸ”„ Updating dashboard..."));
    
    try {
      console.log(chalk.gray("Updating to latest version..."));
      execSync(`npm install ${this.packageName}@latest`, {
        cwd: this.dashboardDir,
        stdio: "inherit",
      });
      
      console.log(chalk.green("âœ… Dashboard updated successfully!"));
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to update dashboard: ${errorMessage}`);
    }
  }
}

class DashboardManager {
  private servers: Map<number, DashboardServer>;

  constructor() {
    this.servers = new Map();
  }

  getDashboardServer(port: number = 3001): DashboardServer {
    if (!this.servers.has(port)) {
      this.servers.set(port, new DashboardServer(port));
    }
    return this.servers.get(port)!;
  }

  stop(port: number): void {
    const server = this.servers.get(port);
    if (server) {
      server.stop();
      this.servers.delete(port);
    }
  }

  stopAll(): void {
    for (const [, server] of this.servers) {
      server.stop();
    }
    this.servers.clear();
  }
}

const dashboardManager = new DashboardManager();

export default dashboardManager;


================================================
FILE: packages/cli/src/logging/logger.js
================================================
import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';
import os from 'os';

class Logger {
  constructor(agentName = null) {
    this.agentName = agentName;
    this.logsDir = path.join(os.homedir(), '.vibekit', 'logs');
    this.sessionId = Date.now().toString();
    this.initializeLogging();
  }

  async initializeLogging() {
    await fs.ensureDir(this.logsDir);
  }

  getLogFilePath(agentName = null) {
    const agent = agentName || this.agentName || 'general';
    const date = new Date().toISOString().split('T')[0];
    return path.join(this.logsDir, `${agent}-${date}.log`);
  }

  async log(level, message, metadata = {}) {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level: level.toUpperCase(),
      agent: this.agentName,
      sessionId: this.sessionId,
      message,
      metadata
    };

    const logLine = JSON.stringify(logEntry) + '\n';
    const logFile = this.getLogFilePath();

    try {
      await fs.appendFile(logFile, logLine);
      
      if (process.env.VIBEKIT_DEBUG) {
        const colorMap = {
          INFO: chalk.blue,
          WARN: chalk.yellow,
          ERROR: chalk.red,
          DEBUG: chalk.gray
        };
        const colorFn = colorMap[level.toUpperCase()] || chalk.white;
        console.log(colorFn(`[${timestamp}] ${level.toUpperCase()}: ${message}`));
        
        // Log analytics metadata if present
        if (metadata.inputTokens || metadata.outputTokens || metadata.duration) {
          console.log(chalk.gray(`  Analytics: ${JSON.stringify({
            tokens: (metadata.inputTokens || 0) + (metadata.outputTokens || 0),
            duration: metadata.duration,
            files: metadata.filesChanged || 0
          })}`));
        }
      }
    } catch (error) {
      console.error(chalk.red('Failed to write log:'), error.message);
    }
  }

  async viewLogs(options = {}) {
    const { agent, lines = 50 } = options;
    const logFiles = [];

    if (!await fs.pathExists(this.logsDir)) {
      console.log(chalk.yellow('No logs found'));
      return;
    }

    if (agent) {
      const files = await fs.readdir(this.logsDir);
      const agentFiles = files.filter(file => file.startsWith(`${agent}-`));
      logFiles.push(...agentFiles.map(file => path.join(this.logsDir, file)));
    } else {
      const files = await fs.readdir(this.logsDir);
      logFiles.push(...files.map(file => path.join(this.logsDir, file)));
    }

    if (logFiles.length === 0) {
      console.log(chalk.yellow('No logs found'));
      return;
    }

    const allLogs = [];
    for (const logFile of logFiles) {
      try {
        const content = await fs.readFile(logFile, 'utf8');
        const logs = content.trim().split('\n')
          .filter(line => line.trim())
          .map(line => {
            try {
              return JSON.parse(line);
            } catch {
              return null;
            }
          })
          .filter(Boolean);
        allLogs.push(...logs);
      } catch (error) {
        console.error(chalk.red(`Failed to read ${logFile}:`), error.message);
      }
    }

    allLogs.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
    const recentLogs = allLogs.slice(-lines);

    recentLogs.forEach(log => {
      const colorMap = {
        INFO: chalk.blue,
        WARN: chalk.yellow,
        ERROR: chalk.red,
        DEBUG: chalk.gray
      };
      const colorFn = colorMap[log.level] || chalk.white;
      const agentTag = log.agent ? chalk.cyan(`[${log.agent}]`) : '';
      
      console.log(
        chalk.gray(log.timestamp),
        colorFn(`[${log.level}]`),
        agentTag,
        log.message
      );
      
      if (log.metadata && Object.keys(log.metadata).length > 0) {
        console.log(chalk.gray('  Metadata:'), JSON.stringify(log.metadata, null, 2));
      }
    });
  }

  async cleanLogs() {
    try {
      const files = await fs.readdir(this.logsDir);
      for (const file of files) {
        await fs.remove(path.join(this.logsDir, file));
      }
    } catch (error) {
      console.error(chalk.red('Failed to clean logs:'), error.message);
    }
  }
}

export default Logger;


================================================
FILE: packages/cli/src/sandbox/docker-sandbox.js
================================================
import { spawn, exec as execCallback } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import fs from 'fs-extra';
import os from 'os';
import crypto from 'crypto';
import { fileURLToPath } from 'url';
import SandboxUtils from './sandbox-utils.js';
import SandboxConfig from './sandbox-config.js';

const exec = promisify(execCallback);

/**
 * Docker-based sandbox implementation
 */
export class DockerSandbox {
  constructor(projectRoot, logger, options = {}) {
    this.projectRoot = projectRoot;
    this.logger = logger;
    this.runtime = options.runtime || 'docker';
    this.imageName = SandboxConfig.getSandboxImageName();
    this.options = {
      networkMode: 'bridge',
      memoryLimit: '1g',
      cpuLimit: '1.0',
      ...options
    };
    this._projectId = null; // Cache for project ID
  }


  /**
   * Ensure sandbox image exists, build if necessary
   */
  async ensureImage() {
    const imageExists = await SandboxUtils.checkImageExists(this.runtime, this.imageName);
    
    if (!imageExists) {
      await this.buildImage();
    }
    
    return true;
  }

  /**
   * Build sandbox image from existing Dockerfile
   */
  async buildImage() {
    // Find the CLI package root by looking for the Dockerfile
    let packageRoot = process.cwd();
    let dockerfilePath = path.join(packageRoot, 'Dockerfile');
    const searchedPaths = [packageRoot];
    
    // If not found in current directory, try packages/cli (for workspace root execution)
    if (!await fs.pathExists(dockerfilePath)) {
      packageRoot = path.join(process.cwd(), 'packages', 'cli');
      dockerfilePath = path.join(packageRoot, 'Dockerfile');
      searchedPaths.push(packageRoot);
    }
    
    // If still not found, try going up from current directory (for CLI directory execution)
    if (!await fs.pathExists(dockerfilePath) && process.cwd().endsWith('packages/cli')) {
      packageRoot = process.cwd();
      dockerfilePath = path.join(packageRoot, 'Dockerfile');
      searchedPaths.push(packageRoot);
    }
    
    // If still not found, try to find it relative to this module (for npm installed package)
    if (!await fs.pathExists(dockerfilePath)) {
      // Get the directory containing this module
      const moduleDir = path.dirname(fileURLToPath(import.meta.url));
      
      // For compiled JS in dist/, navigate up to the package root
      // dist/sandbox/docker-sandbox.js -> ../../Dockerfile
      if (moduleDir.includes('/dist/')) {
        packageRoot = path.resolve(moduleDir, '../../');
      } else {
        // For source files src/sandbox/docker-sandbox.js -> ../../Dockerfile  
        packageRoot = path.resolve(moduleDir, '../../');
      }
      
      dockerfilePath = path.join(packageRoot, 'Dockerfile');
      searchedPaths.push(packageRoot);
      
      // If still not found and we're in a node_modules directory, try finding the vibekit package
      if (!await fs.pathExists(dockerfilePath) && moduleDir.includes('node_modules')) {
        // Find the vibekit package in node_modules
        const nodeModulesMatch = moduleDir.match(/(.*\/node_modules)/);
        if (nodeModulesMatch) {
          packageRoot = path.join(nodeModulesMatch[1], 'vibekit');
          dockerfilePath = path.join(packageRoot, 'Dockerfile');
          searchedPaths.push(packageRoot);
        }
      }
    }
    
    if (!await fs.pathExists(dockerfilePath)) {
      throw new Error(`Dockerfile not found. Searched in: ${searchedPaths.join(', ')}`);
    }

    return new Promise((resolve, reject) => {
      const buildArgs = [
        'build',
        '-t', this.imageName,
        '-f', dockerfilePath,
        packageRoot
      ];

      const buildProcess = spawn(this.runtime, buildArgs, {
        stdio: 'inherit',
        cwd: this.projectRoot
      });

      buildProcess.on('close', (code) => {
        if (code === 0) {
          SandboxUtils.logSandboxOperation('Sandbox image built successfully');
          resolve();
        } else {
          reject(new Error(`${this.runtime} build failed with code ${code}`));
        }
      });

      buildProcess.on('error', (error) => {
        reject(new Error(`${this.runtime} build process error: ${error.message}`));
      });
    });
  }

  /**
   * Execute command in sandbox container
   */
  async executeCommand(command, args = [], options = {}) {
    await this.ensureImage();

    const containerArgs = await this.buildContainerArgs(command, args, options);
    
    // Prepare environment
    const containerEnv = {
      ...process.env,
      ...options.env,
      VIBEKIT_SANDBOX_ACTIVE: '1' // Mark that we're inside a sandbox
    };
    
    return new Promise((resolve, reject) => {
      const child = spawn(this.runtime, containerArgs, {
        stdio: options.stdio || 'inherit',
        cwd: this.projectRoot,
        env: containerEnv
      });

      child.on('close', (code) => {
        resolve({ code });
      });

      child.on('error', (error) => {
        reject(error);
      });
    });
  }

  /**
   * Generate consistent project ID from project root path
   * @returns {string} Project ID hash
   */
  getProjectId() {
    if (!this._projectId) {
      // Generate consistent project ID from project root path
      this._projectId = crypto
        .createHash('sha256')
        .update(this.projectRoot)
        .digest('hex')
        .substring(0, 12);
    }
    return this._projectId;
  }


  /**
   * Build container arguments
   * @returns {Promise<Array>} Container args array
   */
  async buildContainerArgs(command, args, options) {
    const containerArgs = [
      'run',
      '--rm', // Remove container after execution
      '--interactive',
      '--workdir', '/workspace'
    ];

    // Add TTY if stdin is a TTY
    if (process.stdin.isTTY && options.stdio === 'inherit') {
      containerArgs.push('--tty');
    }

    // Add resource limits
    containerArgs.push('--memory', this.options.memoryLimit);
    containerArgs.push('--cpus', this.options.cpuLimit);

    // Add network configuration
    containerArgs.push('--network', this.options.networkMode);

    // Add custom sandbox flags from environment
    const customFlags = SandboxConfig.getSandboxFlags();
    containerArgs.push(...customFlags);

    // Mount project directory
    containerArgs.push('-v', `${this.projectRoot}:/workspace`);

    // Add any additional container arguments (e.g., for OAuth credentials) BEFORE image name
    if (options.additionalContainerArgs && Array.isArray(options.additionalContainerArgs)) {
      containerArgs.push(...options.additionalContainerArgs);
    }

    // Mount authentication files if they exist (always enabled for persistence)
    // This works alongside OAuth injection to provide hybrid authentication:
    // 1. Files are mounted for base authentication and persistence
    // 2. OAuth credentials (via additionalContainerArgs above) enhance the mounted files
    const homeDir = os.homedir();
    const claudeAuthFile = path.join(homeDir, '.claude.json');
    const anthropicDir = path.join(homeDir, '.anthropic');
    const configDir = path.join(homeDir, '.config');

    // Note: We intentionally do NOT mount ~/.claude.json directly because:
    // 1. Mounting the user's file directly causes issues with first time Claude initialization
    //    and it wants to create it, but we can override settings as well using --settings
    //    so it merges with values we extract from the user's .claude.json
    // 2. Additionally, all the project data from the host would be included, which isn't
    //    accessible from the sandbox and thus would make no sense and even provide
    //    additional attack vectors to parts of the filesystem in the sandbox that should
    //    not be configured to do so.
    // Instead, OAuth credentials, settings, and user-scope MCP server configs are 
    // extracted from the host file and injected via environment variables above.

    // Mount .anthropic directory if it exists
    if (await fs.pathExists(anthropicDir)) {
      containerArgs.push('-v', `${anthropicDir}:/root/.anthropic`);
    }

    // Mount .config directory if it exists (for potential Claude config)
    const claudeConfigDir = path.join(configDir, 'claude');
    if (await fs.pathExists(claudeConfigDir)) {
      containerArgs.push('-v', `${claudeConfigDir}:/root/.config/claude`);
    }

    // Add security options
    containerArgs.push('--security-opt', 'no-new-privileges');

    // Add image name
    containerArgs.push(this.imageName);

    // Add command and arguments
    containerArgs.push(command);
    containerArgs.push(...args);

    return containerArgs;
  }

  /**
   * Check if sandbox is available
   */
  async isAvailable() {
    return await SandboxUtils.checkDockerAvailable();
  }

  /**
   * Get sandbox status information
   */
  async getStatus() {
    const available = await this.isAvailable();
    const imageExists = available ? await SandboxUtils.checkImageExists(this.runtime, this.imageName) : false;

    return {
      available,
      runtime: this.runtime,
      imageName: this.imageName,
      imageExists,
      ready: available && imageExists,
      credentials: {
        enabled: true,
        type: 'oauth-with-settings'
      }
    };
  }
}

export default DockerSandbox;


================================================
FILE: packages/cli/src/sandbox/docker.js
================================================
import { spawn } from 'child_process';
import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';

class Docker {
  constructor(projectRoot, logger, options = {}) {
    this.projectRoot = projectRoot;
    this.logger = logger;
    this.sandboxRoot = path.join(projectRoot, '.vibekit', '.vibekit-sandbox');
    this.workspaceDir = path.join(this.sandboxRoot, 'workspace');
    this.imageName = 'vibekit-sandbox';
    this.persistentContainerName = 'vibekit-persistent';
    this.containerName = `vibekit-${Date.now()}`;
    
    this.options = {
      networkMode: 'bridge', // Network enabled by default for AI agents
      memoryLimit: '1g',
      cpuLimit: '1.0',
      timeoutMinutes: 30,
      usePersistent: true, // Use persistent container by default
      ...options
    };
  }

  async buildImage() {
    await this.logger.log('info', 'Building Docker sandbox image with pre-installed agents');
    
    return new Promise((resolve, reject) => {
      const buildProcess = spawn('docker', [
        'build',
        '-t', this.imageName,
        '.'
      ], {
        cwd: this.projectRoot,
        stdio: 'inherit' // Show build output to user
      });

      buildProcess.on('close', (code) => {
        if (code === 0) {
          this.logger.log('info', 'Docker image built successfully with coding agents');
          resolve();
        } else {
          this.logger.log('error', 'Failed to build Docker image', { exitCode: code });
          reject(new Error(`Docker build failed with code ${code}`));
        }
      });

      buildProcess.on('error', (error) => {
        this.logger.log('error', 'Docker build process error', { error: error.message });
        reject(error);
      });
    });
  }

  async checkDockerInstallation() {
    return new Promise((resolve) => {
      // Check if Docker daemon is running by trying to ping it
      const child = spawn('docker', ['info'], { stdio: 'ignore' });
      child.on('close', (code) => {
        resolve(code === 0);
      });
      child.on('error', () => {
        resolve(false);
      });
    });
  }

  async checkImageExists() {
    return new Promise((resolve) => {
      const child = spawn('docker', ['image', 'inspect', this.imageName], { stdio: 'ignore' });
      child.on('close', (code) => {
        resolve(code === 0);
      });
      child.on('error', () => {
        resolve(false);
      });
    });
  }

  async checkPersistentContainer() {
    return new Promise((resolve) => {
      const child = spawn('docker', ['container', 'inspect', this.persistentContainerName], { stdio: 'ignore' });
      child.on('close', (code) => {
        resolve(code === 0);
      });
      child.on('error', () => {
        resolve(false);
      });
    });
  }

  async isPersistentContainerRunning() {
    return new Promise((resolve) => {
      const child = spawn('docker', ['ps', '-q', '-f', `name=${this.persistentContainerName}`], { stdio: 'pipe' });
      let output = '';
      
      child.stdout.on('data', (data) => {
        output += data.toString();
      });
      
      child.on('close', (code) => {
        resolve(code === 0 && output.trim().length > 0);
      });
      
      child.on('error', () => {
        resolve(false);
      });
    });
  }

  async checkContainerNetworkSettings() {
    // For simplicity, always restart if network settings might have changed
    // In practice, we could inspect the container and compare network modes
    return new Promise((resolve) => {
      const child = spawn('docker', ['inspect', this.persistentContainerName, '--format', '{{.HostConfig.NetworkMode}}'], { stdio: 'pipe' });
      let output = '';
      
      child.stdout.on('data', (data) => {
        output += data.toString().trim();
      });
      
      child.on('close', (code) => {
        if (code === 0) {
          // Check if current network mode matches desired
          const currentNetworkMode = output.trim();
          const desiredNetworkMode = this.options.networkMode;
          resolve(currentNetworkMode !== desiredNetworkMode);
        } else {
          resolve(false); // Container probably doesn't exist
        }
      });
      
      child.on('error', () => {
        resolve(false);
      });
    });
  }

  async startPersistentContainer() {
    await this.logger.log('info', 'Starting persistent Docker container for fast execution');

    if (!await this.checkImageExists()) {
      await this.buildImage();
    }

    // Check if existing container has different network settings
    const needsRestart = await this.checkContainerNetworkSettings();

    // Remove existing container if it exists and needs restart or is stopped
    if (await this.checkPersistentContainer() && (needsRestart || !await this.isPersistentContainerRunning())) {
      if (await this.isPersistentContainerRunning()) {
        await this.stopPersistentContainer();
      }
      await new Promise((resolve) => {
        const remove = spawn('docker', ['rm', this.persistentContainerName], { stdio: 'ignore' });
        remove.on('close', () => resolve());
        remove.on('error', () => resolve());
      });
    }

    // Start new persistent container if not running
    if (!await this.isPersistentContainerRunning()) {
      return new Promise((resolve, reject) => {
        const dockerArgs = [
          'run',
          '-d', // Detached
          '--name', this.persistentContainerName,
          '--memory', this.options.memoryLimit,
          '--cpus', this.options.cpuLimit,
          '--network', this.options.networkMode,
          '--tmpfs', '/tmp:rw,noexec,nosuid,size=100m',
          '--security-opt', 'no-new-privileges',
          '--cap-drop', 'ALL',
          this.imageName
        ];

        const startProcess = spawn('docker', dockerArgs, { stdio: 'inherit' });

        startProcess.on('close', (code) => {
          if (code === 0) {
            this.logger.log('info', 'Persistent container started successfully');
            resolve();
          } else {
            reject(new Error(`Failed to start persistent container with code ${code}`));
          }
        });

        startProcess.on('error', (error) => {
          reject(error);
        });
      });
    }
  }

  async prepareWorkspace() {
    await fs.ensureDir(this.workspaceDir);
    
    // Copy important files to workspace
    const importantFiles = [
      'package.json',
      'package-lock.json',
      'yarn.lock',
      'tsconfig.json',
      '.gitignore',
      '.env.example'
    ];

    const importantDirs = [
      'src',
      'lib',
      'components',
      'pages',
      'api',
      'utils',
      'config',
      'public',
      'assets'
    ];

    for (const file of importantFiles) {
      const srcPath = path.join(this.projectRoot, file);
      const destPath = path.join(this.workspaceDir, file);
      
      if (await fs.pathExists(srcPath)) {
        await fs.copy(srcPath, destPath);
      }
    }

    for (const dir of importantDirs) {
      const srcPath = path.join(this.projectRoot, dir);
      const destPath = path.join(this.workspaceDir, dir);
      
      if (await fs.pathExists(srcPath)) {
        await fs.copy(srcPath, destPath);
      }
    }

    // Copy git directory for context (read-only)
    const gitPath = path.join(this.projectRoot, '.git');
    const destGitPath = path.join(this.workspaceDir, '.git');
    
    if (await fs.pathExists(gitPath)) {
      await fs.copy(gitPath, destGitPath);
    }
  }

  async findClaudeCLI() {
    // Try to find Claude CLI on the host system
    const possiblePaths = [
      '/usr/local/bin/claude',
      '/opt/homebrew/bin/claude',
      process.env.HOME + '/.local/bin/claude',
      '/home/' + process.env.USER + '/.local/bin/claude'
    ];

    for (const claudePath of possiblePaths) {
      try {
        if (await fs.pathExists(claudePath)) {
          return claudePath;
        }
      } catch (error) {
        // Continue checking other paths
      }
    }

    // Try to find using 'which'
    return new Promise((resolve) => {
      const which = spawn('which', ['claude'], { stdio: 'pipe' });
      let output = '';
      
      which.stdout.on('data', (data) => {
        output += data.toString().trim();
      });
      
      which.on('close', (code) => {
        if (code === 0 && output) {
          resolve(output);
        } else {
          resolve(null);
        }
      });
    });
  }

  async runCommand(command, args = [], options = {}) {
    if (!await this.checkDockerInstallation()) {
      throw new Error('Docker is not installed or not running');
    }

    await this.prepareWorkspace();

    if (this.options.usePersistent) {
      return await this.runInPersistentContainer(command, args, options);
    } else {
      return await this.runInFreshContainer(command, args, options);
    }
  }

  async runInPersistentContainer(command, args = [], options = {}) {
    // Ensure persistent container is running
    await this.startPersistentContainer();

    // Copy workspace files into the running container
    await new Promise((resolve, reject) => {
      const copyProcess = spawn('docker', [
        'cp', `${this.workspaceDir}/.`, `${this.persistentContainerName}:/workspace/`
      ], { stdio: 'inherit' });

      copyProcess.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`Failed to copy workspace to container`));
        }
      });
    });

    // First check if command exists in container
    const checkArgs = [
      'exec',
      this.persistentContainerName,
      'bash', '-c', `which ${command} || echo "Command ${command} not found"`
    ];

    await new Promise((resolve) => {
      const checkProcess = spawn('docker', checkArgs, { stdio: 'inherit' });
      checkProcess.on('close', () => resolve());
    });

    // Execute command in persistent container
    const execArgs = [
      'exec',
      '-i', // Interactive (always safe)
      '-w', '/workspace', // Working directory
    ];

    // Only add TTY if we're actually in a TTY
    if (process.stdout.isTTY && process.stdin.isTTY) {
      execArgs.push('-t'); // TTY for proper terminal UI
    }

    execArgs.push(this.persistentContainerName, command, ...args);

    await this.logger.log('info', `Running command in persistent container: ${command} ${args.join(' ')}`, {
      containerName: this.persistentContainerName,
      execArgs: execArgs.length
    });

    return new Promise((resolve, reject) => {
      console.log(chalk.blue(`[vibekit] Running in persistent Docker: ${command} ${args.join(' ')}`));
      
      const startTime = Date.now();
      const execProcess = spawn('docker', execArgs, {
        stdio: 'inherit',
        detached: false,
        ...options
      });

      const timeout = setTimeout(() => {
        execProcess.kill('SIGTERM');
        reject(new Error(`Command timed out after ${this.options.timeoutMinutes} minutes`));
      }, this.options.timeoutMinutes * 60 * 1000);

      execProcess.on('close', (code) => {
        clearTimeout(timeout);
        const duration = Date.now() - startTime;
        console.log(chalk.blue(`[vibekit] Persistent Docker command exited with code ${code} (${duration}ms)`));
        
        // Copy results back from container
        this.copyResultsBack().then(() => {
          resolve({ code, duration });
        }).catch(() => {
          resolve({ code, duration }); // Don't fail if copy back fails
        });
      });

      execProcess.on('error', (error) => {
        clearTimeout(timeout);
        reject(error);
      });

      // Handle process termination
      process.on('SIGINT', () => {
        execProcess.kill('SIGINT');
      });

      process.on('SIGTERM', () => {
        execProcess.kill('SIGTERM');
      });
    });
  }

  async runInFreshContainer(command, args = [], options = {}) {
    if (!await this.checkImageExists()) {
      await this.buildImage();
    }

    const dockerArgs = [
      'run',
      '--rm', // Remove container after run
      '--name', this.containerName,
      '--workdir', '/workspace',
      '--volume', `${this.workspaceDir}:/workspace`,
      '--memory', this.options.memoryLimit,
      '--cpus', this.options.cpuLimit,
      '--network', this.options.networkMode,
      '--tmpfs', '/tmp:rw,noexec,nosuid,size=100m',
      '--security-opt', 'no-new-privileges',
      '--cap-drop', 'ALL',
    ];

    // Add timeout if specified
    if (this.options.timeoutMinutes) {
      dockerArgs.push('--stop-timeout', (this.options.timeoutMinutes * 60).toString());
    }

    dockerArgs.push(this.imageName);
    dockerArgs.push(command);
    dockerArgs.push(...args);

    await this.logger.log('info', `Running command in Docker container: ${command} ${args.join(' ')}`, {
      containerName: this.containerName,
      dockerArgs
    });

    return new Promise((resolve, reject) => {
      console.log(chalk.blue(`[vibekit] Running in Docker: ${command} ${args.join(' ')}`));
      
      const dockerProcess = spawn('docker', dockerArgs, {
        stdio: 'inherit',
        ...options
      });

      const timeout = setTimeout(() => {
        dockerProcess.kill('SIGTERM');
        reject(new Error(`Command timed out after ${this.options.timeoutMinutes} minutes`));
      }, this.options.timeoutMinutes * 60 * 1000);

      dockerProcess.on('close', (code) => {
        clearTimeout(timeout);
        console.log(chalk.blue(`[vibekit] Docker container exited with code ${code}`));
        resolve({ code });
      });

      dockerProcess.on('error', (error) => {
        clearTimeout(timeout);
        reject(error);
      });

      // Handle process termination
      process.on('SIGINT', () => {
        this.stopContainer();
      });

      process.on('SIGTERM', () => {
        this.stopContainer();
      });
    });
  }

  async stopContainer() {
    try {
      await this.logger.log('info', `Stopping Docker container: ${this.containerName}`);
      
      const stopProcess = spawn('docker', ['stop', this.containerName], { stdio: 'ignore' });
      
      return new Promise((resolve) => {
        stopProcess.on('close', () => {
          resolve();
        });
        stopProcess.on('error', () => {
          resolve(); // Ignore errors when stopping
        });
      });
    } catch (error) {
      // Ignore errors when stopping container
    }
  }

  async copyResultsBack() {
    // Copy changed files back from persistent container
    return new Promise((resolve, reject) => {
      const copyProcess = spawn('docker', [
        'cp', `${this.persistentContainerName}:/workspace/.`, this.workspaceDir
      ], { stdio: 'ignore' });

      copyProcess.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`Failed to copy results back from container`));
        }
      });
    });
  }

  async stopPersistentContainer() {
    if (await this.isPersistentContainerRunning()) {
      await this.logger.log('info', 'Stopping persistent container');
      
      return new Promise((resolve) => {
        const stopProcess = spawn('docker', ['stop', this.persistentContainerName], { stdio: 'ignore' });
        stopProcess.on('close', () => resolve());
        stopProcess.on('error', () => resolve());
      });
    }
  }

  async cleanup() {
    // For persistent containers, don't stop - keep them warm
    if (!this.options.usePersistent) {
      await this.stopContainer();
      
      // Remove container if it exists
      try {
        const rmProcess = spawn('docker', ['rm', '-f', this.containerName], { stdio: 'ignore' });
        await new Promise((resolve) => {
          rmProcess.on('close', resolve);
          rmProcess.on('error', resolve);
        });
      } catch (error) {
        // Ignore cleanup errors
      }
    }
  }

  async getWorkspaceChanges() {
    const changes = [];
    
    const walkDir = async (dir, relativePath = '') => {
      const items = await fs.readdir(dir);
      
      for (const item of items) {
        if (item.startsWith('.') && item !== '.gitignore') continue;
        
        const itemPath = path.join(dir, item);
        const relativeItemPath = path.join(relativePath, item);
        const stat = await fs.stat(itemPath);
        
        if (stat.isDirectory()) {
          await walkDir(itemPath, relativeItemPath);
        } else {
          const projectFile = path.join(this.projectRoot, relativeItemPath);
          
          if (!await fs.pathExists(projectFile)) {
            changes.push(relativeItemPath);
          } else {
            const sandboxContent = await fs.readFile(itemPath, 'utf8');
            const projectContent = await fs.readFile(projectFile, 'utf8');
            
            if (sandboxContent !== projectContent) {
              changes.push(relativeItemPath);
            }
          }
        }
      }
    };

    await walkDir(this.workspaceDir);
    return changes;
  }

  async syncChangesBack() {
    const changes = await this.getWorkspaceChanges();
    
    if (changes.length === 0) {
      await this.logger.log('info', 'No changes to sync from Docker sandbox');
      return [];
    }

    await this.logger.log('info', `Syncing ${changes.length} files from Docker sandbox`, { changes });

    for (const file of changes) {
      const sandboxFile = path.join(this.workspaceDir, file);
      const projectFile = path.join(this.projectRoot, file);
      
      if (await fs.pathExists(sandboxFile)) {
        await fs.ensureDir(path.dirname(projectFile));
        await fs.copy(sandboxFile, projectFile);
      }
    }

    return changes;
  }
}

export default Docker;


================================================
FILE: packages/cli/src/sandbox/sandbox-config.js
================================================
import SandboxUtils from './sandbox-utils.js';

/**
 * Handles sandbox configuration with precedence: CLI flags > Environment variables > Settings file
 */
export class SandboxConfig {
  /**
   * Resolve sandbox configuration following CLI precedence model
   */
  static async resolveSandboxConfig(cliOptions = {}, settings = {}) {
    let sandboxEnabled = false;
    let sandboxType = 'none';
    let source = 'default';

    // 1. Check CLI flags (highest priority)
    if (cliOptions.sandbox || cliOptions.sandboxType) {
      sandboxEnabled = true;
      sandboxType = cliOptions.sandboxType || 'docker';
      source = 'cli';
    }
    // 2. Check environment variables
    else if (process.env.VIBEKIT_SANDBOX === 'true' || process.env.VIBEKIT_SANDBOX === '1') {
      sandboxEnabled = true;
      sandboxType = process.env.VIBEKIT_SANDBOX_TYPE || 'docker';
      source = 'env';
    }
    else if (process.env.VIBEKIT_SANDBOX && process.env.VIBEKIT_SANDBOX !== 'false' && process.env.VIBEKIT_SANDBOX !== '0') {
      // Support direct type specification like VIBEKIT_SANDBOX=docker
      sandboxEnabled = true;
      sandboxType = process.env.VIBEKIT_SANDBOX;
      source = 'env';
    }
    // 3. Check settings file (lowest priority)
    else if (settings.sandbox?.enabled) {
      // Legacy format support
      sandboxEnabled = true;
      sandboxType = settings.sandbox?.type || 'docker';
      source = 'settings';
    }
    else if (settings.sandbox?.type && settings.sandbox.type !== 'none') {
      // New format
      sandboxEnabled = true;
      sandboxType = settings.sandbox.type;
      source = 'settings';
    }

    // Validate sandbox type
    if (sandboxEnabled && !['docker', 'podman', 'sandbox-exec', 'none'].includes(sandboxType)) {
      SandboxUtils.logSandboxWarning(`Unknown sandbox type '${sandboxType}', falling back to 'docker'`);
      sandboxType = 'docker';
    }

    // Auto-detect container runtime if needed
    if (sandboxEnabled && (sandboxType === 'docker' || sandboxType === 'podman')) {
      const availableRuntime = await SandboxUtils.detectContainerRuntime();
      
      if (!availableRuntime) {
        SandboxUtils.logSandboxWarning('No container runtime available, disabling sandbox');
        sandboxEnabled = false;
        sandboxType = 'none';
      } else if (sandboxType !== availableRuntime) {
        // If user specified docker but only podman available (or vice versa), auto-switch
        if (source !== 'cli') {
          sandboxType = availableRuntime;
        }
      }
    }

    const config = {
      enabled: sandboxEnabled,
      type: sandboxEnabled ? sandboxType : 'none',
      source,
      runtime: sandboxEnabled && (sandboxType === 'docker' || sandboxType === 'podman') ? sandboxType : null
    };

    // Add sandbox-exec specific configuration
    if (sandboxEnabled && sandboxType === 'sandbox-exec') {
      // Get configuration from CLI options, environment, or settings
      const sandboxExecConfig = 
        cliOptions.sandboxExec ||
        SandboxConfig.parseSandboxExecEnv() ||
        settings.sandbox?.sandboxExec ||
        {};

      // Default to custom profile if no specific profile is set
      config.profile = sandboxExecConfig.profile;
      config.profileFile = sandboxExecConfig.profileFile;
      config.profileString = sandboxExecConfig.profileString;
      config.profileParams = sandboxExecConfig.profileParams;
    }

    return config;
  }


  /**
   * Get sandbox flags from environment
   */
  static getSandboxFlags() {
    return SandboxUtils.parseSandboxFlags(process.env.VIBEKIT_SANDBOX_FLAGS);
  }

  /**
   * Get sandbox image name
   */
  static getSandboxImageName() {
    return process.env.VIBEKIT_SANDBOX_IMAGE || 'vibekit-sandbox:latest';
  }

  /**
   * Parse sandbox-exec configuration from environment variables
   */
  static parseSandboxExecEnv() {
    const config = {};
    
    if (process.env.VIBEKIT_SANDBOX_EXEC_PROFILE) {
      config.profile = process.env.VIBEKIT_SANDBOX_EXEC_PROFILE;
    }
    
    if (process.env.VIBEKIT_SANDBOX_EXEC_PROFILE_FILE) {
      config.profileFile = process.env.VIBEKIT_SANDBOX_EXEC_PROFILE_FILE;
    }
    
    if (process.env.VIBEKIT_SANDBOX_EXEC_PROFILE_STRING) {
      config.profileString = process.env.VIBEKIT_SANDBOX_EXEC_PROFILE_STRING;
    }

    if (process.env.VIBEKIT_SANDBOX_EXEC_PARAMS) {
      try {
        config.profileParams = JSON.parse(process.env.VIBEKIT_SANDBOX_EXEC_PARAMS);
      } catch (error) {
        SandboxUtils.logSandboxWarning('Invalid JSON in VIBEKIT_SANDBOX_EXEC_PARAMS, ignoring');
      }
    }
    
    return Object.keys(config).length > 0 ? config : null;
  }
}

export default SandboxConfig;


================================================
FILE: packages/cli/src/sandbox/sandbox-engine.js
================================================
import DockerSandbox from './docker-sandbox.js';
import SandboxExecSandbox from './sandbox-exec.js';
import SandboxConfig from './sandbox-config.js';
import SandboxUtils from './sandbox-utils.js';
import AuthHelperFactory from '../auth/auth-helper-factory.js';

/**
 * Main sandbox orchestrator - handles sandbox selection and execution
 */
export class SandboxEngine {
  constructor(projectRoot, logger, options = {}) {
    this.projectRoot = projectRoot;
    this.logger = logger;
    this.options = options;
  }

  /**
   * Create appropriate sandbox instance based on configuration
   */
  async createSandbox(sandboxConfig) {
    const { type, runtime } = sandboxConfig;

    switch (type) {
      case 'docker':
      case 'podman':
        return new DockerSandbox(this.projectRoot, this.logger, {
          ...this.options,
          runtime: runtime || type
        });
      
      case 'sandbox-exec':
        return new SandboxExecSandbox(this.projectRoot, this.logger, {
          ...this.options,
          profile: sandboxConfig.profile,
          profileFile: sandboxConfig.profileFile,
          profileString: sandboxConfig.profileString,
          profileParams: sandboxConfig.profileParams
        });
      
      case 'none':
      default:
        return null;
    }
  }

  /**
   * Execute command with sandbox if enabled, otherwise direct execution
   */
  async executeWithSandbox(command, args, cliOptions = {}, settings = {}, agentName = null) {
    // Resolve sandbox configuration
    const sandboxConfig = await SandboxConfig.resolveSandboxConfig(cliOptions, settings);

    // Early detection: Skip auth logic entirely if not supported or no sandbox
    if (!sandboxConfig.enabled || sandboxConfig.type !== 'docker' || !agentName) {
      return await this.executeWithoutAuth(command, args, sandboxConfig);
    }

    // Early detection: Check if agent supports auth and has credentials
    const authHelper = await AuthHelperFactory.getAuthHelper(agentName);
    if (!authHelper) {
      // No auth available - proceed without credentials
      return await this.executeWithoutAuth(command, args, sandboxConfig);
    }

    // Auth is available - proceed with credential injection
    return await this.executeWithAuth(command, args, sandboxConfig, authHelper, agentName);
  }

  /**
   * Execute without authentication
   */
  async executeWithoutAuth(command, args, sandboxConfig) {
    // Log sandbox decision for transparency
    if (sandboxConfig.enabled) {
      await this.logger.log('info', `Sandbox enabled: ${sandboxConfig.type}`, {
        source: sandboxConfig.source,
        runtime: sandboxConfig.runtime
      });
    }

    // If sandbox not enabled, return null to indicate direct execution
    if (!sandboxConfig.enabled) {
      return null;
    }

    // Create and execute sandbox without auth
    const sandbox = await this.createSandbox(sandboxConfig);
    if (!sandbox) {
      SandboxUtils.logSandboxWarning('Failed to create sandbox, falling back to direct execution');
      return null;
    }

    // Check if sandbox is available
    const isAvailable = await sandbox.isAvailable();
    if (!isAvailable) {
      SandboxUtils.logSandboxWarning(`${sandboxConfig.runtime} is not available, falling back to direct execution`);
      SandboxUtils.logSandboxOperation('To use sandbox mode, ensure Docker or Podman is installed and running');
      return null;
    }

    try {
      const result = await sandbox.executeCommand(command, args, {
        stdio: 'inherit',
        env: this.options.env
      });

      await this.logger.log('info', 'Command completed in sandbox', {
        exitCode: result.code,
        sandboxType: sandboxConfig.type
      });

      return result;
    } catch (error) {
      await this.logger.log('error', 'Sandbox execution failed', {
        error: error.message,
        sandboxType: sandboxConfig.type
      });
      
      SandboxUtils.logSandboxError(`Execution failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Execute with authentication
   */
  async executeWithAuth(command, args, sandboxConfig, authHelper, agentName) {
    await this.logger.log('info', `Sandbox enabled with ${agentName} authentication: ${sandboxConfig.type}`, {
      source: sandboxConfig.source,
      runtime: sandboxConfig.runtime
    });

    // Create sandbox instance
    const sandbox = await this.createSandbox(sandboxConfig);
    if (!sandbox) {
      SandboxUtils.logSandboxWarning('Failed to create sandbox, falling back to direct execution');
      return null;
    }

    // Check if sandbox is available
    const isAvailable = await sandbox.isAvailable();
    if (!isAvailable) {
      SandboxUtils.logSandboxWarning(`${sandboxConfig.type} is not available, falling back to direct execution`);
      const helpMessage = sandboxConfig.type === 'sandbox-exec' 
        ? 'sandbox-exec is only available on macOS'
        : 'To use sandbox mode, ensure Docker or Podman is installed and running';
      SandboxUtils.logSandboxOperation(helpMessage);
      return null;
    }

    try {
      // Prepare container arguments for credential injection
      const containerArgs = [];
      let finalCommand = command;
      let finalArgs = args;
      
      // Inject credentials using agent-specific helper
      const commandModification = await authHelper.injectCredentials(
        containerArgs,
        command,
        args
      );
      
      if (commandModification) {
        await this.logger.log('info', `Credentials injected for ${agentName}`, {
          sandboxType: sandboxConfig.type
        });
        
        // Use modified command if provided
        if (commandModification.command) {
          finalCommand = commandModification.command;
          finalArgs = commandModification.args;
        }
      }
      
      // Execute in sandbox with credentials
      const result = await sandbox.executeCommand(finalCommand, finalArgs, {
        stdio: 'inherit',
        env: this.options.env,
        additionalContainerArgs: containerArgs
      });

      await this.logger.log('info', 'Command completed in sandbox with auth', {
        exitCode: result.code,
        sandboxType: sandboxConfig.type
      });

      return result;
    } catch (error) {
      await this.logger.log('error', 'Authenticated sandbox execution failed', {
        error: error.message,
        sandboxType: sandboxConfig.type
      });
      
      SandboxUtils.logSandboxError(`Execution failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get sandbox status for management commands
   */
  async getStatus(cliOptions = {}, settings = {}) {
    const sandboxConfig = await SandboxConfig.resolveSandboxConfig(cliOptions, settings);
    
    if (!sandboxConfig.enabled) {
      return {
        enabled: false,
        type: 'none',
        available: false
      };
    }

    const sandbox = await this.createSandbox(sandboxConfig);
    if (!sandbox) {
      return {
        enabled: true,
        type: sandboxConfig.type,
        available: false,
        error: 'Failed to create sandbox instance'
      };
    }

    const status = await sandbox.getStatus();
    
    return {
      enabled: true,
      type: sandboxConfig.type,
      source: sandboxConfig.source,
      ...status
    };
  }
}

export default SandboxEngine;


================================================
FILE: packages/cli/src/sandbox/sandbox-exec.js
================================================
import { spawn, exec as execCallback } from 'child_process';
import { promisify } from 'util';
import os from 'os';
import SandboxUtils from './sandbox-utils.js';

const exec = promisify(execCallback);

/**
 * macOS sandbox-exec based sandbox implementation
 */
export class SandboxExecSandbox {
  constructor(projectRoot, logger, options = {}) {
    this.projectRoot = projectRoot;
    this.logger = logger;
    // Set defaults, but allow options to override
    this.options = { ...options };
    
    // If no specific profile configuration is provided, use our custom development profile
    if (!this.options.profile && !this.options.profileFile && !this.options.profileString) {
      this.options.profileString = this.createDevelopmentProfile();
    }
  }

  /**
   * Execute command in sandbox-exec
   */
  async executeCommand(command, args = [], options = {}) {
    const sandboxArgs = await this.buildSandboxArgs(command, args, options);
    
    // Prepare environment
    const sandboxEnv = {
      ...process.env,
      ...options.env
    };
    
    return new Promise((resolve, reject) => {
      const child = spawn('sandbox-exec', sandboxArgs, {
        stdio: options.stdio || 'inherit',
        cwd: this.projectRoot,
        env: {
          ...sandboxEnv,
          VIBEKIT_SANDBOX_ACTIVE: '1' // Mark that we're inside a sandbox
        }
      });

      child.on('close', (code) => {
        resolve({ code });
      });

      child.on('error', (error) => {
        reject(error);
      });
    });
  }

  /**
   * Build sandbox-exec arguments
   */
  async buildSandboxArgs(command, args, options) {
    const sandboxArgs = [];

    // Use profile (either built-in or custom)
    if (this.options.profileFile) {
      sandboxArgs.push('-f', this.options.profileFile);
    } else if (this.options.profileString) {
      sandboxArgs.push('-p', this.options.profileString);
    } else {
      sandboxArgs.push('-n', this.options.profile);
    }

    // Add any profile parameters
    if (this.options.profileParams) {
      Object.entries(this.options.profileParams).forEach(([key, value]) => {
        sandboxArgs.push('-D', `${key}=${value}`);
      });
    }

    // Add command and arguments
    sandboxArgs.push(command);
    sandboxArgs.push(...args);

    return sandboxArgs;
  }

  /**
   * Check if sandbox-exec is available (macOS only)
   */
  async isAvailable() {
    // Check if we're on macOS
    if (os.platform() !== 'darwin') {
      return false;
    }

    try {
      // Check if sandbox-exec command exists
      await exec('which sandbox-exec');
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Get sandbox status information
   */
  async getStatus() {
    const available = await this.isAvailable();

    return {
      available,
      runtime: 'sandbox-exec',
      profile: this.options.profile,
      profileFile: this.options.profileFile,
      profileString: this.options.profileString,
      ready: available
    };
  }

  /**
   * Get available built-in profiles
   */
  static getBuiltInProfiles() {
    return [
      'no-write',        // Default: Allows network, blocks file writes
      'pure-computation', // Restricts most operations but allows computation
      'no-network'       // Blocks all network access (more secure)
    ];
  }

  /**
   * Create a development-friendly profile with network access (similar to Gemini CLI's permissive-open)
   */
  createDevelopmentProfile() {
    return `
(version 1)
(debug deny)
(allow default)

; Allow network access for development needs
(allow network*)

; Allow file writes in workspace directory and common development locations
(allow file-write*
  (subpath "${this.projectRoot}")
  (subpath "/tmp/")
  (subpath "/private/tmp/")
  (subpath "/var/tmp/")
  (regex #"^/Users/[^/]+/\\.(npm|cache|config)/")
  (regex #"^/Users/[^/]+/node_modules/"))

; Deny writes to critical system areas
(deny file-write* 
  (subpath "/System/")
  (subpath "/usr/")
  (subpath "/bin/")
  (subpath "/sbin/")
  (subpath "/private/etc/")
  (literal "/etc/passwd")
  (literal "/etc/shadow"))

; Allow common development tools
(allow process-exec
  (subpath "/usr/bin/")
  (subpath "/bin/")
  (subpath "/usr/local/bin/"))

; Deny dangerous system operations
(deny process-exec 
  (literal "/usr/bin/sudo")
  (literal "/bin/su"))
`;
  }
}

export default SandboxExecSandbox;


================================================
FILE: packages/cli/src/sandbox/sandbox-utils.js
================================================
import { spawn } from 'child_process';
import chalk from 'chalk';
import crypto from 'crypto';
import { ClaudeAuth } from '@vibe-kit/auth/node';

/**
 * Utility functions for sandbox operations
 */
export class SandboxUtils {
  /**
   * Check if Docker is available and running
   */
  static async checkDockerAvailable() {
    return new Promise((resolve) => {
      const child = spawn('docker', ['info'], { stdio: 'ignore' });
      child.on('close', (code) => resolve(code === 0));
      child.on('error', () => resolve(false));
    });
  }

  /**
   * Check if Podman is available
   */
  static async checkPodmanAvailable() {
    return new Promise((resolve) => {
      const child = spawn('podman', ['info'], { stdio: 'ignore' });
      child.on('close', (code) => resolve(code === 0));
      child.on('error', () => resolve(false));
    });
  }

  /**
   * Detect best available container runtime
   */
  static async detectContainerRuntime() {
    if (await this.checkDockerAvailable()) {
      return 'docker';
    }
    if (await this.checkPodmanAvailable()) {
      return 'podman';
    }
    return null;
  }

  /**
   * Check if image exists
   */
  static async checkImageExists(runtime, imageName) {
    return new Promise((resolve) => {
      const child = spawn(runtime, ['image', 'inspect', imageName], { stdio: 'ignore' });
      child.on('close', (code) => resolve(code === 0));
      child.on('error', () => resolve(false));
    });
  }

  /**
   * Parse sandbox flags from environment variable
   */
  static parseSandboxFlags(flagsString) {
    if (!flagsString) return [];
    
    // Simple parsing - split by spaces but handle quoted arguments
    const flags = [];
    const parts = flagsString.match(/(?:[^\s"]+|"[^"]*")+/g) || [];
    
    parts.forEach(part => {
      if (part.startsWith('"') && part.endsWith('"')) {
        flags.push(part.slice(1, -1));
      } else {
        flags.push(part);
      }
    });
    
    return flags;
  }

  /**
   * Log sandbox operation with consistent formatting
   */
  static logSandboxOperation(message, details = {}) {
    console.log(chalk.blue(`[sandbox] ${message}`));
    if (Object.keys(details).length > 0) {
      console.log(chalk.gray(`  ${JSON.stringify(details)}`));
    }
  }

  /**
   * Log sandbox warning
   */
  static logSandboxWarning(message) {
    console.log(chalk.yellow(`âš ï¸  [sandbox] ${message}`));
  }

  /**
   * Log sandbox error
   */
  static logSandboxError(message) {
    console.log(chalk.red(`âŒ [sandbox] ${message}`));
  }

  // OAuth Authentication Utilities

  /**
   * Create OAuth credentials for Claude CLI authentication
   * @returns {Promise<Object|null>} OAuth credentials with settings or null if failed
   */
  static async createOAuthCredentials() {
    try {
      // Get valid OAuth token from @vibe-kit/auth and full token data  
      const token = await ClaudeAuth.getValidToken();
      const tokenData = await ClaudeAuth.getRawToken();
      
      if (!token || !tokenData) {
        throw new Error('No valid authentication token');
      }

      // Generate settings JSON for onboarding bypass
      const settings = this.generateClaudeSettings(tokenData);
      
      // Return OAuth token with settings for --settings flag approach
      const credentialInfo = {
        type: 'oauth-with-settings',
        oauthToken: token,
        settings: settings,
        tokenData: tokenData
      };
      
      this.logSandboxOperation('Generated OAuth credentials with settings for onboarding bypass');
      return credentialInfo;
    } catch (error) {
      this.logSandboxWarning(`OAuth credential creation failed: ${error.message}`);
      return null;
    }
  }

  /**
   * Generate Claude CLI settings JSON for --settings flag
   * @param {Object} tokenData - Raw token data from ClaudeAuth
   * @returns {Object} Settings object for Claude CLI
   */
  static generateClaudeSettings(tokenData) {
    const settings = {
      hasCompletedOnboarding: true, // KEY: Skip first-time setup
      numStartups: 2, // Indicate it's been started before
      installMethod: 'vibekit-oauth', // Custom install method identifier
      autoUpdates: true,
      userID: this.generateUserIdFromToken(tokenData),
      tipsHistory: {
        'new-user-warmup': 1
      },
      firstStartTime: new Date().toISOString(),
      // Project-level configuration for /workspace
      projects: {
        "/workspace": {
          allowedTools: [],
          history: [],
          mcpContextUris: [],
          mcpServers: {},
          enabledMcpjsonServers: [],
          disabledMcpjsonServers: [],
          hasTrustDialogAccepted: true, // KEY: Skip trust dialog prompts
          hasTrustDialogHooksAccepted: false,
          projectOnboardingSeenCount: 1,
          hasClaudeMdExternalIncludesApproved: false,
          hasClaudeMdExternalIncludesWarningShown: false
        }
      },
      // Add OAuth account info if available
      ...(tokenData.account && {
        oauthAccount: {
          uuid: tokenData.account.uuid,
          email_address: tokenData.account.email_address
        }
      }),
      // Add organization info if available  
      ...(tokenData.organization && {
        organization: {
          uuid: tokenData.organization.uuid,
          name: tokenData.organization.name
        }
      })
    };
    
    return settings;
  }

  /**
   * Generate consistent user ID from token data
   * @param {Object} tokenData - Raw token data from ClaudeAuth
   * @returns {string} SHA256 hash of user identifier
   */
  static generateUserIdFromToken(tokenData) {
    // Use account UUID if available, otherwise generate from token
    if (tokenData.account && tokenData.account.uuid) {
      return crypto
        .createHash('sha256')
        .update(tokenData.account.uuid)
        .digest('hex');
    }
    
    // Fallback: generate from access token (consistent per user)
    return crypto
      .createHash('sha256')
      .update(tokenData.access_token.substring(0, 50)) // Use first 50 chars for consistency
      .digest('hex');
  }
}

export default SandboxUtils;


================================================
FILE: packages/cli/src/utils/aliases.js
================================================
import fs from 'fs-extra';
import path from 'path';
import os from 'os';

// Get all potential shell configuration files
function getShellConfigPaths() {
  const homedir = os.homedir();
  return [
    path.join(homedir, '.bashrc'),
    path.join(homedir, '.zshrc'),
    path.join(homedir, '.profile'),
    path.join(homedir, '.bash_profile'),
    path.join(homedir, '.zprofile'),
    path.join(homedir, '.zsh_profile')
  ];
}

// Helper functions for alias management
export async function installGlobalAliases() {
  // First remove any existing conflicting aliases
  await removeAllConflictingAliases();
  
  // Use 'vibekit' command directly instead of absolute path
  // This works for both local development (npx vibekit) and global installs
  const aliases = [
    { name: 'claude', command: `"vibekit claude"` },
    { name: 'gemini', command: `"vibekit gemini"` },
    { name: 'codex', command: `"vibekit codex"` }
  ];
  
  const shellConfigPaths = getShellConfigPaths();
  
  for (const alias of aliases) {
    for (const configPath of shellConfigPaths) {
      if (await fs.pathExists(configPath)) {
        const content = await fs.readFile(configPath, 'utf8');
        const aliasLine = `alias ${alias.name}=${alias.command}`;
        
        if (!content.includes(aliasLine)) {
          await fs.appendFile(configPath, `\n# VibeKit alias - do not modify\n${aliasLine}\n`);
        }
      }
    }
  }
  
}

// Remove all conflicting aliases (more robust than uninstallGlobalAliases)
export async function removeAllConflictingAliases() {
  const aliases = ['claude', 'gemini', 'codex'];
  const shellConfigPaths = getShellConfigPaths();
  
  for (const configPath of shellConfigPaths) {
    if (await fs.pathExists(configPath)) {
      const content = await fs.readFile(configPath, 'utf8');
      const lines = content.split('\n');
      let filteredLines = [];
      let skipNext = false;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        
        // Skip VibeKit alias comment lines
        if (line.includes('# VibeKit alias')) {
          skipNext = true;
          continue;
        }
        
        // Skip alias lines that follow VibeKit comments
        if (skipNext && (line.includes('alias claude=') || line.includes('alias gemini=') || line.includes('alias codex='))) {
          skipNext = false;
          continue;
        }
        
        // Remove any claude/gemini/codex alias that references vibekit
        let shouldSkip = false;
        for (const aliasName of aliases) {
          if (line.trim().startsWith(`alias ${aliasName}=`)) {
            // Remove ANY alias for these names that contains 'vibekit' anywhere
            // This is more aggressive but ensures proper cleanup
            if (line.includes('vibekit')) {
              shouldSkip = true;
              break;
            }
          }
        }
        
        if (shouldSkip) {
          continue;
        }
        
        filteredLines.push(line);
        skipNext = false;
      }
      
      if (filteredLines.length !== lines.length) {
        await fs.writeFile(configPath, filteredLines.join('\n'));
      }
    }
  }
}

// Legacy function for backwards compatibility
export async function uninstallGlobalAliases() {
  await removeAllConflictingAliases();

}

// Check if aliases are properly set up in current shell
export async function checkAliasesInCurrentShell() {
  const { spawn } = await import('child_process');
  
  return new Promise((resolve) => {
    const shell = process.env.SHELL || '/bin/bash';
    const shellName = path.basename(shell);
    
    // Check if aliases are defined and working
    const checkProcess = spawn(shellName, ['-i', '-c', 'alias claude 2>/dev/null && alias gemini 2>/dev/null && alias codex 2>/dev/null && echo "ALIASES_OK"'], {
      stdio: 'pipe'
    });
    
    let output = '';
    checkProcess.stdout.on('data', (data) => {
      output += data.toString();
    });
    
    checkProcess.on('close', () => {
      const hasValidAliases = output.includes('vibekit claude') && 
                             output.includes('vibekit gemini') && 
                             output.includes('vibekit codex') && 
                             output.includes('ALIASES_OK');
      resolve(hasValidAliases);
    });
    
    // Timeout after 2 seconds
    setTimeout(() => {
      checkProcess.kill();
      resolve(false);
    }, 2000);
  });
}

// Force reload shell aliases in current session
export async function reloadShellAliases() {
  const { spawn } = await import('child_process');
  const shell = process.env.SHELL || '/bin/bash';
  
  try {
    if (shell.includes('zsh') && await fs.pathExists(path.join(os.homedir(), '.zshrc'))) {
      spawn('zsh', ['-c', 'source ~/.zshrc'], { stdio: 'ignore' });
    } else if (shell.includes('bash') && await fs.pathExists(path.join(os.homedir(), '.bashrc'))) {
      spawn('bash', ['-c', 'source ~/.bashrc'], { stdio: 'ignore' });
    }
  } catch (error) {
    // Ignore errors in shell reloading
  }
}

// Unset aliases in current shell session
export async function unsetCurrentShellAliases() {
  const { spawn } = await import('child_process');
  const aliases = ['claude', 'gemini', 'codex'];
  
  return new Promise((resolve) => {
    const shell = process.env.SHELL || '/bin/bash';
    const shellName = path.basename(shell);
    
    // Create command to unset all aliases
    const unsetCommands = aliases.map(alias => `unalias ${alias} 2>/dev/null || true`).join('; ');
    
    const unsetProcess = spawn(shellName, ['-c', unsetCommands], {
      stdio: 'pipe'
    });
    
    unsetProcess.on('close', () => {
      resolve();
    });
    
    // Timeout after 2 seconds
    setTimeout(() => {
      unsetProcess.kill();
      resolve();
    }, 2000);
  });
}

export async function setupAliases(enabled) {
  if (enabled) {
    await installGlobalAliases();
    
    // Give a moment for file writes to complete, then check
    setTimeout(async () => {
      const working = await checkAliasesInCurrentShell();
    }, 500);
    
  } else {
    await uninstallGlobalAliases();
    await unsetCurrentShellAliases();
  }
}


================================================
FILE: packages/cli/src/utils/claude-settings.js
================================================
import fs from 'fs-extra';
import path from 'path';
import os from 'os';

// Function to setup proxy settings from ANTHROPIC_BASE_URL
export async function setupProxySettings(proxyEnabled = true) {
  // If proxy is disabled, don't modify settings
  if (!proxyEnabled) {
    return null;
  }

  // Look for settings files starting from current directory and walking up
  let currentDir = process.cwd();
  const settingsFiles = [];
  
  // Walk up directory tree to find .claude folder
  while (currentDir !== path.dirname(currentDir)) {
    settingsFiles.push(
      path.join(currentDir, '.claude', 'settings.local.json'),
      path.join(currentDir, '.claude', 'settings.json')
    );
    currentDir = path.dirname(currentDir);
  }
  
  // Also check home directory
  settingsFiles.push(
    path.join(os.homedir(), '.claude', 'settings.local.json'),
    path.join(os.homedir(), '.claude', 'settings.json')
  );

  for (const settingsFile of settingsFiles) {
    try {
      if (await fs.pathExists(settingsFile)) {
        const settings = await fs.readJson(settingsFile);
        
        // Ensure env section exists
        if (!settings.env) {
          settings.env = {};
        }
        
        // Store original ANTHROPIC_BASE_URL as VIBEKIT_PROXY_TARGET_URL if it exists
        if (settings.env.ANTHROPIC_BASE_URL && settings.env.ANTHROPIC_BASE_URL !== 'http://localhost:8080') {
          settings.env.VIBEKIT_PROXY_TARGET_URL = settings.env.ANTHROPIC_BASE_URL;
        }
        
        // Always set ANTHROPIC_BASE_URL to localhost:8080
        settings.env.ANTHROPIC_BASE_URL = 'http://localhost:8080';
        
        // Write back to the settings file
        await fs.writeJson(settingsFile, settings, { spaces: 2 });
        
        return settings.env.VIBEKIT_PROXY_TARGET_URL || null;
      }
    } catch (error) {
      // Ignore JSON parse errors, continue checking other files
    }
  }

  return null;
}

// Function to read Claude settings for custom VIBEKIT_PROXY_TARGET_URL
export async function getVibeKitProxyTargetURL() {
  const settingsFiles = [
    path.join(process.cwd(), '.claude', 'settings.json'),
    path.join(process.cwd(), '.claude', 'settings.local.json'),
    path.join(os.homedir(), '.claude', 'settings.json'),
    path.join(os.homedir(), '.claude', 'settings.local.json')
  ];

  for (const settingsFile of settingsFiles) {
    try {
      if (await fs.pathExists(settingsFile)) {
        const settings = await fs.readJson(settingsFile);
        
        // Check for VIBEKIT_PROXY_TARGET_URL in env section
        if (settings.env && settings.env.VIBEKIT_PROXY_TARGET_URL) {
          return settings.env.VIBEKIT_PROXY_TARGET_URL;
        }
      }
    } catch (error) {
      // Ignore JSON parse errors, continue checking other files
    }
  }

  return null;
}

// Function to revert ANTHROPIC_BASE_URL when proxy is turned off
export async function revertAnthropicBaseURL() {
  // Look for settings files starting from current directory and walking up
  let currentDir = process.cwd();
  const settingsFiles = [];
  
  // Walk up directory tree to find .claude folder
  while (currentDir !== path.dirname(currentDir)) {
    settingsFiles.push(
      path.join(currentDir, '.claude', 'settings.local.json'),
      path.join(currentDir, '.claude', 'settings.json')
    );
    currentDir = path.dirname(currentDir);
  }
  
  // Also check home directory
  settingsFiles.push(
    path.join(os.homedir(), '.claude', 'settings.local.json'),
    path.join(os.homedir(), '.claude', 'settings.json')
  );

  let modified = false;

  for (const settingsFile of settingsFiles) {
    try {
      if (await fs.pathExists(settingsFile)) {
        const settings = await fs.readJson(settingsFile);
        
        if (settings.env) {
          let fileModified = false;
          
          // If there's a VIBEKIT_PROXY_TARGET_URL, restore it as ANTHROPIC_BASE_URL
          if (settings.env.VIBEKIT_PROXY_TARGET_URL) {
            settings.env.ANTHROPIC_BASE_URL = settings.env.VIBEKIT_PROXY_TARGET_URL;
            // Remove VIBEKIT_PROXY_TARGET_URL after restoring
            delete settings.env.VIBEKIT_PROXY_TARGET_URL;
            fileModified = true;
          } else if (settings.env.ANTHROPIC_BASE_URL === 'http://localhost:8080') {
            // If ANTHROPIC_BASE_URL is set to proxy but no target URL exists, remove it
            delete settings.env.ANTHROPIC_BASE_URL;
            fileModified = true;
          }
          
          // Write back to the settings file if modified
          if (fileModified) {
            await fs.writeJson(settingsFile, settings, { spaces: 2 });
            modified = true;
          }
        }
      }
    } catch (error) {
      // Ignore JSON parse errors, continue checking other files
    }
  }

  return modified;
}


================================================
FILE: packages/cli/src/utils/redaction.js
================================================
export function initializeSensitivePatterns() {
  return [
    // ==== OPENAI & AI PROVIDERS - Keep specific API key patterns ====
    /sk-proj-[A-Za-z0-9_-]{20,}/g,                // OpenAI project-scoped key
    /dtn_[A-Za-z0-9_]{60,}/g,                     // Daytona API key
    /e2b_[A-Za-z0-9_]{32,}/g,                     // E2B API key
    /sk-ant-[A-Za-z0-9_-]{20,}/g,                 // Anthropic API key
    /sk-or-[A-Za-z0-9_-]{20,}/g,                  // OpenAI org-scoped key
    /sk-[A-Za-z0-9_-]{24,}/g,                     // OpenAI generic secret
    /gsk_[A-Za-z0-9_-]{20,}/g,                    // Google Generative AI Studio key
    /xai-[A-Za-z0-9_-]{20,}/g,                    // xAI key

    // ==== GITHUB - Keep specific token patterns ====
    /ghp_[A-Za-z0-9_]{36}/g,                      // GitHub PAT (classic)
    /gho_[A-Za-z0-9_]{36}/g,                      // GitHub OAuth token
    /ghs_[A-Za-z0-9_]{36}/g,                      // GitHub App server-to-server
    /ghu_[A-Za-z0-9_]{36}/g,                      // GitHub App user-to-server
    /ghr_[A-Za-z0-9_]{36}/g,                      // GitHub refresh token
    /github_pat_[A-Za-z0-9_]{22}_[A-Za-z0-9_]{59}/g, // GitHub fine-grained PAT

    // ==== GITLAB ====
    /glpat-[A-Za-z0-9_-]{20,}/g,                  // GitLab PAT

    // ==== AWS - Keep specific patterns ====
    /AKIA[0-9A-Z]{16}/g,                          // AWS access key ID (long-lived)
    /ASIA[0-9A-Z]{16}/g,                          // AWS temporary access key ID
    /(aws_)?secret(access)?(_)?key\s*[:=]\s*["']?[A-Za-z0-9\/+=]{35,}["']?/gi, // AWS secret key

    // ==== GOOGLE API KEYS ====
    /AIza[0-9A-Za-z-_]{35}/g,                     // Google API key (common AIza prefix)
    /ya29\.[0-9A-Za-z-_]+/g,                      // Google OAuth access token
    /GOCSPX-[A-Za-z0-9-_]{20,}/g,                 // Google OAuth client secret

    // ==== SLACK ====
    /xoxb-[A-Za-z0-9-]{10,}-[A-Za-z0-9-]{10,}-[A-Za-z0-9-]{20,}/g, // Slack bot token
    /xoxp-[A-Za-z0-9-]{10,}-[A-Za-z0-9-]{10,}-[A-Za-z0-9-]{20,}/g, // Slack user token
    /xoxa-[A-Za-z0-9-]{10,}-[A-Za-z0-9-]{10,}-[A-Za-z0-9-]{20,}/g, // Slack workspace token
    /xapp-1-[A-Z0-9-]{10,}-[0-9]{13,}-[A-Za-z0-9]{64,}/g,          // Slack App level token

    // ==== STRIPE ====
    /sk_live_[0-9a-zA-Z]{24,}/g,                  // Stripe live secret key
    /sk_test_[0-9a-zA-Z]{24,}/g,                  // Stripe test secret key
    /rk_live_[0-9a-zA-Z]{24,}/g,                  // Stripe restricted key live
    /rk_test_[0-9a-zA-Z]{24,}/g,                  // Stripe restricted key test
    /whsec_[A-Za-z0-9]{32,}/g,                    // Stripe webhook secret

    // ==== TWILIO ====
    /AC[0-9a-fA-F]{32}/g,                         // Twilio Account SID
    /SK[0-9a-fA-F]{32}/g,                         // Twilio API Key SID

    // ==== SENDGRID / MAIL PROVIDERS ====
    /SG\.[A-Za-z0-9_\-\.]{66}/g,                  // SendGrid API key
    /key-[0-9a-f]{32}/g,                          // Mailgun API key (specific with 'key-' prefix)
    /xkeysib-[A-Za-z0-9]{64}-[A-Za-z0-9]{16}/g,   // SendInBlue API key

    // ==== PAYMENT / CREDIT CARDS ====
    /\b4[0-9]{12}(?:[0-9]{3})?\b/g,               // Visa (no spaces)
    /\b4[0-9]{3}[\s-]?[0-9]{4}[\s-]?[0-9]{4}[\s-]?[0-9]{4}\b/g, // Visa (with spaces/dashes)
    /\b5[1-5][0-9]{14}\b/g,                       // MasterCard (no spaces)
    /\b5[1-5][0-9]{2}[\s-]?[0-9]{4}[\s-]?[0-9]{4}[\s-]?[0-9]{4}\b/g, // MasterCard (with spaces/dashes)
    /\b3[47][0-9]{13}\b/g,                        // AmEx (no spaces)
    /\b3[47][0-9]{2}[\s-]?[0-9]{6}[\s-]?[0-9]{5}\b/g, // AmEx (with spaces/dashes)
    /\b6(?:011|5[0-9]{2})[0-9]{12}\b/g,           // Discover (no spaces)
    /\b6(?:011|5[0-9]{2})[\s-]?[0-9]{4}[\s-]?[0-9]{4}[\s-]?[0-9]{4}\b/g, // Discover (with spaces/dashes)


    // ==== EMAIL ADDRESSES ====
    /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/g, // Email addresses

    // ==== DATABASE CONNECTION STRINGS - With passwords ====
    /\bpostgres(?:ql)?:\/\/[A-Za-z0-9_%+.-]+:[^@\s]{1,}@[^\s]+\/[A-Za-z0-9_.-]+/g,
    /\bmongodb(?:\+srv)?:\/\/[A-Za-z0-9_%+.-]+:[^@\s]{1,}@[^\s]+\/[A-Za-z0-9_.-]+/g,
    /\bmysql:\/\/[A-Za-z0-9_%+.-]+:[^@\s]{1,}@[^\s]+\/[A-Za-z0-9_.-]+/g,
    /\bredis:\/\/[A-Za-z0-9_%+.-]+:[^@\s]{1,}@[A-Za-z0-9_.:-]+/g,

    // ==== JWT TOKENS ====
    /\beyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\b/g, // JWT tokens

    // ==== SSH KEYS ====
    /-----BEGIN (?:RSA|DSA|EC|OPENSSH) PRIVATE KEY-----[\s\S]+?-----END (?:RSA|DSA|EC|OPENSSH) PRIVATE KEY-----/g,

    // ==== OTHER SPECIFIC API KEYS ====
    /\bDD_API_KEY\b[^\n]{0,40}[:=]\s*[0-9a-f]{32}\b/gi,         // Datadog
    /\bDD_APP_KEY\b[^\n]{0,40}[:=]\s*[0-9a-f]{40}\b/gi,         // Datadog
    /NRAK-[A-Z0-9]{27}/g,                                        // New Relic ingest key
    /NRAL-[A-Z0-9]{27}/g,                                        // New Relic license key
    /shpat_[a-f0-9]{32}/g,                                       // Shopify private app access token
    /shpss_[a-f0-9]{32}/g,                                       // Shopify shared secret
    /npm_[A-Za-z0-9]{36}/g,                                      // npm access token
    /\bpypi-AgENdGV\w{20,}\b/g,                                 // PyPI token
    /EAA[A-Za-z0-9]{20,}/g,                                      // Facebook access token
    /\bBearer\s+AAAAAAAA[A-Za-z0-9%\-_]{20,}/g,                 // Twitter bearer token
    /lin_[A-Za-z0-9]{40}/g,                                      // Linear API key
    /secret_[A-Za-z0-9]{43}/g,                                   // Notion token
    // Removed: key[A-Za-z0-9]{14} - too broad, would catch regular file names
    /CFPAT-[A-Za-z0-9_-]{50,}/g,                                // Contentful API token
    /sdk-[A-Za-z0-9_-]{32,}/g,                                  // LaunchDarkly SDK key (made more specific)
    /mob-[A-Za-z0-9_-]{32,}/g,                                  // LaunchDarkly Mobile key (made more specific)
    /r8_[A-Za-z0-9]{32,}/g,                                      // Replicate API token

    // ==== CRYPTO WALLETS ====
    /\b0x[a-fA-F0-9]{40}\b/g,                                    // Ethereum address
    /\b[13][a-km-zA-HJ-NP-Z1-9]{25,34}\b/g,                     // Bitcoin (legacy)
    /\bbc1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{11,71}\b/g,       // Bitcoin Bech32

    // ==== SPECIFIC SECRET PATTERNS WITH CONTEXT ====
    /\b(SECRET_KEY|API_SECRET|CLIENT_SECRET|PRIVATE_KEY)\b\s*[:=]\s*["']?[A-Za-z0-9\-_.+/=]{16,}["']?/gi,
    /\b(password|passwd|pwd)\b\s*[:=]\s*["']?[^\s"']{8,}["']?/gi,
    /\b(api_key|apikey|api_token|access_token)\b\s*[:=]\s*["']?[A-Za-z0-9\-_.]{16,}["']?/gi,
  ];
}


================================================
FILE: packages/cli/test/setup.js
================================================
import { vi } from 'vitest';

// Global test setup
beforeEach(() => {
  // Clear all timers
  vi.useRealTimers();
  
  // Reset environment variables
  delete process.env.VIBEKIT_DEBUG;
  delete process.env.VIBEKIT_CREDENTIALS_ENABLED;
  delete process.env.VIBEKIT_CACHE_ENABLED;
  delete process.env.VIBEKIT_VOLUME_DEBUG;
  
  // Mock console methods to avoid noise in tests
  vi.spyOn(console, 'log').mockImplementation(() => {});
  vi.spyOn(console, 'warn').mockImplementation(() => {});
  vi.spyOn(console, 'error').mockImplementation(() => {});
});

afterEach(() => {
  vi.restoreAllMocks();
});


================================================
FILE: packages/cli/test/vitest.config.js
================================================
import { defineConfig } from 'vitest/config';
import { resolve } from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./packages/cli/test/setup.js'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'test/',
        'dist/',
        '**/*.test.js',
        '**/*.spec.js'
      ]
    },
    testTimeout: 10000, // 10 seconds for Docker operations
    hookTimeout: 10000
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, '../src'),
      '@test': resolve(__dirname, '../test')
    }
  }
});


================================================
FILE: packages/cli/test/sandbox/sandbox-utils.test.js
================================================
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { ClaudeAuth } from '@vibe-kit/auth/node';
import SandboxUtils from '../../src/sandbox/sandbox-utils.js';

// Mock dependencies
vi.mock('@vibe-kit/auth/node');

describe('SandboxUtils OAuth Methods', () => {
  beforeEach(() => {
    // Reset all mocks
    vi.clearAllMocks();
    
    // Mock console methods to avoid noise in test output
    vi.spyOn(console, 'log').mockImplementation(() => {});
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('createOAuthCredentials', () => {
    test('should create OAuth credentials with settings for valid token', async () => {
      const mockToken = 'sk-ant-test-token';
      const mockTokenData = {
        access_token: mockToken,
        account: {
          uuid: 'test-uuid',
          email_address: 'test@example.com'
        },
        organization: {
          uuid: 'org-uuid',
          name: 'Test Org'
        }
      };

      vi.mocked(ClaudeAuth.getValidToken).mockResolvedValue(mockToken);
      vi.mocked(ClaudeAuth.getRawToken).mockResolvedValue(mockTokenData);

      const result = await SandboxUtils.createOAuthCredentials();

      expect(result).toEqual({
        type: 'oauth-with-settings',
        oauthToken: mockToken,
        settings: expect.objectContaining({
          hasCompletedOnboarding: true,
          projects: {
            "/workspace": expect.objectContaining({
              hasTrustDialogAccepted: true
            })
          }
        }),
        tokenData: mockTokenData
      });
    });

    test('should return null when token is invalid', async () => {
      vi.mocked(ClaudeAuth.getValidToken).mockResolvedValue(null);
      vi.mocked(ClaudeAuth.getRawToken).mockResolvedValue(null);

      const result = await SandboxUtils.createOAuthCredentials();

      expect(result).toBeNull();
    });

    test('should return null when ClaudeAuth throws error', async () => {
      vi.mocked(ClaudeAuth.getValidToken).mockRejectedValue(new Error('Auth failed'));

      const result = await SandboxUtils.createOAuthCredentials();

      expect(result).toBeNull();
    });
  });

  describe('generateClaudeSettings', () => {
    test('should generate proper settings structure', () => {
      const mockTokenData = {
        access_token: 'test-token',
        account: {
          uuid: 'test-uuid',
          email_address: 'test@example.com'
        },
        organization: {
          uuid: 'org-uuid',
          name: 'Test Org'
        }
      };

      const settings = SandboxUtils.generateClaudeSettings(mockTokenData);

      expect(settings).toEqual({
        hasCompletedOnboarding: true,
        numStartups: 2,
        installMethod: 'vibekit-oauth',
        autoUpdates: true,
        userID: expect.any(String),
        tipsHistory: {
          'new-user-warmup': 1
        },
        firstStartTime: expect.any(String),
        projects: {
          "/workspace": {
            allowedTools: [],
            history: [],
            mcpContextUris: [],
            mcpServers: {},
            enabledMcpjsonServers: [],
            disabledMcpjsonServers: [],
            hasTrustDialogAccepted: true,
            hasTrustDialogHooksAccepted: false,
            projectOnboardingSeenCount: 1,
            hasClaudeMdExternalIncludesApproved: false,
            hasClaudeMdExternalIncludesWarningShown: false
          }
        },
        oauthAccount: {
          uuid: 'test-uuid',
          email_address: 'test@example.com'
        },
        organization: {
          uuid: 'org-uuid',
          name: 'Test Org'
        }
      });
    });

    test('should handle minimal token data', () => {
      const mockTokenData = {
        access_token: 'test-token'
      };

      const settings = SandboxUtils.generateClaudeSettings(mockTokenData);

      expect(settings.hasCompletedOnboarding).toBe(true);
      expect(settings.userID).toBeDefined();
      expect(settings.projects["/workspace"].hasTrustDialogAccepted).toBe(true);
      expect(settings.oauthAccount).toBeUndefined();
      expect(settings.organization).toBeUndefined();
    });
  });

  describe('generateUserIdFromToken', () => {
    test('should generate user ID from account UUID', () => {
      const mockTokenData = {
        account: {
          uuid: 'test-uuid'
        }
      };

      const userId = SandboxUtils.generateUserIdFromToken(mockTokenData);

      // Should generate a consistent hash from the UUID
      expect(userId).toHaveLength(64); // SHA256 hash length
      expect(userId).toMatch(/^[a-f0-9]+$/); // Hex string
      
      // Should be deterministic - same input produces same output
      const userId2 = SandboxUtils.generateUserIdFromToken(mockTokenData);
      expect(userId).toBe(userId2);
    });

    test('should generate user ID from access token when no account UUID', () => {
      const mockTokenData = {
        access_token: 'test-access-token-for-fallback-generation'
      };

      const userId = SandboxUtils.generateUserIdFromToken(mockTokenData);

      // Should generate a consistent hash from the access token
      expect(userId).toHaveLength(64); // SHA256 hash length
      expect(userId).toMatch(/^[a-f0-9]+$/); // Hex string
      
      // Should be deterministic - same input produces same output
      const userId2 = SandboxUtils.generateUserIdFromToken(mockTokenData);
      expect(userId).toBe(userId2);
    });

    test('should prefer account UUID over access token', () => {
      const mockTokenData = {
        access_token: 'test-access-token',
        account: {
          uuid: 'test-uuid'
        }
      };

      const userId1 = SandboxUtils.generateUserIdFromToken(mockTokenData);
      
      // Remove account UUID to test fallback
      const mockTokenDataWithoutAccount = {
        access_token: 'test-access-token'
      };
      
      const userId2 = SandboxUtils.generateUserIdFromToken(mockTokenDataWithoutAccount);
      
      // Should be different since one uses UUID and other uses access token
      expect(userId1).not.toBe(userId2);
    });
  });
});


================================================
FILE: packages/cloudflare/README.md
================================================
# @vibe-kit/cloudflare

Cloudflare sandbox provider for VibeKit - Run sandboxed code environments on Cloudflare's edge network.

## Installation

```bash
npm install @vibe-kit/cloudflare
```

## Usage

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createCloudflareProvider } from "@vibe-kit/cloudflare";

// This must be called within a Cloudflare Worker
const provider = createCloudflareProvider({
  env: env, // Your Worker's env object containing the Sandbox binding
  hostname: "your-worker.domain.workers.dev", // Your Worker's hostname for preview URLs
});

const vibeKit = new VibeKit()
  .withSandbox(provider)
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })

// Use the sandbox
const result = await vibeKit.generateCode({
  prompt: "Create a simple web server using Node.js",
  mode: "code",
});
```

## Configuration

The `createCloudflareProvider` function accepts a configuration object with these properties:

- `env` (required): Your Cloudflare Worker's environment object containing the `Sandbox` Durable Object binding
- `hostname` (required): Your Worker's hostname used for generating preview URLs when exposing ports

## Cloudflare Worker Setup

Unlike other VibeKit providers, Cloudflare sandboxes run exclusively within Cloudflare Workers and use Cloudflare's container platform built on Durable Objects. Here's how to set up your Worker:

### 1. Configure wrangler.json

```jsonc
{
  "name": "my-vibekit-worker",
  "main": "src/index.ts",
  "compatibility_date": "2024-01-01",
  "containers": [
    {
      "class_name": "Sandbox",
      "image": "./node_modules/@cloudflare/sandbox/Dockerfile",
      "max_instances": 1
    }
  ],
  "durable_objects": {
    "bindings": [
      {
        "class_name": "Sandbox",
        "name": "Sandbox"
      }
    ]
  },
  "migrations": [
    {
      "new_sqlite_classes": ["Sandbox"],
      "tag": "v1"
    }
  ]
}
```

### 3. Create your Worker

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createCloudflareProvider, proxyToSandbox } from "@vibe-kit/cloudflare";

// Export the Sandbox class for Durable Objects
export { Sandbox } from "@cloudflare/sandbox";

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Handle preview URL routing for exposed ports
    const proxyResponse = await proxyToSandbox(request, env);
    if (proxyResponse) return proxyResponse;

    // Handle VibeKit requests
    if (new URL(request.url).pathname === "/vibekit") {
      const provider = createCloudflareProvider({
        env,
        hostname: request.headers.get("host") || "localhost",
      });

      const vibeKit = new VibeKit()
        .withSandbox(provider)
        .withAgent({
          type: "claude",
          provider: "anthropic",
          apiKey: process.env.ANTHROPIC_API_KEY!,
          model: "claude-sonnet-4-20250514",
        })

      const result = await vibeKit.generateCode({
        prompt: "Create a Node.js web server",
        mode: "code",
      });

      return new Response(JSON.stringify(result), {
        headers: { "Content-Type": "application/json" },
      });
    }

    return new Response("Not Found", { status: 404 });
  },
};
```

## Local Development

For local development with `wrangler dev`, only ports explicitly exposed in the Dockerfile are available for port forwarding. This is not an issue in production.

To test multiple ports locally, create a custom Dockerfile:

```dockerfile
FROM docker.io/cloudflare/sandbox:0.1.3

EXPOSE 3000
EXPOSE 8080
EXPOSE 3001

# Always end with the same command as the base image
CMD ["bun", "index.ts"]
```

Then update your wrangler.json to use the custom Dockerfile:

```jsonc
{
  "containers": [
    {
      "class_name": "Sandbox",
      "image": "./Dockerfile",  // Point to your custom Dockerfile
      "max_instances": 1
    }
  ]
}
```

## Requirements

- **Cloudflare Workers**: Must run within a Cloudflare Worker environment
- **Wrangler**: For local development and deployment
- **Docker**: For building container images (happens automatically via wrangler)
- **Node.js 18+**: For development tooling

## Environment Variables

Set the keys you need in your Worker's environment:

- `ANTHROPIC_API_KEY`: Required for using Anthropic Claude models
- `OPENAI_API_KEY`: Required for using OpenAI models
- `GOOGLE_API_KEY`: Required for using Google Gemini models

## License

MIT



================================================
FILE: packages/cloudflare/Dockerfile
================================================
FROM docker.io/cloudflare/sandbox:0.1.3

# Set up Bun environment
ENV BUN_INSTALL="/home/.bun"
ENV PATH="$BUN_INSTALL/bin:$PATH"
RUN bun add -g @anthropic-ai/claude-code@latest
RUN bun add -g @openai/codex@latest
RUN bun add -g @google/gemini-cli@latest
RUN bun add -g opencode-ai@latest
RUN bun add -g @vibe-kit/grok-cli@latest

# Expose common local development ports
# https://developers.cloudflare.com/containers/local-dev/#exposing-ports
# Currently, only explicitly exposed ports can be used for port-forwarding
# when developing locally. In prod, any port can be accessed and this is
# not needed.
EXPOSE 3001
EXPOSE 8080

# Run the same command as the original image
CMD ["bun", "index.ts"]



================================================
FILE: packages/cloudflare/package.json
================================================
{
  "name": "@vibe-kit/cloudflare",
  "version": "0.0.8",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist/",
    "Dockerfile",
    "patches/"
  ],
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    }
  },
  "scripts": {
    "build": "tsup src/index.ts --format esm,cjs --dts",
    "dev": "tsup src/index.ts --watch",
    "type-check": "tsc --noEmit"
  },
  "peerDependencies": {
    "@vibe-kit/sdk": "*"
  },
  "dependencies": {
    "@cloudflare/sandbox": "^0.1.3",
    "patch-package": "^8.0.0"
  },
  "devDependencies": {
    "@types/node": "^22.15.18",
    "tsup": "^8.4.0",
    "typescript": "^5.8.3",
    "wrangler": "^4.26.0"
  }
}



================================================
FILE: packages/cloudflare/tsconfig.json
================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


================================================
FILE: packages/cloudflare/src/index.ts
================================================
import { getSandbox, type LogEvent, parseSSEStream, type Sandbox, type SandboxEnv } from "@cloudflare/sandbox";

// Define the interfaces we need from the SDK
export interface SandboxExecutionResult {
  exitCode: number;
  stdout: string;
  stderr: string;
}

export interface SandboxCommandOptions {
  timeoutMs?: number;
  background?: boolean;
  onStdout?: (data: string) => void;
  onStderr?: (data: string) => void;
}

export interface SandboxCommands {
  run(
    command: string,
    options?: SandboxCommandOptions
  ): Promise<SandboxExecutionResult>;
}

export interface SandboxInstance {
  sandboxId: string;
  commands: SandboxCommands;
  kill(): Promise<void>;
  pause(): Promise<void>;
  getHost(port: number): Promise<string>;
}

export interface SandboxProvider {
  create(
    envs?: Record<string, string>,
    agentType?: "codex" | "claude" | "opencode" | "gemini",
    workingDirectory?: string
  ): Promise<SandboxInstance>;
  resume(sandboxId: string): Promise<SandboxInstance>;
}

export type AgentType = "codex" | "claude" | "opencode" | "gemini";

export interface CloudflareConfig {
  env: SandboxEnv;
  hostname: string;
}

// Cloudflare implementation
export class CloudflareSandboxInstance implements SandboxInstance {
  constructor(
    private sandbox: Sandbox,
    public sandboxId: string,
    private hostname: string,
  ) { }

  private async handleBackgroundCommand(command: string, options?: SandboxCommandOptions) {
    const response = await this.sandbox.startProcess(command);

    // Defer log streaming to avoid blocking the return
    (async () => {
      try {
        const logStream = await this.sandbox.streamProcessLogs(response.id);
        for await (const log of parseSSEStream<LogEvent>(logStream)) {
          if (log.type === 'stdout') {
            options?.onStdout?.(log.data);
          } else if (log.type === 'stderr') {
            options?.onStderr?.(log.data);
          } else if (log.type === 'exit') {
            await this.sandbox.killProcess(response.id);
          } else if (log.type === 'error') {
            options?.onStderr?.(log.data);
            await this.sandbox.killProcess(response.id);
          }
        }
      } catch (error) {
        console.error('Background log streaming error:', error);
      }
    })();

    // Return immediately for background commands
    return {
      exitCode: 0,
      stdout: "Background command started successfully",
      stderr: "",
    };
  }

  private async handleForegroundCommand(command: string, options?: SandboxCommandOptions) {
    const response = await this.sandbox.exec(command, {
      stream: true,
      onOutput(stream, data) {
        if (stream === 'stdout') {
          options?.onStdout?.(data);
        } else if (stream === 'stderr') {
          options?.onStderr?.(data);
        }
      },
    });

    return response;
  }

  get commands(): SandboxCommands {
    return {
      run: (command: string, options?: SandboxCommandOptions) => {
        return options?.background
          ? this.handleBackgroundCommand(command, options)
          : this.handleForegroundCommand(command, options);
      },
    };
  }

  async kill(): Promise<void> {
    await this.sandbox.destroy();
  }

  async pause(): Promise<void> {
    await this.sandbox.stop();
  }

  async getHost(port: number): Promise<string> {
    const response = await this.sandbox.exposePort(port, { name: 'vibekit', hostname: this.hostname });
    return response.url;
  }
}

export class CloudflareSandboxProvider implements SandboxProvider {
  constructor(private config: CloudflareConfig) { }

  async create(
    envs?: Record<string, string>,
    agentType?: AgentType,
    workingDirectory?: string
  ): Promise<SandboxInstance> {
    if (!this.config.env || !this.config.env.Sandbox) {
      throw new Error(
        `Cloudflare Durable Object binding "Sandbox" not found. ` +
        `Make sure you're running within a Cloudflare Worker and the binding is configured in wrangler.json/toml`
      );
    }

    // Generate a unique sandbox ID
    const sandboxId = `vibekit-${agentType || 'default'}-${Date.now()}`;

    // Get or create a sandbox instance using the SDK
    const sandbox = getSandbox(this.config.env.Sandbox, sandboxId) as Sandbox;
    sandbox.setEnvVars(envs || {});
    await sandbox.exec(`sudo mkdir -p ${workingDirectory} && sudo chown $USER:$USER ${workingDirectory}`);

    return new CloudflareSandboxInstance(sandbox, sandboxId, this.config.hostname);
  }

  async resume(sandboxId: string): Promise<SandboxInstance> {
    const sandbox = getSandbox(this.config.env.Sandbox, sandboxId) as Sandbox;
    return new CloudflareSandboxInstance(sandbox, sandboxId, this.config.hostname);
  }
}

export function createCloudflareProvider(
  config: CloudflareConfig
): CloudflareSandboxProvider {
  return new CloudflareSandboxProvider(config);
}



================================================
FILE: packages/dagger/README.md
================================================
# @vibe-kit/dagger

Local sandbox provider for Vibekit using [Dagger](https://dagger.io).

## Overview

The `@vibe-kit/dagger` package enables Vibekit to run AI coding agents in isolated, containerized environments on your local machine. This provides an alternative to cloud-based sandboxes, offering faster iteration, offline development, and cost savings.

## System Requirements

### Required Dependencies
- **Docker**: Container runtime for isolation
- **Dagger**: Container orchestration engine

### Supported Platforms
- macOS (recommended)
- Linux
- Windows (WSL2)

### Minimum System Resources
- 8GB RAM (16GB recommended for multiple environments)
- 10GB free disk space
- Modern CPU with virtualization support

## Installation

The local provider is automatically available when you install Vibekit. System dependencies are installed automatically when you first use the local provider:

```bash
# Initialize with local provider
vibekit init --provider dagger

# Or add to existing project
vibekit dagger setup
```

### Manual Dependency Installation

If automatic installation fails, you can install dependencies manually:

```bash
# Install Docker (platform-specific)
# See: https://docs.docker.com/get-docker/

# Install Dagger
curl -fsSL https://dagger.io/install.sh | bash

# Verify installation
dagger version
```

## Usage

### Basic API Usage

```typescript
import { createLocalProvider } from '@vibe-kit/dagger';

// Create a local provider
const provider = createLocalProvider();

// Create a sandbox instance
const sandbox = await provider.create(
  { NODE_ENV: 'development' }, // environment variables
  'claude',                    // agent type
  '/vibe0'                     // working directory
);

// Execute commands
const result = await sandbox.commands.run('npm install');
console.log(result.stdout);

// Clean up
await sandbox.kill();
```

### Configuration

```typescript
import { createLocalProvider, LocalDaggerConfig } from '@vibe-kit/dagger';

const config: LocalDaggerConfig = {
  // Configuration options for the local provider
};

const provider = createLocalProvider(config);
```

## Architecture

The local provider consists of several key components:

- **Dagger Integration**: Low-level container orchestration
- **Environment Manager**: Lifecycle and state management
- **Container Persistence**: Workspace state across commands
- **Agent Configuration**: Support for multiple agent types
- **Resource Management**: Docker container orchestration

## Agent Support

The local provider supports all Vibekit agent types:

- **Claude**: Uses `assets/dockerfiles/Dockerfile.claude`
- **Codex**: Uses `assets/dockerfiles/Dockerfile.codex`
- **OpenCode**: Uses `assets/dockerfiles/Dockerfile.opencode`
- **Gemini**: Uses `assets/dockerfiles/Dockerfile.gemini`

Each agent type can have its own optimized container image for better performance.

## Security Considerations

Local sandboxes run in Docker containers with the following isolation:

- **File System**: Containers cannot access host files outside mounted volumes
- **Network**: Containers run in isolated Docker networks
- **Process**: Complete process isolation from host system
- **Resources**: Configurable CPU and memory limits

## Interface Compatibility

This package implements the same `SandboxProvider` interface as other Vibekit providers:

```typescript
interface SandboxProvider {
  create(envs?, agentType?, workingDirectory?): Promise<SandboxInstance>;
  resume(sandboxId: string): Promise<SandboxInstance>;
}

interface SandboxInstance {
  sandboxId: string;
  commands: SandboxCommands;
  kill(): Promise<void>;
  pause(): Promise<void>;
  getHost(port: number): Promise<string>;
}
```

This ensures you can swap between local and cloud providers seamlessly.

## Troubleshooting

### Common Issues

**Docker not running:**
```bash
# Check Docker status
docker ps

# Start Docker Desktop (macOS/Windows)
# Or start Docker daemon (Linux)
```

**Dagger not found:**
```bash
# Reinstall Dagger
curl -fsSL https://dagger.io/install.sh | bash

# Check PATH
which dagger
```

**Permission errors:**
```bash
# Add user to docker group (Linux)
sudo usermod -aG docker $USER
# Then log out and back in
```

### Debug Mode

Enable verbose logging for troubleshooting:

```bash
export VIBEKIT_LOG_LEVEL=debug
# Your Vibekit commands here
```

## Contributing

See the main [Vibekit contribution guide](../../CONTRIBUTING.md) for general guidelines.

### Local Development

```bash
# Clone the repository
git clone https://github.com/vibekit/vibekit.git
cd vibekit

# Install dependencies
npm install

# Build the dagger package
cd packages/dagger
npm run build

# Run tests
npm test
```

## License

MIT - see [LICENSE](../../LICENSE) for details. 


================================================
FILE: packages/dagger/package.json
================================================
{
  "name": "@vibe-kit/dagger",
  "version": "0.0.8",
  "description": "Local sandbox provider for Vibekit using Dagger",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist/**/*",
    "README.md"
  ],
  "scripts": {
    "build": "tsup",
    "build:types": "tsup --dts-only",
    "dev": "tsup --watch",
    "test": "vitest",
    "type-check": "tsc --noEmit"
  },
  "keywords": [
    "vibekit",
    "local",
    "sandbox",
    "dagger",
    "development"
  ],
  "author": "Vibekit Team",
  "license": "MIT",
  "dependencies": {
    "@dagger.io/dagger": "^0.18.14"
  },
  "peerDependencies": {
    "@vibe-kit/sdk": "*"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "tsup": "^8.0.0",
    "typescript": "^5.0.0",
    "vitest": "^1.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/vibekit/vibekit.git",
    "directory": "packages/local"
  }
}



================================================
FILE: packages/dagger/tsconfig.json
================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
} 


================================================
FILE: packages/dagger/tsup.config.ts
================================================
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['cjs', 'esm'],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
}); 


================================================
FILE: packages/dagger/vitest.config.ts
================================================
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    testTimeout: 30000, // 30 seconds for integration tests
    hookTimeout: 10000, // 10 seconds for setup/teardown
    globals: true,
  },
  esbuild: {
    target: 'node18',
  },
}); 


================================================
FILE: packages/dagger/src/index.ts
================================================
/**
 * @vibe-kit/dagger - Local Sandbox Provider
 *
 * Main entry point for the local provider package.
 * Exports all public APIs for Dagger integration and setup utilities.
 */

// Environment type for compatibility with other packages
export interface Environment {
  id: string;
  name: string;
  status: "running" | "stopped" | "pending" | "error";
  agentType?: string;
  createdAt?: Date;
  lastUsed?: Date;
  branch?: string;
  environment?: {
    VIBEKIT_AGENT_TYPE?: string;
    AGENT_TYPE?: string;
    [key: string]: string | undefined;
  };
}

// Dagger integration - matching other providers' interface pattern
export {
  LocalSandboxProvider,
  createLocalProvider,
  prebuildAgentImages,
  // Docker registry setup functions
  setupUserDockerRegistry,
  checkDockerLogin,
  uploadImagesToUserAccount,
  getVibeKitConfig,
  saveVibeKitConfig,
  type LocalConfig,
  type AgentType,
  type SandboxInstance,
  type SandboxProvider,
  type SandboxCommands,
  type SandboxExecutionResult,
  type SandboxCommandOptions,
  // Docker registry types
  type DockerLoginInfo,
  type VibeKitConfig,
} from "./dagger/vibekit-dagger";

// Alias for backwards compatibility - keep the old Dagger names available
export { LocalSandboxProvider as LocalDaggerSandboxProvider } from "./dagger/vibekit-dagger";
export type { LocalConfig as LocalDaggerConfig } from "./dagger/vibekit-dagger";

// Setup and installation utilities
export {
  setupLocalProvider,
  prebuildSpecificAgents,
  validateDependencies,
  checkSetupStatus,
  cleanupPreBuiltImages,
  type SetupOptions,
  type SetupResult,
} from "./setup/installer";

// Environment storage
export {
  EnvironmentStore,
  type EnvironmentRecord,
} from "./storage/environment-store";



================================================
FILE: packages/dagger/src/provider.ts
================================================
/**
 * Local Sandbox Provider
 * 
 * Re-exports the Dagger-based implementation for backwards compatibility.
 * This file maintains the same interface as other VibeKit providers.
 */

// Re-export everything from the Dagger implementation
export * from './dagger/vibekit-dagger'; 


================================================
FILE: packages/dagger/src/dagger/registry-integration.ts
================================================
/**
 * Registry Integration Bridge
 * 
 * Provides backward compatibility by bridging Dagger package functions
 * to the new shared registry infrastructure.
 */

import { Configuration } from "./vibekit-dagger";

// Import types and classes dynamically to avoid circular dependencies
type DockerLoginInfo = {
  isLoggedIn: boolean;
  username?: string | null;
  registry?: string;
};

type VibeKitConfig = {
  dockerHubUser?: string;
  lastImageBuild?: string;
  registryImages?: Partial<Record<AgentType, string>>;
  privateRegistry?: string;
  preferRegistryImages?: boolean;
  pushImages?: boolean;
  [key: string]: any;
};

type AgentType = "codex" | "claude" | "opencode" | "gemini" | "grok";

// Dynamic imports to avoid circular dependencies
let DockerClient: any = null;
let ConfigManager: any = null;
let DockerHubRegistry: any = null;
let RegistryManager: any = null;

async function getDockerClient() {
  if (!DockerClient) {
    // Import from services module
    const servicesPath = '@vibe-kit/sdk/services';
    const servicesModule = await import(servicesPath).catch(() => null);
    if (servicesModule) {
      DockerClient = servicesModule.DockerClient;
    }
  }
  
  if (!DockerClient) {
    throw new Error("DockerClient not available. Please ensure @vibe-kit/sdk is properly installed.");
  }
  
  const config = Configuration.getInstance().get();
  const logger = Configuration.getInstance().getLogger();
  
  return new DockerClient({
    retryAttempts: config.retryAttempts,
    retryDelayMs: config.retryDelayMs,
    logger,
  });
}

async function getConfigManager() {
  if (!ConfigManager) {
    // Import from services module
    const servicesPath = '@vibe-kit/sdk/services';
    const servicesModule = await import(servicesPath).catch(() => null);
    if (servicesModule) {
      ConfigManager = servicesModule.ConfigManager;
    }
  }
  
  if (!ConfigManager) {
    throw new Error("ConfigManager not available. Please ensure @vibe-kit/sdk is properly installed.");
  }
  
  const config = Configuration.getInstance().get();
  const logger = Configuration.getInstance().getLogger();
  
  return new ConfigManager({
    configPath: config.configPath,
    logger,
  });
}

async function getRegistryManager() {
  if (!DockerHubRegistry || !RegistryManager) {
    const registryPath = '@vibe-kit/sdk/registry';
    const registryModule = await import(registryPath).catch(() => null);
    if (registryModule) {
      DockerHubRegistry = registryModule.DockerHubRegistry;
      RegistryManager = registryModule.RegistryManager;
    }
  }
  
  if (!DockerHubRegistry || !RegistryManager) {
    throw new Error("Registry modules not available. Please ensure @vibe-kit/sdk is properly installed.");
  }
  
  const logger = Configuration.getInstance().getLogger();
  const dockerHubRegistry = new DockerHubRegistry({ logger });
  
  const registryManager = new RegistryManager({
    defaultRegistry: 'dockerhub',
    logger,
  });
  
  registryManager.registerRegistry('dockerhub', dockerHubRegistry);
  return registryManager;
}

/**
 * Check if user is logged into Docker Hub
 */
export async function checkDockerLogin(): Promise<DockerLoginInfo> {
  const dockerClient = await getDockerClient();
  return await dockerClient.checkDockerLogin();
}

/**
 * Get or create VibeKit configuration
 */
export async function getVibeKitConfig(): Promise<VibeKitConfig> {
  const configManager = await getConfigManager();
  return await configManager.getConfig();
}

/**
 * Save VibeKit configuration
 */
export async function saveVibeKitConfig(config: VibeKitConfig): Promise<void> {
  const configManager = await getConfigManager();
  await configManager.saveConfig(config);
}

/**
 * Upload images to user's Docker Hub account
 */
export async function uploadImagesToUserAccount(
  dockerHubUser: string,
  selectedAgents?: AgentType[]
): Promise<{
  success: boolean;
  results: Array<{
    agentType: AgentType;
    success: boolean;
    error?: string;
    imageUrl?: string;
  }>;
}> {
  const registryManager = await getRegistryManager();
  return await registryManager.uploadImages(dockerHubUser, selectedAgents, 'dockerhub');
}

/**
 * Docker registry setup utilities
 */
export async function setupUserDockerRegistry(
  selectedAgents?: AgentType[]
): Promise<{
  success: boolean;
  config?: VibeKitConfig;
  error?: string;
}> {
  const registryManager = await getRegistryManager();
  return await registryManager.setupRegistry(selectedAgents, 'dockerhub');
}


================================================
FILE: packages/dagger/src/dagger/vibekit-dagger.ts
================================================
/**
 * VibeKit Dagger Local Sandbox Provider
 *
 * Implements the sandbox provider interface using Dagger for local containerized
 * development environments with ARM64 agent images.
 */

import { connect } from "@dagger.io/dagger";
import type { Client, Directory } from "@dagger.io/dagger";
import { exec } from "child_process";
import { promisify } from "util";
import { readFile } from "fs/promises";
import { existsSync } from "fs";
import { join } from "path";
import { EventEmitter } from "events";
import { homedir } from "os";

const execAsync = promisify(exec);

// Logger interface for structured logging
interface Logger {
  debug(message: string, meta?: any): void;
  info(message: string, meta?: any): void;
  warn(message: string, meta?: any): void;
  error(message: string, error?: Error | any, meta?: any): void;
}

// Default console logger implementation
class ConsoleLogger implements Logger {
  private context: string;
  
  constructor(context: string = "VibeKitDagger") {
    this.context = context;
  }

  private log(level: string, message: string, meta?: any): void {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level}] [${this.context}] ${message}`;
    
    if (meta) {
      console.log(logMessage, meta);
    } else {
      console.log(logMessage);
    }
  }

  debug(message: string, meta?: any): void {
    if (process.env.VIBEKIT_LOG_LEVEL === "debug") {
      this.log("DEBUG", message, meta);
    }
  }

  info(message: string, meta?: any): void {
    this.log("INFO", message, meta);
  }

  warn(message: string, meta?: any): void {
    this.log("WARN", message, meta);
  }

  error(message: string, error?: Error | any, meta?: any): void {
    const errorMeta = error instanceof Error ? {
      ...meta,
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name
      }
    } : meta;
    
    this.log("ERROR", message, errorMeta);
  }
}

// Custom error types for specific failure scenarios
export class VibeKitError extends Error {
  constructor(message: string, public code: string, public cause?: Error) {
    super(message);
    this.name = "VibeKitError";
  }
}

export class ContainerExecutionError extends VibeKitError {
  constructor(message: string, public exitCode: number, cause?: Error) {
    super(message, "CONTAINER_EXECUTION_ERROR", cause);
    this.name = "ContainerExecutionError";
  }
}

// Environment interface for provider methods
interface Environment {
  id: string;
  name: string;
  status: "running" | "stopped" | "pending" | "error";
  agentType?: string;
  createdAt?: Date;
  lastUsed?: Date;
  branch?: string;
  environment?: {
    VIBEKIT_AGENT_TYPE?: string;
    AGENT_TYPE?: string;
    [key: string]: string | undefined;
  };
}

// Interface definitions matching E2B/Northflank patterns
export interface SandboxExecutionResult {
  exitCode: number;
  stdout: string;
  stderr: string;
}

export interface SandboxCommandOptions {
  timeoutMs?: number;
  background?: boolean;
  onStdout?: (data: string) => void;
  onStderr?: (data: string) => void;
}

export interface SandboxCommands {
  run(
    command: string,
    options?: SandboxCommandOptions
  ): Promise<SandboxExecutionResult>;
}

export interface SandboxInstance {
  sandboxId: string;
  commands: SandboxCommands;
  kill(): Promise<void>;
  pause(): Promise<void>;
  getHost(port: number): Promise<string>;
  // EventEmitter methods for VibeKit streaming compatibility
  on(event: string, listener: (...args: any[]) => void): this;
  emit(event: string, ...args: any[]): boolean;
}

export interface SandboxProvider {
  create(
    envs?: Record<string, string>,
    agentType?: "codex" | "claude" | "opencode" | "gemini" | "grok",
    workingDirectory?: string
  ): Promise<SandboxInstance>;
  resume(sandboxId: string): Promise<SandboxInstance>;
}

export type AgentType = "codex" | "claude" | "opencode" | "gemini" | "grok";

export interface LocalConfig {
  preferRegistryImages?: boolean;
  dockerHubUser?: string;  // Deprecated - use registryUser
  registryUser?: string;    // Universal registry username
  registryName?: string;    // Registry type: 'dockerhub', 'ghcr', 'ecr', etc.
  pushImages?: boolean;
  privateRegistry?: string;
  autoInstall?: boolean;
  logger?: Logger;
  retryAttempts?: number;
  retryDelayMs?: number;
  connectionTimeout?: number;
  configPath?: string;
}

// Configuration with environment variable support
export class Configuration {
  private static instance: Configuration;
  private config: LocalConfig;
  private logger: Logger;

  private constructor(config: LocalConfig = {}) {
    // Support both registryUser and dockerHubUser for backward compatibility
    const registryUser = process.env.VIBEKIT_REGISTRY_USER || config.registryUser || 
                        process.env.VIBEKIT_DOCKER_USER || config.dockerHubUser;
    
    this.config = {
      preferRegistryImages: this.getEnvBoolean("VIBEKIT_PREFER_REGISTRY", config.preferRegistryImages ?? true),
      dockerHubUser: registryUser,  // Keep for backward compatibility
      registryUser: registryUser,
      registryName: process.env.VIBEKIT_REGISTRY_NAME || config.registryName || "dockerhub",
      pushImages: this.getEnvBoolean("VIBEKIT_PUSH_IMAGES", config.pushImages ?? true),
      privateRegistry: process.env.VIBEKIT_REGISTRY || config.privateRegistry,
      autoInstall: this.getEnvBoolean("VIBEKIT_AUTO_INSTALL", config.autoInstall ?? false),
      retryAttempts: this.getEnvNumber("VIBEKIT_RETRY_ATTEMPTS", config.retryAttempts ?? 3),
      retryDelayMs: this.getEnvNumber("VIBEKIT_RETRY_DELAY", config.retryDelayMs ?? 1000),
      connectionTimeout: this.getEnvNumber("VIBEKIT_CONNECTION_TIMEOUT", config.connectionTimeout ?? 30000),
      configPath: process.env.VIBEKIT_CONFIG_PATH || config.configPath || join(homedir(), ".vibekit"),
      logger: config.logger || new ConsoleLogger()
    };
    this.logger = this.config.logger!;
  }

  static getInstance(config?: LocalConfig): Configuration {
    if (!Configuration.instance) {
      Configuration.instance = new Configuration(config);
    }
    return Configuration.instance;
  }

  private getEnvBoolean(key: string, defaultValue: boolean): boolean {
    const value = process.env[key];
    if (value === undefined) return defaultValue;
    return value.toLowerCase() === "true";
  }

  private getEnvNumber(key: string, defaultValue: number): number {
    const value = process.env[key];
    if (value === undefined) return defaultValue;
    const num = parseInt(value, 10);
    return isNaN(num) ? defaultValue : num;
  }

  get(): LocalConfig {
    return this.config;
  }

  getLogger(): Logger {
    return this.logger;
  }
}

// Validates and sanitizes command input to prevent injection
function sanitizeCommand(command: string): string {
  // For Dagger, we're already running in an isolated container
  // and using sh -c, so we can be less restrictive
  // Still prevent some obvious injection patterns
  
  // Check for obvious command injection attempts
  const veryDangerous = [
    "rm -rf /",
    "rm -rf /*",
    ":(){ :|:& };:", // Fork bomb
    "dd if=/dev/zero", // Disk fill
  ];
  
  for (const pattern of veryDangerous) {
    if (command.includes(pattern)) {
      throw new Error(`Command contains dangerous pattern: ${pattern}`);
    }
  }
  
  // Allow common shell operators since we're in a sandboxed environment
  // The container isolation provides the security boundary
  return command;
}

// Registry factory - creates appropriate registry based on config
async function createRegistryManager(config: LocalConfig, logger: any): Promise<any> {
  const modulePath = '@vibe-kit/sdk/registry';
  const registryModule = await import(modulePath).catch(() => null);
  
  if (!registryModule) {
    logger.warn("Registry module not available");
    return null;
  }
  
  const { RegistryManager, DockerHubRegistry, GitHubContainerRegistry, AWSECRRegistry } = registryModule;
  const registryName = config.registryName || 'dockerhub';
  
  const registryManager = new RegistryManager({
    defaultRegistry: registryName,
    logger,
  });
  
  // Register the appropriate registry based on configuration
  switch (registryName) {
    case 'ghcr':
      const ghcrRegistry = new GitHubContainerRegistry({ 
        logger,
        githubToken: process.env.GITHUB_TOKEN,
      });
      registryManager.registerRegistry('ghcr', ghcrRegistry);
      break;
      
    case 'ecr':
      const ecrRegistry = new AWSECRRegistry({ 
        logger,
        awsRegion: process.env.AWS_REGION,
        awsAccountId: process.env.AWS_ACCOUNT_ID,
      });
      registryManager.registerRegistry('ecr', ecrRegistry);
      break;
      
    case 'dockerhub':
    default:
      const dockerHubRegistry = new DockerHubRegistry({ logger });
      registryManager.registerRegistry('dockerhub', dockerHubRegistry);
      break;
  }
  
  return registryManager;
}

// Image resolution using shared infrastructure
class ImageResolver {
  private sharedResolver: any;
  private config: LocalConfig;

  constructor(config: LocalConfig, logger: Logger) {
    this.config = config;
    // Support both registryUser and dockerHubUser for backward compatibility
    const registryUser = config.registryUser || config.dockerHubUser;
    
    // Import and use the shared ImageResolver
    const sharedConfig = {
      preferRegistryImages: config.preferRegistryImages,
      pushImages: config.pushImages,
      privateRegistry: config.privateRegistry,
      dockerHubUser: registryUser,  // For backward compatibility
      registryUser: registryUser,
      registryName: config.registryName,
      retryAttempts: config.retryAttempts,
      retryDelayMs: config.retryDelayMs,
      logger,
    };

    // Use dynamic import to avoid circular dependencies
    this.initializeSharedResolver(sharedConfig);
  }

  private async initializeSharedResolver(config: any) {
    try {
      const modulePath = '@vibe-kit/sdk/registry';
      const registryModule = await import(modulePath).catch(() => null);
      if (!registryModule) {
        config.logger.warn("Registry module not available, using fallback image resolution");
        return;
      }
      
      const { ImageResolver: SharedImageResolver } = registryModule;
      
      // Use the factory to create registry manager with appropriate registry
      const registryManager = await createRegistryManager(this.config, config.logger);
      if (!registryManager) {
        config.logger.warn("Failed to create registry manager, using fallback");
        return;
      }

      this.sharedResolver = new SharedImageResolver(config, registryManager);
    } catch (error) {
      config.logger.warn("Failed to initialize shared resolver:", error);
    }
  }

  async resolveImage(agentType?: AgentType): Promise<string> {
    if (!this.sharedResolver) {
      // Fallback if shared resolver not initialized yet
      const registryUser = this.config.registryUser || this.config.dockerHubUser;
      if (agentType && registryUser) {
        return `${registryUser}/vibekit-${agentType}:latest`;
      }
      return agentType ? `vibekit-${agentType}:latest` : "ubuntu:24.04";
    }
    
    return await this.sharedResolver.resolveImage(agentType);
  }
}

// Local Dagger sandbox instance implementation
class LocalSandboxInstance extends EventEmitter implements SandboxInstance {
  private isRunning = true;
  private workspaceDirectory: Directory | null = null;
  private logger: Logger;
  private imageResolver: ImageResolver;
  private config: LocalConfig;

  constructor(
    public sandboxId: string,
    private envs?: Record<string, string>,
    private workDir?: string,
    private agentType?: AgentType,
    config?: LocalConfig
  ) {
    super();
    this.config = Configuration.getInstance(config).get();
    this.logger = Configuration.getInstance().getLogger();
    this.imageResolver = new ImageResolver(this.config, this.logger);
  }

  get commands(): SandboxCommands {
    return {
      run: async (
        command: string,
        options?: SandboxCommandOptions
      ): Promise<SandboxExecutionResult> => {
        if (!this.isRunning) {
          throw new ContainerExecutionError("Sandbox instance is not running", -1);
        }

        // Validate and sanitize command
        let sanitizedCommand: string;
        try {
          sanitizedCommand = sanitizeCommand(command);
        } catch (error) {
          throw new ContainerExecutionError(
            `Invalid command: ${error instanceof Error ? error.message : String(error)}`,
            -1
          );
        }

        // Emit start event
        this.emit("update", JSON.stringify({
          type: "start",
          command: sanitizedCommand,
          timestamp: Date.now(),
        }));

        try {
          return await this.executeCommand(sanitizedCommand, options);
        } catch (error) {
          // Emit error event
          const errorMessage = error instanceof Error ? error.message : String(error);
          this.emit("error", errorMessage);
          
          if (error instanceof ContainerExecutionError) {
            throw error;
          }
          
          throw new ContainerExecutionError(
            `Command execution failed: ${errorMessage}`,
            -1,
            error instanceof Error ? error : undefined
          );
        } finally {
          // Emit end event
          this.emit("update", JSON.stringify({
            type: "end",
            command: sanitizedCommand,
            timestamp: Date.now(),
          }));
        }
      },
    };
  }

  private async executeCommand(
    command: string,
    options?: SandboxCommandOptions
  ): Promise<SandboxExecutionResult> {
    // Use direct connect instead of connection pool to avoid GraphQL sync issues
    let result: SandboxExecutionResult | null = null;
    
    await connect(async (client) => {
      // Resolve the image
      const image = await this.imageResolver.resolveImage(this.agentType);
      
      // Create container
      let container = client.container()
        .from(image)
        .withWorkdir(this.workDir || "/vibe0");

      // Add environment variables
      if (this.envs) {
        for (const [key, value] of Object.entries(this.envs)) {
          container = container.withEnvVariable(key, value);
        }
      }

      // Restore workspace if exists
      if (this.workspaceDirectory) {
        container = container.withDirectory(
          this.workDir || "/vibe0",
          this.workspaceDirectory
        );
      }

      // Execute command
      if (options?.background) {
        // Background execution
        container = container.withExec(["sh", "-c", command], {
          experimentalPrivilegedNesting: true,
        });

        // Save workspace state - await the directory call
        this.workspaceDirectory = await container.directory(this.workDir || "/vibe0");

        result = {
          exitCode: 0,
          stdout: `Background process started: ${command}`,
          stderr: "",
        };
      } else {
        // Foreground execution with timeout
        const timeout = options?.timeoutMs || 120000; // 2 minutes default
        const execContainer = container.withExec(["sh", "-c", command]);

        try {
          const [stdout, stderr, exitCode] = await Promise.race([
            Promise.all([
              execContainer.stdout(),
              execContainer.stderr(),
              execContainer.exitCode()
            ]),
            new Promise<never>((_, reject) => 
              setTimeout(() => reject(new Error("Command execution timeout")), timeout)
            )
          ]);

          // Save workspace state - await the directory call
          this.workspaceDirectory = await execContainer.directory(this.workDir || "/vibe0");

          // Handle output callbacks
          if (stdout && options?.onStdout) {
            this.emitOutput("stdout", stdout, options.onStdout);
          }
          if (stderr && options?.onStderr) {
            this.emitOutput("stderr", stderr, options.onStderr);
          }

          result = { exitCode, stdout, stderr };
        } catch (error) {
          if (error instanceof Error && error.message === "Command execution timeout") {
            throw new ContainerExecutionError("Command execution timeout", -1, error);
          }
          throw error;
        }
      }
    });

    if (!result) {
      throw new ContainerExecutionError("Command execution failed - no result returned", -1);
    }
    
    return result;
  }

  private emitOutput(
    type: "stdout" | "stderr",
    output: string,
    callback?: (data: string) => void
  ): void {
    const lines = output.split("\n").filter(line => line.trim());
    for (const line of lines) {
      this.emit("update", `${type.toUpperCase()}: ${line}`);
      if (callback) callback(line);
    }
  }

  async kill(): Promise<void> {
    this.isRunning = false;
    this.workspaceDirectory = null;
    this.logger.debug(`Killed sandbox instance: ${this.sandboxId}`);
  }

  async pause(): Promise<void> {
    // Not applicable for Dagger containers
    this.logger.debug(`Pause requested for sandbox: ${this.sandboxId} (no-op)`);
  }

  async getHost(_port: number): Promise<string> {
    return "localhost";
  }
}

export class LocalSandboxProvider implements SandboxProvider {
  private logger: Logger;
  private config: LocalConfig;

  constructor(config: LocalConfig = {}) {
    this.config = Configuration.getInstance(config).get();
    this.logger = Configuration.getInstance().getLogger();
  }

  async create(
    envs?: Record<string, string>,
    agentType?: AgentType,
    workingDirectory?: string
  ): Promise<SandboxInstance> {
    // Generate unique ID with timestamp + random suffix to avoid collisions
    const timestamp = Date.now().toString(36);
    const randomSuffix = Math.random().toString(36).substring(2, 8);
    const sandboxId = `dagger-${agentType || "default"}-${timestamp}-${randomSuffix}`;
    const workDir = workingDirectory || "/vibe0";

    this.logger.info(`Creating sandbox instance`, { sandboxId, agentType, workDir });

    const instance = new LocalSandboxInstance(
      sandboxId,
      envs,
      workDir,
      agentType,
      this.config
    );

    return instance;
  }

  async resume(sandboxId: string): Promise<SandboxInstance> {
    this.logger.info(`Resuming sandbox instance: ${sandboxId}`);
    return await this.create();
  }

  async listEnvironments(): Promise<Environment[]> {
    return [];
  }
}

export function createLocalProvider(
  config: LocalConfig = {}
): LocalSandboxProvider {
  return new LocalSandboxProvider(config);
}

// Pre-cache agent images for faster startup
export async function prebuildAgentImages(
  selectedAgents?: AgentType[]
): Promise<{
  success: boolean;
  results: Array<{
    agentType: AgentType;
    success: boolean;
    error?: string;
    source: "registry" | "dockerfile" | "cached";
  }>;
}> {
  const config = Configuration.getInstance().get();
  const logger = Configuration.getInstance().getLogger();
  
  // Try to use shared ImageResolver for pre-building
  try {
    const modulePath = '@vibe-kit/sdk/registry';
    const registryModule = await import(modulePath).catch(() => null);
    if (registryModule) {
      const { ImageResolver: SharedImageResolver } = registryModule;
      
      // Use the factory to create registry manager with appropriate registry
      const registryManager = await createRegistryManager(config, logger);
      if (registryManager) {
        const registryUser = config.registryUser || config.dockerHubUser;
        
        const imageResolver = new SharedImageResolver({
          preferRegistryImages: config.preferRegistryImages,
          pushImages: config.pushImages,
          privateRegistry: config.privateRegistry,
          dockerHubUser: registryUser,  // For backward compatibility
          registryUser: registryUser,
          registryName: config.registryName,
          retryAttempts: config.retryAttempts,
          retryDelayMs: config.retryDelayMs,
          logger,
        }, registryManager);

        return await imageResolver.prebuildImages(selectedAgents);
      }
    }
  } catch (error) {
    logger.warn("Failed to use shared image resolver, falling back to basic prebuilding:", error);
  }

  // Fallback to basic image resolution
  const allAgentTypes: AgentType[] = ["claude", "codex", "opencode", "gemini", "grok"];
  const agentTypes = selectedAgents?.length ? selectedAgents : allAgentTypes;
  const results: Array<{
    agentType: AgentType;
    success: boolean;
    error?: string;
    source: "registry" | "dockerfile" | "cached";
  }> = [];

  logger.info("Pre-caching agent images for faster startup (fallback mode)");

  for (const agentType of agentTypes) {
    try {
      const imageResolver = new ImageResolver(config, logger);
      await imageResolver.resolveImage(agentType);
      results.push({ agentType, success: true, source: "cached" });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to cache image for ${agentType}`, error);
      results.push({ agentType, success: false, error: errorMessage, source: "dockerfile" });
    }
  }

  const successCount = results.filter(r => r.success).length;
  logger.info(`Pre-cache complete: ${successCount}/${agentTypes.length} images ready`);

  return {
    success: successCount > 0,
    results,
  };
}

// Re-export types for backward compatibility
export type DockerLoginInfo = {
  isLoggedIn: boolean;
  username?: string | null;
  registry?: string;
};

export type VibeKitConfig = {
  dockerHubUser?: string;
  lastImageBuild?: string;
  registryImages?: Partial<Record<AgentType, string>>;
  privateRegistry?: string;
  preferRegistryImages?: boolean;
  pushImages?: boolean;
  [key: string]: any;
};

// Re-export functions for backward compatibility
export { checkDockerLogin } from "./registry-integration";
export { getVibeKitConfig, saveVibeKitConfig } from "./registry-integration";  
export { uploadImagesToUserAccount, setupUserDockerRegistry } from "./registry-integration";


================================================
FILE: packages/dagger/src/setup/installer.ts
================================================
/**
 * Local Provider Setup and Installation
 * 
 * Handles setup and pre-building of agent images for the local provider.
 * This includes validating dependencies, installing tools, and caching
 * Docker images for faster startup times.
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { prebuildAgentImages, type AgentType } from '../dagger/vibekit-dagger';

const execAsync = promisify(exec);

export interface SetupOptions {
  skipPreBuild?: boolean;
  selectedAgents?: AgentType[];
  verbose?: boolean;
}

export interface SetupResult {
  success: boolean;
  message: string;
  preBuildResults?: Array<{ agentType: AgentType; success: boolean; error?: string }>;
  warnings?: string[];
}

/**
 * Validate system dependencies for local provider
 */
export async function validateDependencies(): Promise<{ valid: boolean; issues: string[] }> {
  const issues: string[] = [];

  try {
    // Check Docker
    await execAsync('docker --version');
    try {
      await execAsync('docker info');
    } catch (error) {
      issues.push('Docker is installed but not running. Please start Docker.');
    }
  } catch (error) {
    issues.push('Docker is not installed. Please install Docker from https://docs.docker.com/get-docker/');
  }

  try {
    // Check Dagger CLI
    await execAsync('dagger version');
  } catch (error) {
    issues.push('Dagger CLI is not installed. Please install from https://docs.dagger.io/install/');
  }

  try {
    // Check Node.js version (for MCP server functionality)
    const { stdout } = await execAsync('node --version');
    const version = stdout.trim();
    const majorVersion = parseInt(version.substring(1).split('.')[0]);
    if (majorVersion < 18) {
      issues.push(`Node.js ${version} detected. Node.js 18+ is recommended for optimal performance.`);
    }
  } catch (error) {
    issues.push('Node.js is not available. This may affect MCP server functionality.');
  }

  return {
    valid: issues.length === 0,
    issues
  };
}

/**
 * Setup the local provider with optional pre-building
 */
export async function setupLocalProvider(options: SetupOptions = {}): Promise<SetupResult> {
  const { skipPreBuild = false, selectedAgents, verbose = false } = options;
  const warnings: string[] = [];

  try {
    if (verbose) {
      console.log('ðŸ” Validating system dependencies...');
    }

    // Step 1: Validate dependencies
    const validation = await validateDependencies();
    if (!validation.valid) {
      return {
        success: false,
        message: `Setup failed due to missing dependencies:\n${validation.issues.map(issue => `  âŒ ${issue}`).join('\n')}`,
        warnings
      };
    }

    if (verbose) {
      console.log('âœ… System dependencies validated');
    }

    // Step 2: Test Dagger connectivity
    if (verbose) {
      console.log('ðŸ”— Testing Dagger engine connectivity...');
    }

    try {
      await execAsync('dagger query --help', { timeout: 10000 });
      if (verbose) {
        console.log('âœ… Dagger engine connectivity verified');
      }
    } catch (error) {
      warnings.push('Dagger engine test skipped (may start on first use)');
      if (verbose) {
        console.log('âš ï¸  Dagger engine will start automatically on first use');
      }
    }

    let preBuildResults;

    // Step 3: Pre-build agent images (optional)
    if (!skipPreBuild) {
      if (verbose) {
        console.log('ðŸ—ï¸ Pre-building agent images for faster startup...');
      }

      try {
        const buildResult = await prebuildAgentImages(selectedAgents);
        preBuildResults = buildResult.results;

        if (buildResult.success) {
          const successCount = buildResult.results.filter(r => r.success).length;
          if (verbose) {
            console.log(`âœ… Pre-build completed: ${successCount}/${buildResult.results.length} images ready`);
          }
        } else {
          warnings.push('Some agent images failed to pre-build but can be built on first use');
        }
      } catch (error) {
        warnings.push(`Pre-building failed: ${error instanceof Error ? error.message : String(error)}`);
        if (verbose) {
          console.log('âš ï¸  Agent images will be built on first use instead');
        }
      }
    } else if (verbose) {
      console.log('â­ï¸  Skipping pre-build as requested');
    }

    // Step 4: Setup completion
    const successMessage = [
      'Local provider setup completed successfully!',
      '',
      'ðŸ“‹ What\'s available:',
      '  â€¢ Create sandboxes with agent-specific environments',
      '  â€¢ Automatic Docker image caching for fast startup',
      '  â€¢ Local development with containerized isolation',
      '  â€¢ Git operations and PR creation support',
      '',
      'ðŸš€ Quick start:',
      '  const provider = createLocalProvider();',
      '  const sandbox = await provider.create({}, "claude");',
      '',
    ];

    if (preBuildResults) {
      const successfulBuilds = preBuildResults.filter(r => r.success).map(r => r.agentType);
      if (successfulBuilds.length > 0) {
        successMessage.push(`ðŸŽ¯ Pre-built agents: ${successfulBuilds.join(', ')}`);
      }
    }

    if (warnings.length > 0) {
      successMessage.push('');
      successMessage.push('âš ï¸  Warnings:');
      warnings.forEach(warning => successMessage.push(`  â€¢ ${warning}`));
    }

    return {
      success: true,
      message: successMessage.join('\n'),
      preBuildResults,
      warnings
    };

  } catch (error) {
    return {
      success: false,
      message: `Setup failed: ${error instanceof Error ? error.message : String(error)}`,
      warnings
    };
  }
}

/**
 * Pre-build specific agent images
 */
export async function prebuildSpecificAgents(agentTypes: AgentType[]): Promise<SetupResult> {
  try {
    console.log(`ðŸ—ï¸ Pre-building images for: ${agentTypes.join(', ')}`);
    
    const buildResult = await prebuildAgentImages();
    const requestedResults = buildResult.results.filter(r => agentTypes.includes(r.agentType));
    
    const successCount = requestedResults.filter(r => r.success).length;
    const failedAgents = requestedResults.filter(r => !r.success).map(r => `${r.agentType}: ${r.error}`);
    
    let message = `Pre-build completed: ${successCount}/${agentTypes.length} requested images ready`;
    
    if (failedAgents.length > 0) {
      message += `\n\nFailed builds:\n${failedAgents.map(f => `  âŒ ${f}`).join('\n')}`;
    }

    return {
      success: successCount > 0,
      message,
      preBuildResults: requestedResults
    };
  } catch (error) {
    return {
      success: false,
      message: `Pre-build failed: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}

/**
 * Check if local provider is properly set up
 */
export async function checkSetupStatus(): Promise<{ isSetup: boolean; issues: string[]; recommendations: string[] }> {
  const issues: string[] = [];
  const recommendations: string[] = [];

  // Check dependencies
  const validation = await validateDependencies();
  issues.push(...validation.issues);

  // Check if any agent images are pre-built
  try {
    const agentTypes: AgentType[] = ["claude", "codex", "opencode", "gemini"];
    let hasPreBuiltImages = false;

    for (const agentType of agentTypes) {
      try {
        const { stdout } = await execAsync(`docker images -q vibekit-${agentType}:latest`);
        if (stdout.trim()) {
          hasPreBuiltImages = true;
          break;
        }
      } catch (error) {
        // Ignore individual image check errors
      }
    }

    if (!hasPreBuiltImages) {
      recommendations.push('Consider pre-building agent images for faster startup: prebuildAgentImages()');
    }
  } catch (error) {
    recommendations.push('Unable to check pre-built images status');
  }

  return {
    isSetup: issues.length === 0,
    issues,
    recommendations
  };
}

/**
 * Clean up pre-built images (for maintenance)
 */
export async function cleanupPreBuiltImages(): Promise<{ success: boolean; removed: string[]; errors: string[] }> {
  const removed: string[] = [];
  const errors: string[] = [];
  const agentTypes: AgentType[] = ["claude", "codex", "opencode", "gemini"];

  for (const agentType of agentTypes) {
    const imageTag = `vibekit-${agentType}:latest`;
    try {
      const { stdout } = await execAsync(`docker images -q ${imageTag}`);
      if (stdout.trim()) {
        await execAsync(`docker rmi ${imageTag}`);
        removed.push(imageTag);
      }
    } catch (error) {
      errors.push(`Failed to remove ${imageTag}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  return {
    success: errors.length === 0,
    removed,
    errors
  };
} 


================================================
FILE: packages/dagger/src/storage/environment-store.ts
================================================
/**
 * Environment Storage System
 * 
 * Provides persistent storage for sandbox environment metadata
 * to track environments across CLI sessions.
 */

import { readFile, writeFile, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import { join, dirname } from 'path';
import { homedir } from 'os';
import type { AgentType } from '../dagger/vibekit-dagger';

export interface EnvironmentRecord {
  id: string;
  name: string;
  status: 'running' | 'stopped' | 'paused' | 'error';
  agentType?: AgentType;
  branch?: string;
  created: Date;
  lastUsed: Date;
  sandboxId: string;
  workingDirectory: string;
  envVars: Record<string, string>;
  dockerImage?: string;
  pid?: number; // For tracking background processes
  githubToken?: string;
  model?: string;
  apiKey?: string;
}

export class EnvironmentStore {
  private storePath: string;
  private lockPath: string;

  constructor(customPath?: string) {
    const basePath = customPath || join(homedir(), '.vibekit');
    this.storePath = join(basePath, 'environments.json');
    this.lockPath = join(basePath, 'environments.lock');
  }

  /**
   * Ensure storage directory exists
   */
  private async ensureStorageDir(): Promise<void> {
    const dir = dirname(this.storePath);
    if (!existsSync(dir)) {
      await mkdir(dir, { recursive: true });
    }
  }

  /**
   * Simple file-based locking for concurrent access
   */
  private async acquireLock(): Promise<void> {
    await this.ensureStorageDir();
    let attempts = 0;
    const maxAttempts = 50; // 5 seconds with 100ms intervals
    
    while (attempts < maxAttempts) {
      try {
        if (!existsSync(this.lockPath)) {
          await writeFile(this.lockPath, process.pid.toString());
          return;
        }
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
      } catch (error) {
        // File might have been deleted between check and write, try again
        attempts++;
      }
    }
    
    throw new Error('Could not acquire lock for environment storage');
  }

  /**
   * Release the file lock
   */
  private async releaseLock(): Promise<void> {
    try {
      if (existsSync(this.lockPath)) {
        const lockContent = await readFile(this.lockPath, 'utf-8');
        if (lockContent.trim() === process.pid.toString()) {
          await writeFile(this.lockPath, ''); // Clear lock file
        }
      }
    } catch (error) {
      // Lock file might have been removed by another process
    }
  }

  /**
   * Load all environments from storage
   */
  async load(): Promise<EnvironmentRecord[]> {
    await this.acquireLock();
    
    try {
      await this.ensureStorageDir();
      
      if (!existsSync(this.storePath)) {
        return [];
      }

      const content = await readFile(this.storePath, 'utf-8');
      const data = JSON.parse(content);
      
      // Convert date strings back to Date objects
      return data.map((env: any) => ({
        ...env,
        created: new Date(env.created),
        lastUsed: new Date(env.lastUsed)
      }));
    } catch (error) {
      if (error instanceof SyntaxError) {
        // Corrupted JSON, start fresh
        return [];
      }
      throw error;
    } finally {
      await this.releaseLock();
    }
  }

  /**
   * Save all environments to storage
   */
  private async saveAll(environments: EnvironmentRecord[]): Promise<void> {
    await this.ensureStorageDir();
    await writeFile(this.storePath, JSON.stringify(environments, null, 2));
  }

  /**
   * Save a new environment
   */
  async save(env: EnvironmentRecord): Promise<void> {
    await this.acquireLock();
    
    try {
      const environments = await this.load();
      
      // Check for duplicate names
      const existing = environments.find(e => e.name === env.name);
      if (existing) {
        throw new Error(`Environment with name '${env.name}' already exists`);
      }
      
      environments.push(env);
      await this.saveAll(environments);
    } finally {
      await this.releaseLock();
    }
  }

  /**
   * Update an existing environment
   */
  async update(id: string, updates: Partial<EnvironmentRecord>): Promise<void> {
    await this.acquireLock();
    
    try {
      const environments = await this.load();
      const index = environments.findIndex(env => env.id === id);
      
      if (index === -1) {
        throw new Error(`Environment with id '${id}' not found`);
      }
      
      environments[index] = { ...environments[index], ...updates };
      await this.saveAll(environments);
    } finally {
      await this.releaseLock();
    }
  }

  /**
   * Delete an environment by ID
   */
  async delete(id: string): Promise<void> {
    await this.acquireLock();
    
    try {
      const environments = await this.load();
      const filteredEnvironments = environments.filter(env => env.id !== id);
      
      if (filteredEnvironments.length === environments.length) {
        throw new Error(`Environment with id '${id}' not found`);
      }
      
      await this.saveAll(filteredEnvironments);
    } finally {
      await this.releaseLock();
    }
  }

  /**
   * Find environment by ID
   */
  async findById(id: string): Promise<EnvironmentRecord | null> {
    const environments = await this.load();
    return environments.find(env => env.id === id) || null;
  }

  /**
   * Find environment by name
   */
  async findByName(name: string): Promise<EnvironmentRecord | null> {
    const environments = await this.load();
    return environments.find(env => env.name === name) || null;
  }

  /**
   * Get environments filtered by status
   */
  async getByStatus(status: EnvironmentRecord['status']): Promise<EnvironmentRecord[]> {
    const environments = await this.load();
    return environments.filter(env => env.status === status);
  }

  /**
   * Get environments filtered by agent type
   */
  async getByAgentType(agentType: AgentType): Promise<EnvironmentRecord[]> {
    const environments = await this.load();
    return environments.filter(env => env.agentType === agentType);
  }

  /**
   * Clean up old environments (older than specified days)
   */
  async cleanup(olderThanDays: number = 30): Promise<string[]> {
    await this.acquireLock();
    
    try {
      const environments = await this.load();
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);
      
      const toRemove = environments.filter(env => 
        env.lastUsed < cutoffDate && env.status !== 'running'
      );
      
      const remaining = environments.filter(env => 
        env.lastUsed >= cutoffDate || env.status === 'running'
      );
      
      await this.saveAll(remaining);
      
      return toRemove.map(env => env.name);
    } finally {
      await this.releaseLock();
    }
  }
} 


================================================
FILE: packages/dashboard/README.md
================================================
# @vibe-kit/dashboard

A real-time analytics dashboard for monitoring AI-assisted coding sessions with Vibekit CLI. This is a standalone npm package that provides a Next.js-based dashboard.

## Overview

The Vibekit dashboard provides comprehensive insights into your coding sessions, command execution, and agent interactions. Built with Next.js and TypeScript, it offers a modern, responsive interface for tracking productivity and analyzing coding patterns.

## Features

- ðŸ“Š **Real-time Analytics** - Live tracking of coding sessions and agent activity
- ðŸ” **Command History** - Detailed logs of all executed commands and their outcomes
- âš¡ **Performance Metrics** - Response times, success rates, and efficiency analytics
- ðŸŽ¯ **Project Insights** - File modification patterns and project activity
- ðŸ“ˆ **Session Tracking** - Duration, productivity metrics, and workflow analysis
- ðŸŒ **Modern UI** - Clean, responsive interface built with Tailwind CSS

## Installation

```bash
npm install @vibe-kit/dashboard
```

## Getting Started

### Via VibeKit CLI (Recommended)
The dashboard is automatically managed by the Vibekit CLI:

```bash
# Start dashboard from CLI (installs package automatically)
vibekit dashboard

# Check dashboard status
vibekit dashboard status
```

### Direct Usage

```javascript
const DashboardServer = require('@vibe-kit/dashboard');

const server = new DashboardServer({
  port: 3001,
  hostname: 'localhost'
});

await server.start();
```

### CLI Command

```bash
vibe-kit-dashboard --port 3001
```

### Development

For development purposes:

```bash
npm install
npm run dev
```

The dashboard will be available at [http://localhost:3001](http://localhost:3001).

## Architecture

```
dashboard/
â”œâ”€â”€ app/                    # Next.js App Router
â”‚   â”œâ”€â”€ api/               # API routes for analytics data
â”‚   â”‚   â””â”€â”€ analytics/     # Analytics endpoints
â”‚   â”œâ”€â”€ globals.css        # Global styles
â”‚   â”œâ”€â”€ layout.tsx         # Root layout
â”‚   â””â”€â”€ page.tsx          # Main dashboard page
â”œâ”€â”€ components/            # React components
â”‚   â”œâ”€â”€ ui/               # Reusable UI components
â”‚   â””â”€â”€ metric-card.tsx   # Analytics display components
â”œâ”€â”€ lib/                   # Utilities and types
â”‚   â”œâ”€â”€ analytics.ts      # Analytics data processing
â”‚   â”œâ”€â”€ types.ts          # TypeScript type definitions
â”‚   â””â”€â”€ utils.ts          # Utility functions
â”œâ”€â”€ manager.ts            # Dashboard server management
â”œâ”€â”€ server.ts             # Dashboard server implementation
â””â”€â”€ package.json          # Dependencies and scripts
```

## API Endpoints

### Analytics Data
- `GET /api/analytics` - Current session analytics
- `GET /api/analytics/summary` - Session summary and metrics

### Data Format

The dashboard expects analytics data in the following format:

```typescript
interface SessionAnalytics {
  sessionId: string;
  startTime: Date;
  duration: number;
  commandsExecuted: number;
  filesModified: string[];
  agentType: string;
  performance: {
    averageResponseTime: number;
    successRate: number;
  };
}
```

## Configuration

The dashboard server can be configured through the Vibekit CLI configuration:

```json
{
  "dashboard": {
    "port": 3001,
    "autoStart": false,
    "analytics": {
      "enabled": true,
      "retention": 30
    }
  }
}
```

## Development

### Tech Stack
- **Framework**: Next.js 15 with App Router
- **Language**: TypeScript
- **Styling**: Tailwind CSS
- **UI Components**: Custom components with shadcn/ui
- **Charts**: Recharts for data visualization

### Scripts
- `npm run dev` - Start development server
- `npm run build` - Build for production
- `npm run start` - Start production server
- `npm run lint` - Run ESLint
- `npm run type-check` - Run TypeScript checks

### Adding New Metrics

1. Update the analytics types in `lib/types.ts`
2. Modify the API endpoints in `app/api/analytics/`
3. Add new components in `components/`
4. Update the main dashboard page in `app/page.tsx`

## Integration

The dashboard automatically integrates with:
- Vibekit CLI logging system
- Agent command execution tracking
- File system change monitoring
- Session management

All data is collected passively during normal CLI usage and displayed in real-time.


================================================
FILE: packages/dashboard/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: packages/dashboard/eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;



================================================
FILE: packages/dashboard/next-env.d.ts
================================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.



================================================
FILE: packages/dashboard/next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  output: 'standalone',
  eslint: {
    ignoreDuringBuilds: true,
  },
  typescript: {
    ignoreBuildErrors: true,
  },
  // Optimize for smallest bundle size
  experimental: {
    optimizePackageImports: ['lucide-react', 'recharts'],
  },
  // Minimize build output
  compress: true,
  poweredByHeader: false,
  // Configure to run on port 3001 by default
  async rewrites() {
    return []
  },
  // Minimize static generation
  trailingSlash: false,
  // Optimize images
  images: {
    unoptimized: true
  }
};

export default nextConfig;



================================================
FILE: packages/dashboard/package.json
================================================
{
  "name": "@vibe-kit/dashboard",
  "version": "0.0.11",
  "description": "Analytics dashboard for VibeKit CLI middleware",
  "private": false,
  "publishConfig": {
    "access": "public"
  },
  "main": "index.js",
  "bin": {
    "vibe-kit-dashboard": "./bin/dashboard.js"
  },
  "files": [
    ".next/**/*",
    "public/**/*",
    "bin/dashboard.js"
  ],
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit",
    "prepublishOnly": "npm run build"
  },
  "keywords": [
    "vibekit",
    "dashboard",
    "analytics",
    "cli",
    "nextjs"
  ],
  "author": "VibeKit Team",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/superagent-ai/vibekit.git",
    "directory": "packages/dashboard"
  },
  "homepage": "https://github.com/superagent-ai/vibekit#readme",
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@tailwindcss/postcss": "^4",
    "@types/fs-extra": "^11.0.4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "eslint": "^9",
    "eslint-config-next": "15.4.5",
    "lucide-react": "^0.536.0",
    "next": "15.4.5",
    "next-themes": "^0.4.6",
    "react": "19.1.1",
    "react-dom": "19.1.1",
    "recharts": "^3.1.2",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.6",
    "typescript": "^5"
  },
  "bundleDependencies": [
    "@radix-ui/react-avatar",
    "@radix-ui/react-dialog",
    "@radix-ui/react-dropdown-menu",
    "@radix-ui/react-label",
    "@radix-ui/react-separator",
    "@radix-ui/react-slot",
    "@radix-ui/react-switch",
    "@radix-ui/react-tooltip",
    "class-variance-authority",
    "clsx",
    "lucide-react",
    "next",
    "next-themes",
    "react",
    "react-dom",
    "recharts",
    "tailwind-merge"
  ]
}



================================================
FILE: packages/dashboard/postcss.config.mjs
================================================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;



================================================
FILE: packages/dashboard/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: packages/dashboard/.npmignore
================================================
# Override root .gitignore for npm publishing
# Include .next build files in npm package
!.next/

# But still ignore these
node_modules/
.env*
*.log


================================================
FILE: packages/dashboard/app/globals.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: Geist Mono, monospace;
  --font-mono: Geist Mono, monospace;
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --font-serif: Geist Mono, monospace;
  --radius: 0rem;
  --tracking-tighter: calc(var(--tracking-normal) - 0.05em);
  --tracking-tight: calc(var(--tracking-normal) - 0.025em);
  --tracking-wide: calc(var(--tracking-normal) + 0.025em);
  --tracking-wider: calc(var(--tracking-normal) + 0.05em);
  --tracking-widest: calc(var(--tracking-normal) + 0.1em);
  --tracking-normal: var(--tracking-normal);
  --shadow-2xl: var(--shadow-2xl);
  --shadow-xl: var(--shadow-xl);
  --shadow-lg: var(--shadow-lg);
  --shadow-md: var(--shadow-md);
  --shadow: var(--shadow);
  --shadow-sm: var(--shadow-sm);
  --shadow-xs: var(--shadow-xs);
  --shadow-2xs: var(--shadow-2xs);
  --spacing: var(--spacing);
  --letter-spacing: var(--letter-spacing);
  --shadow-offset-y: var(--shadow-offset-y);
  --shadow-offset-x: var(--shadow-offset-x);
  --shadow-spread: var(--shadow-spread);
  --shadow-blur: var(--shadow-blur);
  --shadow-opacity: var(--shadow-opacity);
  --color-shadow-color: var(--shadow-color);
  --color-destructive-foreground: var(--destructive-foreground);
}

:root {
  --radius: 0rem;
  --background: oklch(1.0000 0 0);
  --foreground: oklch(0.1448 0 0);
  --card: oklch(1.0000 0 0);
  --card-foreground: oklch(0.1448 0 0);
  --popover: oklch(1.0000 0 0);
  --popover-foreground: oklch(0.1448 0 0);
  --primary: oklch(0 0 0);
  --primary-foreground: oklch(0.9851 0 0);
  --secondary: oklch(0.9702 0 0);
  --secondary-foreground: oklch(0.2046 0 0);
  --muted: oklch(0.9702 0 0);
  --muted-foreground: oklch(0.5486 0 0);
  --accent: oklch(0.9702 0 0);
  --accent-foreground: oklch(0.2046 0 0);
  --destructive: oklch(0.5830 0.2387 28.4765);
  --border: oklch(0.9219 0 0);
  --input: oklch(0.9219 0 0);
  --ring: oklch(0.7090 0 0);
  --chart-1: oklch(0.5555 0 0);
  --chart-2: oklch(0.5555 0 0);
  --chart-3: oklch(0.5555 0 0);
  --chart-4: oklch(0.5555 0 0);
  --chart-5: oklch(0.5555 0 0);
  --sidebar: oklch(0.9851 0 0);
  --sidebar-foreground: oklch(0.1448 0 0);
  --sidebar-primary: oklch(0.2046 0 0);
  --sidebar-primary-foreground: oklch(0.9851 0 0);
  --sidebar-accent: oklch(0.9702 0 0);
  --sidebar-accent-foreground: oklch(0.2046 0 0);
  --sidebar-border: oklch(0.9219 0 0);
  --sidebar-ring: oklch(0.7090 0 0);
  --destructive-foreground: oklch(0.9702 0 0);
  --font-sans: Geist Mono, monospace;
  --font-serif: Geist Mono, monospace;
  --font-mono: Geist Mono, monospace;
  --shadow-color: hsl(0 0% 0%);
  --shadow-opacity: 0;
  --shadow-blur: 0px;
  --shadow-spread: 0px;
  --shadow-offset-x: 0px;
  --shadow-offset-y: 1px;
  --letter-spacing: 0em;
  --spacing: 0.25rem;
  --shadow-2xs: 0px 1px 0px 0px hsl(0 0% 0% / 0.00);
  --shadow-xs: 0px 1px 0px 0px hsl(0 0% 0% / 0.00);
  --shadow-sm: 0px 1px 0px 0px hsl(0 0% 0% / 0.00), 0px 1px 2px -1px hsl(0 0% 0% / 0.00);
  --shadow: 0px 1px 0px 0px hsl(0 0% 0% / 0.00), 0px 1px 2px -1px hsl(0 0% 0% / 0.00);
  --shadow-md: 0px 1px 0px 0px hsl(0 0% 0% / 0.00), 0px 2px 4px -1px hsl(0 0% 0% / 0.00);
  --shadow-lg: 0px 1px 0px 0px hsl(0 0% 0% / 0.00), 0px 4px 6px -1px hsl(0 0% 0% / 0.00);
  --shadow-xl: 0px 1px 0px 0px hsl(0 0% 0% / 0.00), 0px 8px 10px -1px hsl(0 0% 0% / 0.00);
  --shadow-2xl: 0px 1px 0px 0px hsl(0 0% 0% / 0.00);
  --tracking-normal: 0em;
}

.dark {
  --background: oklch(0.1448 0 0);
  --foreground: oklch(0.9851 0 0);
  --card: oklch(0.2134 0 0);
  --card-foreground: oklch(0.9851 0 0);
  --popover: oklch(0.2686 0 0);
  --popover-foreground: oklch(0.9851 0 0);
  --primary: oklch(0.5555 0 0);
  --primary-foreground: oklch(0.9851 0 0);
  --secondary: oklch(0.2686 0 0);
  --secondary-foreground: oklch(0.9851 0 0);
  --muted: oklch(0.2686 0 0);
  --muted-foreground: oklch(0.7090 0 0);
  --accent: oklch(0.3715 0 0);
  --accent-foreground: oklch(0.9851 0 0);
  --destructive: oklch(0.7022 0.1892 22.2279);
  --border: oklch(0.3407 0 0);
  --input: oklch(0.4386 0 0);
  --ring: oklch(0.5555 0 0);
  --chart-1: oklch(0.5555 0 0);
  --chart-2: oklch(0.5555 0 0);
  --chart-3: oklch(0.5555 0 0);
  --chart-4: oklch(0.5555 0 0);
  --chart-5: oklch(0.5555 0 0);
  --sidebar: oklch(0.2046 0 0);
  --sidebar-foreground: oklch(0.9851 0 0);
  --sidebar-primary: oklch(0.9851 0 0);
  --sidebar-primary-foreground: oklch(0.2046 0 0);
  --sidebar-accent: oklch(0.2686 0 0);
  --sidebar-accent-foreground: oklch(0.9851 0 0);
  --sidebar-border: oklch(1.0000 0 0);
  --sidebar-ring: oklch(0.4386 0 0);
  --destructive-foreground: oklch(0.2686 0 0);
  --radius: 0rem;
  --font-sans: Geist Mono, monospace;
  --font-serif: Geist Mono, monospace;
  --font-mono: Geist Mono, monospace;
  --shadow-color: hsl(0 0% 0%);
  --shadow-opacity: 0;
  --shadow-blur: 0px;
  --shadow-spread: 0px;
  --shadow-offset-x: 0px;
  --shadow-offset-y: 1px;
  --letter-spacing: 0em;
  --spacing: 0.25rem;
  --shadow-2xs: 0px 1px 0px 0px hsl(0 0% 0% / 0.00);
  --shadow-xs: 0px 1px 0px 0px hsl(0 0% 0% / 0.00);
  --shadow-sm: 0px 1px 0px 0px hsl(0 0% 0% / 0.00), 0px 1px 2px -1px hsl(0 0% 0% / 0.00);
  --shadow: 0px 1px 0px 0px hsl(0 0% 0% / 0.00), 0px 1px 2px -1px hsl(0 0% 0% / 0.00);
  --shadow-md: 0px 1px 0px 0px hsl(0 0% 0% / 0.00), 0px 2px 4px -1px hsl(0 0% 0% / 0.00);
  --shadow-lg: 0px 1px 0px 0px hsl(0 0% 0% / 0.00), 0px 4px 6px -1px hsl(0 0% 0% / 0.00);
  --shadow-xl: 0px 1px 0px 0px hsl(0 0% 0% / 0.00), 0px 8px 10px -1px hsl(0 0% 0% / 0.00);
  --shadow-2xl: 0px 1px 0px 0px hsl(0 0% 0% / 0.00);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
    letter-spacing: var(--tracking-normal);
  }
}


================================================
FILE: packages/dashboard/app/layout.tsx
================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { AppSidebar } from "@/components/app-sidebar";
import { SidebarInset, SidebarProvider } from "@/components/ui/sidebar";
import { ThemeProvider } from "@/components/theme-provider";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "VibeKit Dashboard",
  description: "Analytics dashboard for Vibekit coding agent usage",
  icons: {
    icon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ––</text></svg>",
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          <SidebarProvider defaultOpen={false}>
            <AppSidebar />
            <SidebarInset>
              {children}
            </SidebarInset>
          </SidebarProvider>
        </ThemeProvider>
      </body>
    </html>
  );
}



================================================
FILE: packages/dashboard/app/page.tsx
================================================
"use client";

import React, { useEffect, useState } from "react";
import Image from "next/image";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { SidebarTrigger } from "@/components/ui/sidebar";
import {
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  LineChart,
  Line,
  CartesianGrid,
} from "recharts";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import type { AnalyticsSession, AnalyticsSummary } from "@/lib/types";

// Define proper types for Recharts tooltip
interface TooltipPayload {
  dataKey: string;
  value: number;
  color: string;
}

interface CustomTooltipProps {
  active?: boolean;
  payload?: TooltipPayload[];
  label?: string;
}
import { Loader } from "lucide-react";

// Custom tooltip component that respects theme
const CustomTooltip = ({ active, payload, label }: CustomTooltipProps) => {
  const getAgentDisplayName = (agentKey: string) => {
    const displayNames: Record<string, string> = {
      claude: "claude-code",
      gemini: "gemini-cli",
      cursor: "cursor",
      opencode: "opencode",
    };
    return displayNames[agentKey.toLowerCase()] || agentKey;
  };

  if (active && payload && payload.length) {
    return (
      <div className="bg-background border border-border rounded-md p-3 shadow-lg">
        <p className="text-foreground font-medium mb-2">{label}</p>
        {payload.map((entry: TooltipPayload, index: number) => (
          <p
            key={index}
            className="text-xs text-foreground flex items-center gap-2"
          >
            <span
              className="w-3 h-3 rounded-sm"
              style={{ backgroundColor: entry.color }}
            />
            <span className="text-xs font-medium">
              {getAgentDisplayName(entry.dataKey)}:
            </span>{" "}
            <span className="text-xs font-medium">{entry.value}</span>
          </p>
        ))}
      </div>
    );
  }
  return null;
};

// Utility functions moved here to avoid Node.js dependencies in client
function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  } else if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  } else {
    return `${seconds}s`;
  }
}

export default function Dashboard() {
  const [summary, setSummary] = useState<AnalyticsSummary | null>(null);
  const [recentSessions, setRecentSessions] = useState<AnalyticsSession[]>([]);
  const [allSessions, setAllSessions] = useState<AnalyticsSession[]>([]);
  const [currentPage, setCurrentPage] = useState(1);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedFilter, setSelectedFilter] = useState<string>("7d");
  const sessionsPerPage = 10;

  const timeFilters = [
    { label: "Today", value: "1d", days: 1 },
    { label: "7 Days", value: "7d", days: 7 },
    { label: "2 Weeks", value: "14d", days: 14 },
    { label: "1 Month", value: "30d", days: 30 },
    { label: "3 Months", value: "90d", days: 90 },
  ];

  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true);

        const selectedFilterData = timeFilters.find(
          (f) => f.value === selectedFilter
        );
        const days = selectedFilterData?.days || 7;

        // Fetch summary data
        const summaryResponse = await fetch(
          `/api/analytics/summary?days=${days}`
        );
        if (!summaryResponse.ok) throw new Error("Failed to fetch summary");
        const summaryData = await summaryResponse.json();
        setSummary(summaryData);

        // Fetch all sessions
        const sessionsResponse = await fetch(`/api/analytics?days=${days}`);
        if (!sessionsResponse.ok) throw new Error("Failed to fetch sessions");
        const sessionsData = await sessionsResponse.json();
        setAllSessions(sessionsData);
        setRecentSessions(sessionsData);
      } catch (err) {
        setError(err instanceof Error ? err.message : "An error occurred");
      } finally {
        setLoading(false);
      }
    }

    fetchData();

    // Set up auto-refresh every 20 seconds
    const interval = setInterval(fetchData, 20000);

    // Cleanup interval on unmount
    return () => clearInterval(interval);
  }, [selectedFilter]);

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center flex items-center gap-2 justify-center">
          <Loader className="animate-spin size-4 text-primary" />
          <p className="text-sm text-muted-foreground">Loading analytics...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-2xl font-bold text-destructive mb-2">Error</h2>
          <p className="text-muted-foreground">{error}</p>
        </div>
      </div>
    );
  }

  if (!summary) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-2xl font-bold mb-2">No Data Available</h2>
          <p className="text-muted-foreground">
            No analytics data found. Run some Vibekit sessions first!
          </p>
        </div>
      </div>
    );
  }

  // Generate time series data from recent sessions
  const generateTimeSeriesData = () => {
    const today = new Date();
    type DayData = { date: string; [key: string]: string | number };
    const selectedFilterData = timeFilters.find(
      (f) => f.value === selectedFilter
    );
    const filterDays = selectedFilterData?.days || 7;
    const timeSeriesDays: DayData[] = [];

    // Create data structure for selected time period with actual dates
    for (let i = filterDays - 1; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const dateStr = `${date.getMonth() + 1}/${date.getDate()}`;

      timeSeriesDays.push({
        date: dateStr,
      });
    }

    // Group sessions by date
    const sessionsByDate = new Map<string, Record<string, number>>();

    recentSessions.forEach((session) => {
      const sessionDate = new Date(session.startTime);
      const dateStr = `${sessionDate.getMonth() + 1}/${sessionDate.getDate()}`;

      // Check if this date is within our selected time window
      const daysDiff = Math.floor(
        (today.getTime() - sessionDate.getTime()) / (1000 * 60 * 60 * 24)
      );

      if (daysDiff >= 0 && daysDiff < filterDays) {
        if (!sessionsByDate.has(dateStr)) {
          sessionsByDate.set(dateStr, {});
        }

        const agentKey = session.agentName.toLowerCase();
        const dayData = sessionsByDate.get(dateStr)!;
        dayData[agentKey] = (dayData[agentKey] || 0) + 1;
      }
    });

    // Get all unique agents across all days
    const allAgents = new Set<string>();
    sessionsByDate.forEach((dayData) => {
      Object.keys(dayData).forEach((agent) => allAgents.add(agent));
    });

    // Merge the session data with our date structure, ensuring all agents have values for all days
    timeSeriesDays.forEach((dayData) => {
      const sessionsForDay = sessionsByDate.get(dayData.date) || {};

      // Initialize all agents to 0 for this day
      allAgents.forEach((agent) => {
        dayData[agent] = 0;
      });

      // Override with actual session counts
      Object.assign(dayData, sessionsForDay);
    });

    return timeSeriesDays;
  };

  const timeSeriesData = generateTimeSeriesData();

  // Get all unique agents from the chart data (not just summary breakdown)
  const allAgentsInData = new Set<string>();
  timeSeriesData.forEach((dayData) => {
    Object.keys(dayData).forEach((key) => {
      if (key !== "date" && typeof dayData[key] === "number") {
        allAgentsInData.add(key);
      }
    });
  });
  const agentsToRender = Array.from(allAgentsInData);

  return (
    <div className="px-6 space-y-6">
      <div className="-mx-6 px-4 border-b flex h-12 items-center">
        <div className="flex items-center gap-2">
          <SidebarTrigger />
          <h1 className="text-lg font-bold">Usage</h1>
        </div>
      </div>

      {/* Time Filter Buttons */}
      <div className="flex flex-wrap gap-2 mb-4">
        {timeFilters.map((filter) => (
          <button
            key={filter.value}
            onClick={() => setSelectedFilter(filter.value)}
            className={`px-2 py-1 text-sm font-medium rounded-md border transition-colors ${
              selectedFilter === filter.value
                ? "bg-primary text-primary-foreground border-primary"
                : "border-border hover:bg-accent hover:text-accent-foreground"
            }`}
          >
            {filter.label}
          </button>
        ))}
      </div>

      {/* Stats Cards */}
      <div className="grid gap-4 md:grid-cols-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium uppercase">
              Active Sessions
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-green-600">
              {summary.activeSessions}
            </div>
            <p className="text-xs text-muted-foreground">Currently running</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium uppercase">
              Total Sessions
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{summary.totalSessions}</div>
            <p className="text-xs text-muted-foreground">
              Coding agent sessions
            </p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium uppercase">
              Success Rate
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {summary.successRate.toFixed(1)}%
            </div>
            <p className="text-xs text-muted-foreground">
              Sessions completed successfully
            </p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium uppercase">
              Average Duration
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {formatDuration(summary.averageDuration)}
            </div>
            <p className="text-xs text-muted-foreground">Per session</p>
          </CardContent>
        </Card>
      </div>

      {/* Chart */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="text-sm font-medium uppercase">
              Sessions Over Time
            </CardTitle>
            <div className="flex items-center gap-2">
              <div className="w-2 h-2 bg-green-500 rounded-full"></div>
              <span className="text-sm text-muted-foreground">
                {summary.activeSessions} active
              </span>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={timeSeriesData}>
              <CartesianGrid
                strokeDasharray="3 3"
                className="stroke-muted"
                opacity={1}
              />
              <XAxis
                dataKey="date"
                axisLine={false}
                tickLine={false}
                interval={(() => {
                  const selectedFilterData = timeFilters.find(
                    (f) => f.value === selectedFilter
                  );
                  const filterDays = selectedFilterData?.days || 7;
                  // Show fewer ticks for longer time periods
                  if (filterDays <= 7) return 0; // Show all ticks for 7 days or less
                  if (filterDays <= 14) return 1; // Show every other tick for 2 weeks
                  if (filterDays <= 30) return 4; // Show every 5th tick for 1 month
                  return 6; // Show every 7th tick for 3 months
                })()}
                angle={-45}
                textAnchor="end"
                height={60}
              />
              <YAxis axisLine={false} tickLine={false} />
              <Tooltip content={<CustomTooltip />} />
              {agentsToRender.map((agent, index) => {
                const getAgentColor = (
                  agentName: string,
                  fallbackIndex: number
                ) => {
                  const agentColors: Record<string, string> = {
                    claude: "#ff6b35", // Orange color for Claude
                    gemini: "#4285f4", // Google blue for Gemini
                    codex: "#6b7280", // Grey color for Codex (works in light/dark)
                    cursor: "#374151", // Dark grey/black-ish color for Cursor (works in light/dark)
                    opencode: "#333333", // Dark black color for OpenCode
                  };
                  if (agentColors[agentName.toLowerCase()]) {
                    return agentColors[agentName.toLowerCase()];
                  }
                  const fallbackColors = [
                    "#8884d8",
                    "#82ca9d",
                    "#ffc658",
                    "#ff7c7c",
                    "#8dd1e1",
                    "#d084d0",
                  ];
                  return fallbackColors[fallbackIndex % fallbackColors.length];
                };
                const color = getAgentColor(agent, index);
                return (
                  <Line
                    key={agent}
                    type="monotone"
                    dataKey={agent.toLowerCase()}
                    stroke={color}
                    strokeWidth={2}
                    dot={false}
                  />
                );
              })}
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>

      {/* Sessions Table with Pagination */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="text-sm font-medium uppercase">
              All Sessions
            </CardTitle>
            <div className="text-sm text-muted-foreground">
              Total: {allSessions.length} sessions
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="text-sm font-medium uppercase">
                  Agent
                </TableHead>
                <TableHead className="text-sm font-medium uppercase">
                  Status
                </TableHead>
                <TableHead className="text-sm font-medium uppercase">
                  Mode
                </TableHead>
                <TableHead className="text-sm font-medium uppercase">
                  Duration
                </TableHead>
                <TableHead className="text-sm font-medium uppercase">
                  Files Changed
                </TableHead>
                <TableHead className="text-sm font-medium uppercase">
                  Project
                </TableHead>
                <TableHead className="text-sm font-medium uppercase">
                  Git
                </TableHead>
                <TableHead className="text-sm font-medium uppercase">
                  Hostname
                </TableHead>
                <TableHead className="text-sm font-medium uppercase">
                  Start Time
                </TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {(() => {
                const indexOfLastSession = currentPage * sessionsPerPage;
                const indexOfFirstSession =
                  indexOfLastSession - sessionsPerPage;
                const currentSessions = allSessions.slice(
                  indexOfFirstSession,
                  indexOfLastSession
                );

                return currentSessions.map((session, index) => (
                  <TableRow
                    key={`${session.sessionId}-${session.startTime}-${index}`}
                  >
                    <TableCell>
                      <Badge
                        variant="outline"
                        className="flex items-center gap-1.5"
                      >
                        {session.agentName.toLowerCase() === "claude" && (
                          <Image
                            src="/claude-color.png"
                            alt="Claude"
                            width={12}
                            height={12}
                            className="w-3 h-3"
                          />
                        )}
                        {session.agentName.toLowerCase() === "gemini" && (
                          <Image
                            src="/gemini-color.png"
                            alt="Gemini"
                            width={12}
                            height={12}
                            className="w-3 h-3"
                          />
                        )}
                        {session.agentName.toLowerCase() === "codex" && (
                          <Image
                            src="/codex.svg"
                            alt="Codex"
                            width={12}
                            height={12}
                            className="w-3 h-3 dark:invert"
                          />
                        )}
                        {session.agentName.toLowerCase() === "cursor" && (
                          <Image
                            src="/cursor.svg"
                            alt="Cursor"
                            width={12}
                            height={12}
                            className="w-3 h-3"
                          />
                        )}
                        {session.agentName.toLowerCase() === "opencode" && (
                          <Image
                            src="/opencode.webp"
                            alt="OpenCode"
                            width={12}
                            height={12}
                            className="w-3 h-3"
                          />
                        )}
                        <span className="text-sm font-medium">
                          {(() => {
                            const displayNames: Record<string, string> = {
                              claude: "claude-code",
                              gemini: "gemini-cli",
                              codex: "codex",
                              cursor: "cursor",
                              opencode: "opencode",
                            };
                            return (
                              displayNames[session.agentName.toLowerCase()] ||
                              session.agentName
                            );
                          })()}
                        </span>
                      </Badge>
                    </TableCell>
                    <TableCell>
                      <Badge
                        variant={
                          session.status === "active" ? "default" : "secondary"
                        }
                        className={`text-sm ${
                          session.status === "active"
                            ? "bg-green-100 text-green-800 border-green-200"
                            : ""
                        }`}
                      >
                        {session.status || "terminated"}
                      </Badge>
                    </TableCell>
                    <TableCell>
                      <Badge
                        variant={
                          session.executionMode === "sandbox"
                            ? "default"
                            : "outline"
                        }
                        className={`text-sm ${
                          session.executionMode === "sandbox"
                            ? "bg-blue-100 text-blue-800 border-blue-200"
                            : ""
                        }`}
                      >
                        {session.executionMode || "local"}
                      </Badge>
                    </TableCell>
                    <TableCell>
                      {formatDuration(session.duration || 0)}
                    </TableCell>
                    <TableCell>{session.filesChanged.length}</TableCell>
                    <TableCell>
                      <span className="text-sm font-medium">
                        {session.systemInfo?.projectName || "Unknown"}
                      </span>
                    </TableCell>
                    <TableCell>
                      <span className="text-sm font-mono">
                        {session.systemInfo?.gitBranch || "No git"}
                      </span>
                    </TableCell>
                    <TableCell>
                      <span className="text-sm font-mono">
                        {session.systemInfo?.hostname || "Unknown"}
                      </span>
                    </TableCell>
                    <TableCell>
                      {new Date(session.startTime).toLocaleString()}
                    </TableCell>
                  </TableRow>
                ));
              })()}
            </TableBody>
          </Table>

          {/* Pagination Controls */}
          <div className="flex items-center justify-between space-x-2 py-4">
            <div className="text-sm text-muted-foreground">
              Showing {(currentPage - 1) * sessionsPerPage + 1} to{" "}
              {Math.min(currentPage * sessionsPerPage, allSessions.length)} of{" "}
              {allSessions.length} sessions
            </div>
            <div className="flex space-x-2">
              <button
                onClick={() => setCurrentPage((prev) => Math.max(prev - 1, 1))}
                disabled={currentPage === 1}
                className="px-3 py-1 text-sm font-medium rounded-md border border-border hover:bg-accent disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Previous
              </button>

              {/* Page numbers */}
              <div className="flex space-x-1">
                {Array.from(
                  { length: Math.ceil(allSessions.length / sessionsPerPage) },
                  (_, i) => i + 1
                )
                  .filter((page) => {
                    // Show first page, last page, current page, and pages around current
                    const totalPages = Math.ceil(
                      allSessions.length / sessionsPerPage
                    );
                    if (page === 1 || page === totalPages) return true;
                    if (Math.abs(page - currentPage) <= 1) return true;
                    return false;
                  })
                  .map((page, index, array) => (
                    <React.Fragment key={page}>
                      {index > 0 && array[index - 1] < page - 1 && (
                        <span className="px-2 py-1 text-sm">...</span>
                      )}
                      <button
                        onClick={() => setCurrentPage(page)}
                        className={`px-3 py-1 text-sm font-medium rounded-md border ${
                          currentPage === page
                            ? "bg-primary text-primary-foreground border-primary"
                            : "border-border hover:bg-accent"
                        }`}
                      >
                        {page}
                      </button>
                    </React.Fragment>
                  ))}
              </div>

              <button
                onClick={() =>
                  setCurrentPage((prev) =>
                    Math.min(
                      prev + 1,
                      Math.ceil(allSessions.length / sessionsPerPage)
                    )
                  )
                }
                disabled={
                  currentPage ===
                  Math.ceil(allSessions.length / sessionsPerPage)
                }
                className="px-3 py-1 text-sm font-medium rounded-md border border-border hover:bg-accent disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Next
              </button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}



================================================
FILE: packages/dashboard/app/api/analytics/route.ts
================================================
import { NextRequest, NextResponse } from 'next/server';
import { getAnalyticsData } from '@/lib/analytics';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const days = parseInt(searchParams.get('days') || '7');
    const agentName = searchParams.get('agent') || undefined;

    const analytics = await getAnalyticsData(days, agentName);
    
    return NextResponse.json(analytics);
  } catch (error) {
    console.error('Failed to fetch analytics:', error);
    return NextResponse.json(
      { error: 'Failed to fetch analytics data' },
      { status: 500 }
    );
  }
}


================================================
FILE: packages/dashboard/app/api/analytics/summary/route.ts
================================================
import { NextRequest, NextResponse } from 'next/server';
import { getAnalyticsData, generateSummary } from '@/lib/analytics';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const days = parseInt(searchParams.get('days') || '7');
    const agentName = searchParams.get('agent') || undefined;

    const analytics = await getAnalyticsData(days, agentName);
    const summary = generateSummary(analytics);
    
    return NextResponse.json(summary);
  } catch (error) {
    console.error('Failed to generate analytics summary:', error);
    return NextResponse.json(
      { error: 'Failed to generate analytics summary' },
      { status: 500 }
    );
  }
}


================================================
FILE: packages/dashboard/app/api/settings/route.ts
================================================
import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs-extra';
import path from 'path';
import os from 'os';

const settingsPath = path.join(os.homedir(), '.vibekit', 'settings.json');

// Match the exact structure from cli.js readSettings()
const defaultSettings = {
  sandbox: { enabled: false, type: 'docker' },
  proxy: { enabled: true, redactionEnabled: true },
  analytics: { enabled: true },
  aliases: { enabled: false }
};

export async function GET() {
  try {
    await fs.ensureDir(path.dirname(settingsPath));
    
    if (await fs.pathExists(settingsPath)) {
      const settings = await fs.readJson(settingsPath);
      return NextResponse.json({ ...defaultSettings, ...settings });
    } else {
      return NextResponse.json(defaultSettings);
    }
  } catch (error) {
    console.error('Failed to load settings:', error);
    return NextResponse.json(defaultSettings);
  }
}

export async function POST(request: NextRequest) {
  try {
    const settings = await request.json();
    
    await fs.ensureDir(path.dirname(settingsPath));
    await fs.writeJson(settingsPath, settings, { spaces: 2 });
    
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Failed to save settings:', error);
    return NextResponse.json(
      { error: 'Failed to save settings' },
      { status: 500 }
    );
  }
}


================================================
FILE: packages/dashboard/app/dashboard/page.tsx
================================================
import { AppSidebar } from '@/components/app-sidebar'
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from '@/components/ui/breadcrumb'
import { Separator } from '@/components/ui/separator'
import {
  SidebarInset,
  SidebarProvider,
  SidebarTrigger,
} from '@/components/ui/sidebar'

export default function Page() {
  return (
    <SidebarProvider>
      <AppSidebar />
      <SidebarInset>
        <header className="flex h-16 shrink-0 items-center gap-2 transition-[width,height] ease-linear group-has-data-[collapsible=icon]/sidebar-wrapper:h-12">
          <div className="flex items-center gap-2 px-4">
            <SidebarTrigger className="-ml-1" />
            <Separator
              orientation="vertical"
              className="mr-2 data-[orientation=vertical]:h-4"
            />
            <Breadcrumb>
              <BreadcrumbList>
                <BreadcrumbItem className="hidden md:block">
                  <BreadcrumbLink href="#">
                    Building Your Application
                  </BreadcrumbLink>
                </BreadcrumbItem>
                <BreadcrumbSeparator className="hidden md:block" />
                <BreadcrumbItem>
                  <BreadcrumbPage>Data Fetching</BreadcrumbPage>
                </BreadcrumbItem>
              </BreadcrumbList>
            </Breadcrumb>
          </div>
        </header>
        <div className="flex flex-1 flex-col gap-4 p-4 pt-0">
          <div className="grid auto-rows-min gap-4 md:grid-cols-3">
            <div className="bg-muted/50 aspect-video rounded-xl" />
            <div className="bg-muted/50 aspect-video rounded-xl" />
            <div className="bg-muted/50 aspect-video rounded-xl" />
          </div>
          <div className="bg-muted/50 min-h-[100vh] flex-1 rounded-xl md:min-h-min" />
        </div>
      </SidebarInset>
    </SidebarProvider>
  )
}



================================================
FILE: packages/dashboard/app/settings/page.tsx
================================================
"use client";

import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { SidebarTrigger } from "@/components/ui/sidebar";
import { Settings, Shield, BarChart3, Link, RefreshCw } from "lucide-react";
import { useRouter } from "next/navigation";

// Match the exact structure from cli.js readSettings()
interface VibeKitSettings {
  sandbox: {
    enabled: boolean;
    type: string;
  };
  proxy: {
    enabled: boolean;
    redactionEnabled: boolean;
  };
  analytics: {
    enabled: boolean;
  };
  aliases: {
    enabled: boolean;
  };
}

export default function SettingsPage() {
  const router = useRouter();
  const [settings, setSettings] = useState<VibeKitSettings>({
    sandbox: {
      enabled: false,
      type: 'docker',
    },
    proxy: {
      enabled: true,
      redactionEnabled: true,
    },
    analytics: {
      enabled: true,
    },
    aliases: {
      enabled: false,
    },
  });
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);

  useEffect(() => {
    loadSettings();
  }, []);

  const loadSettings = async () => {
    try {
      const response = await fetch("/api/settings");
      if (response.ok) {
        const loadedSettings = await response.json();
        setSettings(loadedSettings);
      }
    } catch (error) {
      console.error("Failed to load settings:", error);
    } finally {
      setLoading(false);
    }
  };

  const saveSettings = async (newSettings: VibeKitSettings) => {
    setSaving(true);
    try {
      const response = await fetch("/api/settings", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(newSettings),
      });

      if (response.ok) {
        setSettings(newSettings);
      } else {
        throw new Error("Failed to save settings");
      }
    } catch (error) {
      console.error("Failed to save settings:", error);
    } finally {
      setSaving(false);
    }
  };

  const handleToggle = (category: keyof VibeKitSettings, setting: string) => {
    const newSettings = {
      ...settings,
      [category]: {
        ...settings[category],
        [setting]:
          !settings[category][
            setting as keyof (typeof settings)[typeof category]
          ],
      },
    };
    saveSettings(newSettings);
  };

  if (loading) {
    return (
      <div className="px-6 space-y-6">
        <div className="-mx-6 px-4 border-b flex h-12 items-center">
          <div className="flex items-center gap-2">
            <SidebarTrigger />
            <h1 className="text-lg font-bold">Settings</h1>
          </div>
        </div>
        <div className="flex items-center justify-center min-h-[50vh]">
          <RefreshCw className="h-8 w-8 animate-spin text-muted-foreground" />
        </div>
      </div>
    );
  }

  return (
    <div className="px-6 space-y-6">
      <div className="-mx-6 px-4 border-b flex h-12 items-center">
        <div className="flex items-center gap-2">
          <SidebarTrigger />
          <h1 className="text-lg font-bold">Settings</h1>
        </div>
      </div>

      <div className="grid gap-6 md:grid-cols-2">
        {/* Analytics Settings */}
        <Card>
          <CardHeader>
            <div className="flex items-center gap-2">
              <BarChart3 className="h-5 w-5" />
              <CardTitle>Analytics</CardTitle>
            </div>
            <CardDescription>
              Control analytics collection and dashboard features
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-between">
              <div className="space-y-0.5">
                <Label htmlFor="analytics-enabled">Enable Analytics</Label>
                <p className="text-sm text-muted-foreground">
                  Collect and store usage analytics for the dashboard
                </p>
              </div>
              <Switch
                id="analytics-enabled"
                checked={settings.analytics.enabled}
                onCheckedChange={() => handleToggle("analytics", "enabled")}
                disabled={saving}
              />
            </div>
          </CardContent>
        </Card>

        {/* Proxy Settings */}
        <Card>
          <CardHeader>
            <div className="flex items-center gap-2">
              <Shield className="h-5 w-5" />
              <CardTitle>Proxy Server</CardTitle>
            </div>
            <CardDescription>
              Configure proxy server and security settings
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-between">
              <div className="space-y-0.5">
                <Label htmlFor="proxy-enabled">Enable Proxy</Label>
                <p className="text-sm text-muted-foreground">
                  Enable the proxy server functionality
                </p>
              </div>
              <Switch
                id="proxy-enabled"
                checked={settings.proxy.enabled}
                onCheckedChange={() => handleToggle("proxy", "enabled")}
                disabled={saving}
              />
            </div>
            <Separator />
            <div className="flex items-center justify-between">
              <div className="space-y-0.5">
                <Label htmlFor="redaction-enabled">Data Redaction</Label>
                <p className="text-sm text-muted-foreground">
                  Redact secrets, API keys, and sensitive data from coding agent output
                </p>
              </div>
              <Switch
                id="redaction-enabled"
                checked={settings.proxy.redactionEnabled}
                onCheckedChange={() =>
                  handleToggle("proxy", "redactionEnabled")
                }
                disabled={saving || !settings.proxy.enabled}
              />
            </div>
          </CardContent>
        </Card>

        {/* Sandbox Settings */}
        <Card>
          <CardHeader>
            <div className="flex items-center gap-2">
              <Settings className="h-5 w-5" />
              <CardTitle>Sandbox</CardTitle>
            </div>
            <CardDescription>
              Configure sandbox isolation for secure execution
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-between">
              <div className="space-y-0.5">
                <Label htmlFor="sandbox-enabled">Enable Sandbox</Label>
                <p className="text-sm text-muted-foreground">
                  Enable sandbox isolation for secure command execution
                </p>
              </div>
              <Switch
                id="sandbox-enabled"
                checked={settings.sandbox.enabled}
                onCheckedChange={() => handleToggle("sandbox", "enabled")}
                disabled={saving}
              />
            </div>
          </CardContent>
        </Card>

        {/* Connect IDE Settings */}
        <Card>
          <CardHeader>
            <div className="flex items-center gap-2">
              <Link className="h-5 w-5" />
              <CardTitle>Connect IDE</CardTitle>
            </div>
            <CardDescription>
              Create global command aliases for easier access
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-between">
              <div className="space-y-0.5">
                <div className="flex items-center gap-2">
                  <Label htmlFor="aliases-enabled">Enable IDE Integration</Label>
                  {settings.aliases.enabled && (
                    <Badge variant="secondary" className="text-xs">
                      Requires restart
                    </Badge>
                  )}
                </div>
                <p className="text-sm text-muted-foreground">
                  Create global &quot;claude&quot; and &quot;gemini&quot;
                  commands
                </p>
              </div>
              <Switch
                id="aliases-enabled"
                checked={settings.aliases.enabled}
                onCheckedChange={() => handleToggle("aliases", "enabled")}
                disabled={saving}
              />
            </div>
          </CardContent>
        </Card>
      </div>

      {saving && (
        <div className="flex items-center justify-center p-4">
          <RefreshCw className="h-4 w-4 animate-spin mr-2" />
          <span className="text-sm text-muted-foreground">
            Saving settings...
          </span>
        </div>
      )}
    </div>
  );
}



================================================
FILE: packages/dashboard/components/app-sidebar.tsx
================================================
"use client";

import type * as React from "react";
import {
  ChartSpline,
  LucideGithub as Github,
  BookOpen,
  Palette,
  Info,
} from "lucide-react";
import { usePathname } from "next/navigation";
import Link from "next/link";

import { NavMain } from "@/components/nav-main";
import { ThemeToggle } from "@/components/theme-toggle";
import packageJson from "../package.json";
import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarHeader,
  SidebarRail,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/components/ui/sidebar";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

const getNavData = (pathname: string) => ({
  navMain: [
    {
      title: "Usage",
      url: "/",
      icon: ChartSpline,
      isActive: pathname === "/",
    },
  ],
  footerLinks: [
    {
      title: "Github",
      url: "https://github.com/superagent-ai/vibekit",
      icon: Github,
    },
    {
      title: "Documentation",
      url: "https://docs.vibekit.com",
      icon: BookOpen,
    },
    {
      title: "Theme",
      url: "#",
      icon: Palette,
      isThemeToggle: true,
    },
    {
      title: `v${packageJson.version}`,
      url: "#",
      icon: Info,
      isVersion: true,
    },
  ],
});

export function AppSidebar({ ...props }: React.ComponentProps<typeof Sidebar>) {
  const pathname = usePathname();
  const data = getNavData(pathname);
  return (
    <TooltipProvider>
      <Sidebar collapsible="icon" {...props}>
        <SidebarHeader>
          <SidebarMenu>
            <SidebarMenuItem>
              <SidebarMenuButton asChild>
                <Link href="/">
                  <div className="bg-muted flex aspect-square size-4 items-center justify-center rounded-lg">
                    <span className="text-lg">ðŸ––</span>
                  </div>
                  <div
                    className="grid flex-1 text-left leading-tight"
                    style={{ fontFamily: "helvetica, sans-serif" }}
                  >
                    <span className="truncate text-md font-bold">VibeKit</span>
                  </div>
                </Link>
              </SidebarMenuButton>
            </SidebarMenuItem>
          </SidebarMenu>
        </SidebarHeader>
        <SidebarContent>
          <NavMain items={data.navMain} />
        </SidebarContent>
        <SidebarFooter>
          <SidebarMenu>
            {data.footerLinks.map((link) => (
              <SidebarMenuItem key={link.title}>
                {link.isThemeToggle ? (
                  <ThemeToggle />
                ) : link.isVersion ? (
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <SidebarMenuButton>
                        <link.icon className="text-muted-foreground" />
                        <span className="text-muted-foreground">
                          {link.title}
                        </span>
                      </SidebarMenuButton>
                    </TooltipTrigger>
                    <TooltipContent side="right">
                      <p>VibeKit Version {packageJson.version}</p>
                    </TooltipContent>
                  </Tooltip>
                ) : (
                  <SidebarMenuButton asChild>
                    <a
                      href={link.url}
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      <link.icon />
                      <span>{link.title}</span>
                    </a>
                  </SidebarMenuButton>
                )}
              </SidebarMenuItem>
            ))}
          </SidebarMenu>
        </SidebarFooter>
        <SidebarRail />
      </Sidebar>
    </TooltipProvider>
  );
}



================================================
FILE: packages/dashboard/components/metric-card.tsx
================================================
'use client'

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"

interface MetricCardProps {
  title: string
  value: string | number
  description?: string
  trend?: {
    value: number
    label: string
    positive?: boolean
  }
  badge?: {
    text: string
    variant?: "default" | "secondary" | "destructive" | "outline"
  }
}

export function MetricCard({ title, value, description, trend, badge }: MetricCardProps) {
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">{title}</CardTitle>
        {badge && (
          <Badge variant={badge.variant || "secondary"}>
            {badge.text}
          </Badge>
        )}
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
        {description && (
          <p className="text-xs text-muted-foreground">
            {description}
          </p>
        )}
        {trend && (
          <p className="text-xs text-muted-foreground">
            <span className={trend.positive !== false ? "text-green-600" : "text-red-600"}>
              {trend.positive !== false ? "+" : ""}{trend.value}%
            </span>{" "}
            {trend.label}
          </p>
        )}
      </CardContent>
    </Card>
  )
}


================================================
FILE: packages/dashboard/components/nav-main.tsx
================================================
"use client"

import type { LucideIcon } from "lucide-react"
import Link from "next/link"

import { SidebarGroup, SidebarMenu, SidebarMenuButton, SidebarMenuItem } from "@/components/ui/sidebar"

export function NavMain({
  items,
}: {
  items: {
    title: string
    url: string
    icon?: LucideIcon
    isActive?: boolean
  }[]
}) {
  return (
    <SidebarGroup>
      <SidebarMenu>
        {items.map((item) => (
          <SidebarMenuItem key={item.title}>
            <SidebarMenuButton tooltip={item.title} isActive={item.isActive} asChild>
              <Link href={item.url}>
                {item.icon && <item.icon />}
                <span>{item.title}</span>
              </Link>
            </SidebarMenuButton>
          </SidebarMenuItem>
        ))}
      </SidebarMenu>
    </SidebarGroup>
  )
}



================================================
FILE: packages/dashboard/components/nav-projects.tsx
================================================
"use client"

import {
  Folder,
  Forward,
  MoreHorizontal,
  Trash2,
  type LucideIcon,
} from "lucide-react"

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import {
  SidebarGroup,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuButton,
  SidebarMenuItem,
  useSidebar,
} from '@/components/ui/sidebar'

export function NavProjects({
  projects,
}: {
  projects: {
    name: string
    url: string
    icon: LucideIcon
  }[]
}) {
  const { isMobile } = useSidebar()

  return (
    <SidebarGroup className="group-data-[collapsible=icon]:hidden">
      <SidebarGroupLabel>Projects</SidebarGroupLabel>
      <SidebarMenu>
        {projects.map((item) => (
          <SidebarMenuItem key={item.name}>
            <SidebarMenuButton asChild>
              <a href={item.url}>
                <item.icon />
                <span>{item.name}</span>
              </a>
            </SidebarMenuButton>
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <SidebarMenuAction showOnHover>
                  <MoreHorizontal />
                  <span className="sr-only">More</span>
                </SidebarMenuAction>
              </DropdownMenuTrigger>
              <DropdownMenuContent
                className="w-48 rounded-lg"
                side={isMobile ? "bottom" : "right"}
                align={isMobile ? "end" : "start"}
              >
                <DropdownMenuItem>
                  <Folder className="text-muted-foreground" />
                  <span>View Project</span>
                </DropdownMenuItem>
                <DropdownMenuItem>
                  <Forward className="text-muted-foreground" />
                  <span>Share Project</span>
                </DropdownMenuItem>
                <DropdownMenuSeparator />
                <DropdownMenuItem>
                  <Trash2 className="text-muted-foreground" />
                  <span>Delete Project</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </SidebarMenuItem>
        ))}
        <SidebarMenuItem>
          <SidebarMenuButton className="text-sidebar-foreground/70">
            <MoreHorizontal className="text-sidebar-foreground/70" />
            <span>More</span>
          </SidebarMenuButton>
        </SidebarMenuItem>
      </SidebarMenu>
    </SidebarGroup>
  )
}



================================================
FILE: packages/dashboard/components/nav-user.tsx
================================================
"use client"

import {
  BadgeCheck,
  Bell,
  ChevronsUpDown,
  CreditCard,
  LogOut,
  Sparkles,
} from "lucide-react"

import {
  Avatar,
  AvatarFallback,
  AvatarImage,
} from '@/components/ui/avatar'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import {
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  useSidebar,
} from '@/components/ui/sidebar'

export function NavUser({
  user,
}: {
  user: {
    name: string
    email: string
    avatar: string
  }
}) {
  const { isMobile } = useSidebar()

  return (
    <SidebarMenu>
      <SidebarMenuItem>
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <SidebarMenuButton
              size="lg"
              className="data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground"
            >
              <Avatar className="h-8 w-8 rounded-lg">
                <AvatarImage src={user.avatar} alt={user.name} />
                <AvatarFallback className="rounded-lg">CN</AvatarFallback>
              </Avatar>
              <div className="grid flex-1 text-left text-sm leading-tight">
                <span className="truncate font-medium">{user.name}</span>
                <span className="truncate text-xs">{user.email}</span>
              </div>
              <ChevronsUpDown className="ml-auto size-4" />
            </SidebarMenuButton>
          </DropdownMenuTrigger>
          <DropdownMenuContent
            className="w-(--radix-dropdown-menu-trigger-width) min-w-56 rounded-lg"
            side={isMobile ? "bottom" : "right"}
            align="end"
            sideOffset={4}
          >
            <DropdownMenuLabel className="p-0 font-normal">
              <div className="flex items-center gap-2 px-1 py-1.5 text-left text-sm">
                <Avatar className="h-8 w-8 rounded-lg">
                  <AvatarImage src={user.avatar} alt={user.name} />
                  <AvatarFallback className="rounded-lg">CN</AvatarFallback>
                </Avatar>
                <div className="grid flex-1 text-left text-sm leading-tight">
                  <span className="truncate font-medium">{user.name}</span>
                  <span className="truncate text-xs">{user.email}</span>
                </div>
              </div>
            </DropdownMenuLabel>
            <DropdownMenuSeparator />
            <DropdownMenuGroup>
              <DropdownMenuItem>
                <Sparkles />
                Upgrade to Pro
              </DropdownMenuItem>
            </DropdownMenuGroup>
            <DropdownMenuSeparator />
            <DropdownMenuGroup>
              <DropdownMenuItem>
                <BadgeCheck />
                Account
              </DropdownMenuItem>
              <DropdownMenuItem>
                <CreditCard />
                Billing
              </DropdownMenuItem>
              <DropdownMenuItem>
                <Bell />
                Notifications
              </DropdownMenuItem>
            </DropdownMenuGroup>
            <DropdownMenuSeparator />
            <DropdownMenuItem>
              <LogOut />
              Log out
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </SidebarMenuItem>
    </SidebarMenu>
  )
}



================================================
FILE: packages/dashboard/components/team-switcher.tsx
================================================
"use client"

import * as React from "react"
import { ChevronsUpDown, Plus } from "lucide-react"

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import {
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  useSidebar,
} from '@/components/ui/sidebar'

export function TeamSwitcher({
  teams,
}: {
  teams: {
    name: string
    logo: React.ElementType
    plan: string
  }[]
}) {
  const { isMobile } = useSidebar()
  const [activeTeam, setActiveTeam] = React.useState(teams[0])

  if (!activeTeam) {
    return null
  }

  return (
    <SidebarMenu>
      <SidebarMenuItem>
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <SidebarMenuButton
              size="lg"
              className="data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground"
            >
              <div className="bg-sidebar-primary text-sidebar-primary-foreground flex aspect-square size-8 items-center justify-center rounded-lg">
                <activeTeam.logo className="size-4" />
              </div>
              <div className="grid flex-1 text-left text-sm leading-tight">
                <span className="truncate font-medium">{activeTeam.name}</span>
                <span className="truncate text-xs">{activeTeam.plan}</span>
              </div>
              <ChevronsUpDown className="ml-auto" />
            </SidebarMenuButton>
          </DropdownMenuTrigger>
          <DropdownMenuContent
            className="w-(--radix-dropdown-menu-trigger-width) min-w-56 rounded-lg"
            align="start"
            side={isMobile ? "bottom" : "right"}
            sideOffset={4}
          >
            <DropdownMenuLabel className="text-muted-foreground text-xs">
              Teams
            </DropdownMenuLabel>
            {teams.map((team, index) => (
              <DropdownMenuItem
                key={team.name}
                onClick={() => setActiveTeam(team)}
                className="gap-2 p-2"
              >
                <div className="flex size-6 items-center justify-center rounded-md border">
                  <team.logo className="size-3.5 shrink-0" />
                </div>
                {team.name}
                <DropdownMenuShortcut>âŒ˜{index + 1}</DropdownMenuShortcut>
              </DropdownMenuItem>
            ))}
            <DropdownMenuSeparator />
            <DropdownMenuItem className="gap-2 p-2">
              <div className="flex size-6 items-center justify-center rounded-md border bg-transparent">
                <Plus className="size-4" />
              </div>
              <div className="text-muted-foreground font-medium">Add team</div>
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </SidebarMenuItem>
    </SidebarMenu>
  )
}



================================================
FILE: packages/dashboard/components/theme-provider.tsx
================================================
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}


================================================
FILE: packages/dashboard/components/theme-toggle.tsx
================================================
"use client"

import * as React from "react"
import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"

import { SidebarMenuButton } from "@/components/ui/sidebar"

export function ThemeToggle() {
  const { setTheme, theme } = useTheme()

  return (
    <SidebarMenuButton
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
      tooltip="Toggle theme"
    >
      <Sun className="h-4 w-4 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
      <Moon className="absolute h-4 w-4 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
      <span>Theme</span>
    </SidebarMenuButton>
  )
}


================================================
FILE: packages/dashboard/components/ui/avatar.tsx
================================================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }



================================================
FILE: packages/dashboard/components/ui/badge.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }



================================================
FILE: packages/dashboard/components/ui/breadcrumb.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className
      )}
      {...props}
    />
  )
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  )
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  )
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  )
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  )
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  )
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}



================================================
FILE: packages/dashboard/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: packages/dashboard/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}



================================================
FILE: packages/dashboard/components/ui/dropdown-menu.tsx
================================================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}



================================================
FILE: packages/dashboard/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }



================================================
FILE: packages/dashboard/components/ui/label.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }


================================================
FILE: packages/dashboard/components/ui/separator.tsx
================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }



================================================
FILE: packages/dashboard/components/ui/sheet.tsx
================================================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}



================================================
FILE: packages/dashboard/components/ui/sidebar.tsx
================================================
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, VariantProps } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}



================================================
FILE: packages/dashboard/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: packages/dashboard/components/ui/switch.tsx
================================================
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-keyboard:outline-none focus-keyboard:ring-2 focus-keyboard:ring-ring focus-keyboard:ring-offset-2 focus-keyboard:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-green-500 data-[state=unchecked]:bg-gray-300 dark:data-[state=unchecked]:bg-gray-600 disabled:data-[state=checked]:bg-green-400 disabled:data-[state=unchecked]:bg-gray-200 dark:disabled:data-[state=unchecked]:bg-gray-700",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }


================================================
FILE: packages/dashboard/components/ui/table.tsx
================================================
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium text-sm whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle text-sm whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}



================================================
FILE: packages/dashboard/components/ui/tooltip.tsx
================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



================================================
FILE: packages/dashboard/hooks/use-mobile.ts
================================================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}



================================================
FILE: packages/dashboard/hooks/use-mobile.tsx
================================================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}



================================================
FILE: packages/dashboard/lib/analytics.ts
================================================
import fs from 'fs-extra';
import path from 'path';
import os from 'os';

export interface AnalyticsSession {
  sessionId: string;
  agentName: string;
  startTime: number;
  endTime: number | null;
  duration: number | null;
  status?: 'active' | 'terminated';
  executionMode?: 'sandbox' | 'local';
  inputBytes: number;
  outputBytes: number;
  commands: Array<{
    command: string;
    args: string[];
    timestamp: number;
  }>;
  exitCode: number | null;
  filesChanged: string[];
  filesCreated: string[];
  filesDeleted: string[];
  errors: string[];
  warnings: string[];
  systemInfo?: any;
}

export interface AnalyticsSummary {
  totalSessions: number;
  activeSessions: number;
  totalDuration: number;
  averageDuration: number;
  successfulSessions: number;
  successRate: number;
  totalFilesChanged: number;
  totalErrors: number;
  totalWarnings: number;
  topErrors: Array<{ error: string; count: number }>;
  agentBreakdown: Record<string, {
    sessions: number;
    duration: number;
    successfulSessions: number;
    successRate: number;
    averageDuration: number;
  }>;
}

export async function getAnalyticsData(days = 7, agentName?: string): Promise<AnalyticsSession[]> {
  const analyticsDir = path.join(os.homedir(), '.vibekit', 'analytics');
  
  if (!await fs.pathExists(analyticsDir)) {
    return [];
  }
  
  const files = await fs.readdir(analyticsDir);
  const targetFiles = agentName 
    ? files.filter((f: string) => f.startsWith(`${agentName}-`))
    : files.filter((f: string) => f.endsWith('.json'));
  
  // Filter by date range
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - days);
  
  const allAnalytics: AnalyticsSession[] = [];
  
  for (const file of targetFiles) {
    try {
      const filePath = path.join(analyticsDir, file);
      const content = await fs.readFile(filePath, 'utf8');
      const data = JSON.parse(content);
      
      const filteredData = data.filter((session: AnalyticsSession) => {
        const sessionDate = new Date(session.startTime);
        return sessionDate >= cutoffDate;
      });
      
      allAnalytics.push(...filteredData);
    } catch (error) {
      console.error(`Failed to read analytics file ${file}:`, error);
    }
  }
  
  return allAnalytics.sort((a, b) => b.startTime - a.startTime);
}

export function generateSummary(analytics: AnalyticsSession[]): AnalyticsSummary {
  if (analytics.length === 0) {
    return {
      totalSessions: 0,
      activeSessions: 0,
      totalDuration: 0,
      averageDuration: 0,
      successfulSessions: 0,
      successRate: 0,
      totalFilesChanged: 0,
      totalErrors: 0,
      totalWarnings: 0,
      topErrors: [],
      agentBreakdown: {}
    };
  }

  const summary = {
    totalSessions: analytics.length,
    activeSessions: analytics.filter(a => a.status === 'active').length,
    totalDuration: analytics.reduce((sum, a) => sum + (a.duration || 0), 0),
    successfulSessions: analytics.filter(a => a.exitCode === 0).length,
    totalFilesChanged: analytics.reduce((sum, a) => sum + (a.filesChanged?.length || 0), 0),
    totalErrors: analytics.reduce((sum, a) => sum + (a.errors?.length || 0), 0),
    totalWarnings: analytics.reduce((sum, a) => sum + (a.warnings?.length || 0), 0),
  };

  const averageDuration = summary.totalDuration / summary.totalSessions;
  const successRate = (summary.successfulSessions / summary.totalSessions) * 100;

  // Top errors
  const errorCounts: Record<string, number> = {};
  analytics.forEach(a => {
    a.errors?.forEach(error => {
      errorCounts[error] = (errorCounts[error] || 0) + 1;
    });
  });
  const topErrors = Object.entries(errorCounts)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 5)
    .map(([error, count]) => ({ error, count }));

  // Agent breakdown
  const agentBreakdown: Record<string, {
    sessions: number;
    duration: number;
    successfulSessions: number;
    successRate: number;
    averageDuration: number;
  }> = {};
  analytics.forEach(a => {
    if (!agentBreakdown[a.agentName]) {
      agentBreakdown[a.agentName] = {
        sessions: 0,
        duration: 0,
        successfulSessions: 0,
        successRate: 0,
        averageDuration: 0
      };
    }
    const agent = agentBreakdown[a.agentName];
    agent.sessions++;
    agent.duration += a.duration || 0;
    if (a.exitCode === 0) agent.successfulSessions++;
  });

  Object.keys(agentBreakdown).forEach(agentName => {
    const agent = agentBreakdown[agentName];
    agent.successRate = (agent.successfulSessions / agent.sessions) * 100;
    agent.averageDuration = agent.duration / agent.sessions;
  });

  return {
    ...summary,
    averageDuration,
    successRate,
    topErrors,
    agentBreakdown
  };
}

export function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  } else if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  } else {
    return `${seconds}s`;
  }
}

export function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}


================================================
FILE: packages/dashboard/lib/types.ts
================================================
export interface SystemInfo {
  // Essential System Info
  machineId: string;         // unique machine identifier
  hostname: string;          // os.hostname()
  platform: string;         // os.platform()
  arch: string;              // os.arch()
  release: string;           // os.release()
  totalMemory: number;       // os.totalmem()
  cpuCores: number;          // os.cpus().length
  
  // Development Environment
  nodeVersion: string;       // process.version
  shell?: string;            // process.env.SHELL
  terminal?: string;         // process.env.TERM_PROGRAM
  gitVersion?: string;       // git --version
  
  // Project Context
  projectName?: string;      // project name from package.json, etc.
  projectLanguage?: string;  // detected from package.json, etc.
  projectType?: string;      // npm, cargo, gradle, etc.
  gitBranch?: string;        // current git branch
  gitStatus?: 'clean' | 'dirty'; // git working tree status
  projectFileCount?: number; // approximate file count
}

export interface AnalyticsSession {
  sessionId: string;
  agentName: string;
  startTime: number;
  endTime: number | null;
  duration: number | null;
  status?: 'active' | 'terminated';
  executionMode?: 'sandbox' | 'local';
  inputBytes: number;
  outputBytes: number;
  commands: Array<{
    command: string;
    args: string[];
    timestamp: number;
  }>;
  exitCode: number | null;
  filesChanged: string[];
  filesCreated: string[];
  filesDeleted: string[];
  errors: string[];
  warnings: string[];
  systemInfo: SystemInfo;
}

export interface AnalyticsSummary {
  totalSessions: number;
  activeSessions: number;
  totalDuration: number;
  averageDuration: number;
  successfulSessions: number;
  successRate: number;
  totalFilesChanged: number;
  totalErrors: number;
  totalWarnings: number;
  topErrors: Array<{ error: string; count: number }>;
  agentBreakdown: Record<string, {
    sessions: number;
    duration: number;
    successfulSessions: number;
    successRate: number;
    averageDuration: number;
  }>;
  // System environment breakdown
  machineBreakdown: Record<string, number>;
  hostnameBreakdown: Record<string, number>;
  platformBreakdown: Record<string, number>;
  nodeVersionBreakdown: Record<string, number>;
  projectLanguageBreakdown: Record<string, number>;
  terminalBreakdown: Record<string, number>;
}


================================================
FILE: packages/dashboard/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================
FILE: packages/dashboard/public/opencode.webp
================================================
[Binary file]


================================================
FILE: packages/daytona/README.md
================================================
# @vibe-kit/daytona

Daytona sandbox provider for VibeKit.

## Installation

```bash
npm install @vibe-kit/daytona
```

## Usage

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createDaytonaProvider } from "@vibe-kit/daytona";

// Create the Daytona provider with configuration
const daytonaProvider = createDaytonaProvider({
  apiKey: process.env.DAYTONA_API_KEY!,
  serverUrl: "https://app.daytona.io/api", // optional
  image: "superagentai/vibekit-claude:1.0", // optional, will be auto-selected based on agent
});

// Create the VibeKit instance with the provider
const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.CLAUDE_API_KEY!,
    model: "claude-3-5-sonnet-20241022",
  })
  .withSandbox(daytonaProvider) // Pass the provider instance
  .withWorkingDirectory("/var/custom-workdir") // Optional: specify working directory
  .withSecrets({
    // Any environment variables for the sandbox
    NODE_ENV: "development",
  });

// Use the configured instance
const response = await vibeKit.generateCode("Create a simple React component");
console.log(response);
```

## Configuration

The Daytona provider accepts the following configuration:

- `apiKey` (required): Your Daytona API key
- `serverUrl` (optional): Daytona server URL (defaults to "https://app.daytona.io")
- `image` (optional): Docker image to use. If not provided, it will be auto-selected based on the agent type:
  - `claude` â†’ `superagentai/vibekit-claude:1.0`
  - `opencode` â†’ `superagentai/vibekit-opencode:1.0`
  - `gemini` â†’ `superagentai/vibekit-gemini:1.0`
  - `codex` â†’ `superagentai/vibekit-codex:1.0`

## Migration from v0.0.x

Previous versions used a factory pattern with configuration objects. The new version uses provider instances:

### Before (v0.0.x)
```typescript
const vibeKit = new VibeKit()
  .withSandbox({
    type: "daytona",
    apiKey: process.env.DAYTONA_API_KEY!,
    serverUrl: "https://app.daytona.io/api",
    image: "superagentai/vibekit-claude:1.0",
  });
```

### After (v0.1.x)
```typescript
import { createDaytonaProvider } from "@vibe-kit/daytona";

const daytonaProvider = createDaytonaProvider({
  apiKey: process.env.DAYTONA_API_KEY!,
  serverUrl: "https://app.daytona.io/api",
  image: "superagentai/vibekit-claude:1.0",
});

const vibeKit = new VibeKit()
  .withSandbox(daytonaProvider);
```

## Features

- Automatic Docker image selection based on agent type
- Support for background command execution
- Workspace management (create, resume, delete)
- Port forwarding support
- Environment variable injection
- Custom working directory support (automatically created)

## Requirements

- Node.js 18+
- Daytona API key
- Access to Daytona workspace

## License

MIT


================================================
FILE: packages/daytona/package.json
================================================
{
  "name": "@vibe-kit/daytona",
  "version": "0.0.5",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    }
  },
  "scripts": {
    "build": "tsup src/index.ts --format esm,cjs --dts",
    "dev": "tsup src/index.ts --watch",
    "type-check": "tsc --noEmit"
  },
  "peerDependencies": {
    "@vibe-kit/sdk": "*"
  },
  "devDependencies": {
    "@types/node": "^22.15.18",
    "tsup": "^8.4.0",
    "typescript": "^5.8.3"
  },
  "dependencies": {
    "@daytonaio/sdk": "^0.22.1"
  }
}



================================================
FILE: packages/daytona/tsconfig.json
================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


================================================
FILE: packages/daytona/src/index.ts
================================================
import {
  Daytona,
  DaytonaConfig as DaytonaSDKConfig,
  Sandbox,
} from "@daytonaio/sdk";

// Define the interfaces we need from the SDK
export interface SandboxExecutionResult {
  exitCode: number;
  stdout: string;
  stderr: string;
}

export interface SandboxCommandOptions {
  timeoutMs?: number;
  background?: boolean;
  onStdout?: (data: string) => void;
  onStderr?: (data: string) => void;
}

export interface SandboxCommands {
  run(
    command: string,
    options?: SandboxCommandOptions
  ): Promise<SandboxExecutionResult>;
}

export interface SandboxInstance {
  sandboxId: string;
  commands: SandboxCommands;
  kill(): Promise<void>;
  pause(): Promise<void>;
  getHost(port: number): Promise<string>;
}

export interface SandboxProvider {
  create(
    envs?: Record<string, string>,
    agentType?: "codex" | "claude" | "opencode" | "gemini" | "grok",
    workingDirectory?: string
  ): Promise<SandboxInstance>;
  resume(sandboxId: string): Promise<SandboxInstance>;
}

export type AgentType = "codex" | "claude" | "opencode" | "gemini" | "grok";

export interface DaytonaConfig {
  apiKey: string;
  image?: string;
  serverUrl?: string;
}

// Helper function to get Docker image based on agent type
const getDockerImageFromAgentType = (agentType?: AgentType) => {
  if (agentType === "codex") {
    return "superagentai/vibekit-codex:1.0";
  } else if (agentType === "claude") {
    return "superagentai/vibekit-claude:1.0";
  } else if (agentType === "opencode") {
    return "superagentai/vibekit-opencode:1.0";
  } else if (agentType === "gemini") {
    return "superagentai/vibekit-gemini:1.1";
  } else if (agentType === "grok") {
    return "superagentai/vibekit-grok-cli:1.0";
  }
  return "ubuntu:22.04";
};

// Daytona implementation
class DaytonaSandboxInstance implements SandboxInstance {
  constructor(
    private workspace: Sandbox, // Daytona workspace object
    private daytona: Daytona, // Daytona client
    public sandboxId: string,
    private envs?: Record<string, string> // Store environment variables
  ) {}

  get commands(): SandboxCommands {
    return {
      run: async (command: string, options?: SandboxCommandOptions) => {
        const session = await this.workspace.process.getSession(
          this.workspace.id
        );
        // Check if background execution is requested - not supported in Daytona
        if (options?.background) {
          const response = await this.workspace.process.executeSessionCommand(
            session.sessionId, // sessionId - using a default session name
            {
              command: command,
              runAsync: true, // run asynchronously for background execution
            },
            undefined // timeout - use default working directory
          );

          // Set up logging for the background command
          this.workspace.process.getSessionCommandLogs(
            session.sessionId,
            response.cmdId!,
            (chunk) => {
              options?.onStdout?.(chunk);
            }
          );

          // Wait for the command to complete
          while (true) {
            const commandInfo = await this.workspace.process.getSessionCommand(
              session.sessionId,
              response.cmdId!
            );

            const exitCode = commandInfo.exitCode;
            if (exitCode !== null && exitCode !== undefined) {
              return {
                exitCode: exitCode,
                stdout: "Background command started successfully",
                stderr: "", // SessionExecuteResponse doesn't have stderr
              };
            }

            // Wait before checking again
            await new Promise((resolve) => setTimeout(resolve, 500));
          }
        }

        try {
          // Execute command using Daytona's process execution API
          // Format: executeCommand(command, cwd?, env?, timeout?)
          const response = await this.workspace.process.executeSessionCommand(
            session.sessionId, // sessionId - using a default session name
            {
              command: command,
              runAsync: false,
            },
            undefined // timeout - use default working directory
          );

          return {
            exitCode: response.exitCode || 0,
            stdout: response.output || "",
            stderr: "", // ExecuteResponse doesn't have stderr
          };
        } catch (error) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          if (options?.onStderr) {
            options.onStderr(errorMessage);
          }
          return {
            exitCode: 1,
            stdout: "",
            stderr: errorMessage,
          };
        }
      },
    };
  }

  async kill(): Promise<void> {
    if (this.daytona && this.workspace) {
      await this.daytona.delete(this.workspace);
    }
  }

  async pause(): Promise<void> {
    // Daytona doesn't have a direct pause equivalent
    console.log(
      "Pause not directly supported for Daytona sandboxes - workspace remains active"
    );
  }

  async getHost(port: number): Promise<string> {
    const previewLink = await this.workspace.getPreviewLink(port);
    return previewLink.url;
  }
}

export class DaytonaSandboxProvider implements SandboxProvider {
  constructor(private config: DaytonaConfig) {}

  async create(
    envs?: Record<string, string>,
    agentType?: AgentType,
    workingDirectory?: string
  ): Promise<SandboxInstance> {
    try {
      // Dynamic import to avoid dependency issues if daytona-sdk is not installed
      const daytonaConfig: DaytonaSDKConfig = {
        apiKey: this.config.apiKey,
        apiUrl: this.config.serverUrl || "https://app.daytona.io/api",
      };

      const daytona = new Daytona(daytonaConfig);

      // Determine default image based on agent type if not specified in config
      let image = this.config.image || getDockerImageFromAgentType(agentType);

      // Create workspace with specified image or default and environment variables
      const workspace = await daytona.create({
        image,
        envVars: envs || {},
      });

      await workspace.process.createSession(workspace.id);

      // Set up working directory if specified
      if (workingDirectory) {
        await workspace.process.executeSessionCommand(
          workspace.id,
          {
            command: `mkdir -p ${workingDirectory}`,
            runAsync: false,
          },
          undefined
        );
      }

      return new DaytonaSandboxInstance(workspace, daytona, workspace.id, envs);
    } catch (error) {
      if (
        error instanceof Error &&
        error.message.includes("Cannot resolve module")
      ) {
        throw new Error(
          "Daytona SDK not found. Please install daytona-sdk: npm install daytona-sdk"
        );
      }
      throw new Error(
        `Failed to create Daytona sandbox: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }
  }

  async resume(sandboxId: string): Promise<SandboxInstance> {
    try {
      const daytonaConfig: DaytonaSDKConfig = {
        apiKey: this.config.apiKey,
        apiUrl: this.config.serverUrl || "https://app.daytona.io/api",
      };

      const daytona = new Daytona(daytonaConfig);

      // Resume workspace by ID
      const workspace = await daytona.get(sandboxId);

      return new DaytonaSandboxInstance(
        workspace,
        daytona,
        sandboxId,
        undefined
      );
    } catch (error) {
      throw new Error(
        `Failed to resume Daytona sandbox: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }
  }
}

export function createDaytonaProvider(
  config: DaytonaConfig
): DaytonaSandboxProvider {
  return new DaytonaSandboxProvider(config);
}



================================================
FILE: packages/e2b/README.md
================================================
# @vibe-kit/e2b

E2B sandbox provider for VibeKit.

## Installation

```bash
npm install @vibe-kit/e2b
```

## Usage

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createE2BProvider } from "@vibe-kit/e2b";

// Create the E2B provider with configuration
const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY!,
  templateId: "vibekit-claude", // optional, will be auto-selected based on agent
});

// Create the VibeKit instance with the provider
const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.CLAUDE_API_KEY!,
    model: "claude-3-5-sonnet-20241022",
  })
  .withSandbox(e2bProvider) // Pass the provider instance
  .withWorkingDirectory("/var/custom-workdir") // Optional: specify working directory
  .withSecrets({
    // Any environment variables for the sandbox
    NODE_ENV: "development",
  });

// Use the configured instance
const response = await vibeKit.generateCode("Create a simple React component");
console.log(response);
```

## Configuration

The E2B provider accepts the following configuration:

- `apiKey` (required): Your E2B API key
- `templateId` (optional): E2B template ID. If not provided, it will be auto-selected based on the agent type:
  - `claude` â†’ `vibekit-claude`
  - `opencode` â†’ `vibekit-opencode`
  - `gemini` â†’ `vibekit-gemini`
  - `codex` â†’ `vibekit-codex`

## Migration from v0.0.x

Previous versions used a factory pattern with configuration objects. The new version uses provider instances:

### Before (v0.0.x)
```typescript
const vibeKit = new VibeKit()
  .withSandbox({
    type: "e2b",
    apiKey: process.env.E2B_API_KEY!,
    templateId: "vibekit-claude",
  });
```

### After (v0.1.x)
```typescript
import { createE2BProvider } from "@vibe-kit/e2b";

const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY!,
  templateId: "vibekit-claude",
});

const vibeKit = new VibeKit()
  .withSandbox(e2bProvider);
```

## Features

- Automatic template selection based on agent type
- Support for background command execution
- 1-hour timeout for long-running operations
- Sandbox pause/resume functionality
- Port forwarding support
- Custom working directory support (automatically created with proper permissions)

## Requirements

- Node.js 18+
- E2B API key

## License

MIT


================================================
FILE: packages/e2b/package.json
================================================
{
  "name": "@vibe-kit/e2b",
  "version": "0.0.5",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    }
  },
  "scripts": {
    "build": "tsup src/index.ts --format esm,cjs --dts",
    "dev": "tsup src/index.ts --watch",
    "type-check": "tsc --noEmit"
  },
  "peerDependencies": {
    "@vibe-kit/sdk": "*"
  },
  "dependencies": {
    "@e2b/code-interpreter": "1.2.0-beta.4"
  },
  "devDependencies": {
    "@types/node": "^22.15.18",
    "tsup": "^8.4.0",
    "typescript": "^5.8.3"
  }
}



================================================
FILE: packages/e2b/tsconfig.json
================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


================================================
FILE: packages/e2b/src/index.ts
================================================
import { Sandbox as E2BSandbox } from "@e2b/code-interpreter";

// Define the interfaces we need from the SDK
export interface SandboxExecutionResult {
  exitCode: number;
  stdout: string;
  stderr: string;
}

export interface SandboxCommandOptions {
  timeoutMs?: number;
  background?: boolean;
  onStdout?: (data: string) => void;
  onStderr?: (data: string) => void;
}

export interface SandboxCommands {
  run(
    command: string,
    options?: SandboxCommandOptions
  ): Promise<SandboxExecutionResult>;
}

export interface SandboxInstance {
  sandboxId: string;
  commands: SandboxCommands;
  kill(): Promise<void>;
  pause(): Promise<void>;
  getHost(port: number): Promise<string>;
}

export interface SandboxProvider {
  create(
    envs?: Record<string, string>,
    agentType?: "codex" | "claude" | "opencode" | "gemini" | "grok",
    workingDirectory?: string
  ): Promise<SandboxInstance>;
  resume(sandboxId: string): Promise<SandboxInstance>;
}

export type AgentType = "codex" | "claude" | "opencode" | "gemini" | "grok";

export interface E2BConfig {
  apiKey: string;
  templateId?: string;
}

// E2B implementation
export class E2BSandboxInstance implements SandboxInstance {
  constructor(private sandbox: E2BSandbox) {}

  get sandboxId(): string {
    return this.sandbox.sandboxId;
  }

  get commands(): SandboxCommands {
    return {
      run: async (command: string, options?: SandboxCommandOptions) => {
        // Extract our custom options and pass the rest to E2B
        const { background, ...e2bOptions } = options || {};

        // E2B has specific overloads for background vs non-background execution
        if (background) {
          // For background execution, E2B returns a CommandHandle, not a CommandResult
          await this.sandbox.commands.run(command, {
            ...e2bOptions,
            background: true,
            onStdout: (data) => console.log("stdout", data),
            onStderr: (data) => console.log("stderr", data),
          });
          // Since we need to return SandboxExecutionResult consistently,
          // return a placeholder result for background commands

          return {
            exitCode: 0,
            stdout: "Background command started successfully",
            stderr: "",
          };
        } else {
          // For non-background execution, E2B returns a CommandResult
          return await this.sandbox.commands.run(command, e2bOptions);
        }
      },
    };
  }

  async kill(): Promise<void> {
    await this.sandbox.kill();
  }

  async pause(): Promise<void> {
    await this.sandbox.pause();
  }

  async getHost(port: number): Promise<string> {
    return await this.sandbox.getHost(port);
  }
}

export class E2BSandboxProvider implements SandboxProvider {
  constructor(private config: E2BConfig) {}

  async create(
    envs?: Record<string, string>,
    agentType?: AgentType,
    workingDirectory?: string
  ): Promise<SandboxInstance> {
    // Determine default template based on agent type if not specified in config
    let templateId = this.config.templateId;
    if (!templateId) {
      if (agentType === "claude") {
        templateId = "vibekit-claude";
      } else if (agentType === "opencode") {
        templateId = "vibekit-opencode";
      } else if (agentType === "gemini") {
        templateId = "vibekit-gemini";
      } else if (agentType === "grok") {
        templateId = "vibekit-grok";
      } else {
        templateId = "vibekit-codex";
      }
    }

    const sandbox = await E2BSandbox.create(templateId, {
      envs,
      apiKey: this.config.apiKey,
      timeoutMs: 3600000, // 1 hour in milliseconds
    });

    // Set up working directory if specified
    if (workingDirectory) {
      await sandbox.commands.run(
        `sudo mkdir -p ${workingDirectory} && sudo chown $USER:$USER ${workingDirectory}`
      );
    }

    return new E2BSandboxInstance(sandbox);
  }

  async resume(sandboxId: string): Promise<SandboxInstance> {
    const sandbox = await E2BSandbox.resume(sandboxId, {
      timeoutMs: 3600000,
      apiKey: this.config.apiKey,
    });
    return new E2BSandboxInstance(sandbox);
  }
}

export function createE2BProvider(config: E2BConfig): E2BSandboxProvider {
  return new E2BSandboxProvider(config);
}



================================================
FILE: packages/northflank/README.md
================================================
# @vibe-kit/northflank

Northflank sandbox provider for VibeKit.

## Installation

```bash
npm install @vibe-kit/northflank
```

## Usage

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createNorthflankProvider } from "@vibe-kit/northflank";

// Create the Northflank provider with configuration
const northflankProvider = createNorthflankProvider({
  apiKey: process.env.NORTHFLANK_API_KEY!,
  projectId: process.env.NORTHFLANK_PROJECT_ID!,
  image: "superagentai/vibekit-claude:1.0", // optional, will be auto-selected based on agent
  billingPlan: "nf-compute-200", // optional
  persistentVolumeStorage: 10240, // optional, 10GiB
  workingDirectory: "/var/vibe0", // optional
});

// Create the VibeKit instance with the provider
const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.CLAUDE_API_KEY!,
    model: "claude-3-5-sonnet-20241022",
  })
  .withSandbox(northflankProvider) // Pass the provider instance
  .withWorkingDirectory("/var/custom-workdir") // Optional: specify working directory
  .withSecrets({
    // Any environment variables for the sandbox
    NODE_ENV: "development",
  });

// Use the configured instance
const response = await vibeKit.generateCode("Create a simple React component");
console.log(response);
```

## Configuration

The Northflank provider accepts the following configuration:

- `apiKey` (required): Your Northflank API key
- `projectId` (required): Your Northflank project ID
- `image` (optional): Docker image to use. If not provided, it will be auto-selected based on the agent type:
  - `claude` â†’ `superagentai/vibekit-claude:1.0`
  - `opencode` â†’ `superagentai/vibekit-opencode:1.0`
  - `gemini` â†’ `superagentai/vibekit-gemini:1.0`
  - `codex` â†’ `superagentai/vibekit-codex:1.0`
- `billingPlan` (optional): Northflank billing plan (defaults to "nf-compute-200")
- `persistentVolumeStorage` (optional): Storage size in MB (defaults to 10240 MB / 10GB)
- `workingDirectory` (optional): Working directory inside the container (defaults to "/var/vibe0")

## Migration from v0.0.x

Previous versions used a factory pattern with configuration objects. The new version uses provider instances:

### Before (v0.0.x)
```typescript
const vibeKit = new VibeKit()
  .withSandbox({
    type: "northflank",
    apiKey: process.env.NORTHFLANK_API_KEY!,
    projectId: process.env.NORTHFLANK_PROJECT_ID!,
    image: "superagentai/vibekit-claude:1.0",
    billingPlan: "nf-compute-200",
    persistentVolumeStorage: 10240,
    workingDirectory: "/var/vibe0",
  });
```

### After (v0.1.x)
```typescript
import { createNorthflankProvider } from "@vibe-kit/northflank";

const northflankProvider = createNorthflankProvider({
  apiKey: process.env.NORTHFLANK_API_KEY!,
  projectId: process.env.NORTHFLANK_PROJECT_ID!,
  image: "superagentai/vibekit-claude:1.0",
  billingPlan: "nf-compute-200",
  persistentVolumeStorage: 10240,
  workingDirectory: "/var/vibe0",
});

const vibeKit = new VibeKit()
  .withSandbox(northflankProvider);
```

## Features

- Automatic Docker image selection based on agent type
- Support for background command execution
- Service management (create, resume, delete, pause)
- Port forwarding support with automatic DNS configuration
- Environment variable injection
- Persistent volume storage
- Custom working directory support (automatically mounted)
- Configurable billing plans and storage sizes

## Requirements

- Node.js 18+
- Northflank API key
- Northflank project ID

## License

MIT


================================================
FILE: packages/northflank/package.json
================================================
{
  "name": "@vibe-kit/northflank",
  "version": "0.0.3",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    }
  },
  "scripts": {
    "build": "tsup src/index.ts --format esm,cjs --dts",
    "dev": "tsup src/index.ts --watch",
    "type-check": "tsc --noEmit"
  },
  "peerDependencies": {
    "@vibe-kit/sdk": "*"
  },
  "dependencies": {
    "@northflank/js-client": "^0.8.2"
  },
  "devDependencies": {
    "@types/node": "^22.15.18",
    "tsup": "^8.4.0",
    "typescript": "^5.8.3"
  }
}



================================================
FILE: packages/northflank/tsconfig.json
================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


================================================
FILE: packages/northflank/src/index.ts
================================================
import {
  ApiClient,
  ApiClientInMemoryContextProvider,
  GetServicePortsResult,
} from "@northflank/js-client";

// Define the interfaces we need from the SDK
export interface SandboxExecutionResult {
  exitCode: number;
  stdout: string;
  stderr: string;
}

export interface SandboxCommandOptions {
  timeoutMs?: number;
  background?: boolean;
  onStdout?: (data: string) => void;
  onStderr?: (data: string) => void;
}

export interface SandboxCommands {
  run(
    command: string,
    options?: SandboxCommandOptions
  ): Promise<SandboxExecutionResult>;
}

export interface SandboxInstance {
  sandboxId: string;
  commands: SandboxCommands;
  kill(): Promise<void>;
  pause(): Promise<void>;
  getHost(port: number): Promise<string>;
}

export interface SandboxProvider {
  create(
    envs?: Record<string, string>,
    agentType?: "codex" | "claude" | "opencode" | "gemini" | "grok",
    workingDirectory?: string
  ): Promise<SandboxInstance>;
  resume(sandboxId: string): Promise<SandboxInstance>;
}

export type AgentType = "codex" | "claude" | "opencode" | "gemini" | "grok";

export interface NorthflankConfig {
  apiKey: string;
  image?: string;
  projectId: string;
  billingPlan?: string;
  persistentVolumeStorage?: number;
  workingDirectory?: string;
}

// Helper function to get Docker image based on agent type
const getDockerImageFromAgentType = (agentType?: AgentType) => {
  if (agentType === "codex") {
    return "superagentai/vibekit-codex:1.0";
  } else if (agentType === "claude") {
    return "superagentai/vibekit-claude:1.0";
  } else if (agentType === "opencode") {
    return "superagentai/vibekit-opencode:1.0";
  } else if (agentType === "gemini") {
    return "superagentai/vibekit-gemini:1.0";
  } else if (agentType === "grok") {
    return "superagentai/vibekit-grok-cli:1.0";
  }
  return "ubuntu:22.04";
};

export class NorthflankSandboxInstance implements SandboxInstance {
  constructor(
    private apiClient: ApiClient,
    public sandboxId: string,
    private projectId: string,
    private workingDirectory: string
  ) {}

  get commands(): SandboxCommands {
    return {
      run: async (command: string, options?: SandboxCommandOptions) => {
        if (options?.background) {
          const handle = await this.apiClient.exec.execServiceSession(
            {
              projectId: this.projectId,
              serviceId: this.sandboxId,
            },
            {
              shell: `bash -c`,
              command,
            }
          );

          handle.stdErr.on("data", (data) =>
            options.onStderr?.(data.toString())
          );
          handle.stdOut.on("data", (data) =>
            options.onStdout?.(data.toString())
          );

          return {
            exitCode: 0,
            stdout: "Background command started successfully",
            stderr: "",
          };
        }

        const handle = await this.apiClient.exec.execServiceSession(
          {
            projectId: this.projectId,
            serviceId: this.sandboxId,
          },
          {
            shell: `bash -c`,
            command,
          }
        );

        const stdoutChunks: string[] = [];
        const stderrChunks: string[] = [];

        handle.stdOut.on("data", (data) => {
          const chunk = data.toString();
          stdoutChunks.push(chunk);
          options?.onStdout?.(chunk);
        });

        handle.stdErr.on("data", (data) => {
          const chunk = data.toString();
          stderrChunks.push(chunk);
          options?.onStderr?.(chunk);
        });

        const result = await handle.waitForCommandResult();

        const fullStdout = stdoutChunks.join("");
        const fullStderr = stderrChunks.join("");

        return {
          exitCode: result.exitCode,
          stdout: fullStdout,
          stderr: fullStderr,
        };
      },
    };
  }

  async kill(): Promise<void> {
    if (this.apiClient && this.sandboxId) {
      await this.apiClient.delete.service({
        parameters: {
          projectId: this.projectId,
          serviceId: this.sandboxId,
        },
      });
    }
  }

  async pause(): Promise<void> {
    await this.apiClient.scale.service({
      parameters: {
        projectId: this.projectId,
        serviceId: this.sandboxId,
      },
      data: {
        instances: 0,
      },
    });
  }

  async getHost(port: number): Promise<string> {
    const existingPorts = await this.apiClient.get.service.ports({
      parameters: {
        projectId: this.projectId,
        serviceId: this.sandboxId,
      },
    });

    const existingPort = existingPorts.data.ports?.find(
      (p) => p.internalPort === port
    );
    if (existingPort) {
      const host = existingPort.dns;
      if (host) {
        return host;
      }
    }

    const input = [
      ...existingPorts.data.ports
        .filter((p) => p.internalPort === port)
        .map((port) => ({
          id: port.id,
          name: port.name,
          internalPort: port.internalPort,
          public: port.public,
          protocol: port.protocol,
          domains: port.domains.map((domain) => domain.name),
        })),
      {
        name: `p-${port}`,
        internalPort: port,
        public: true,
        protocol: "HTTP" as const,
      },
    ].filter(Boolean);

    await this.apiClient.update.service.ports({
      parameters: {
        projectId: this.projectId,
        serviceId: this.sandboxId,
      },
      data: {
        ports: input,
      },
    });

    const newPorts = await this.apiClient.get.service.ports({
      parameters: {
        projectId: this.projectId,
        serviceId: this.sandboxId,
      },
    });

    return (
      newPorts.data.ports?.find(
        (p: GetServicePortsResult["ports"][number]) => p.internalPort === port
      )?.dns || ""
    );
  }
}

export class NorthflankSandboxProvider implements SandboxProvider {
  private static readonly DefaultBillingPlan = "nf-compute-200";
  private static readonly DefaultPersistentVolume = "/var/vibe0";
  private static readonly DefaultPersistentVolumeStorage = 10240; // 10GiB
  private static readonly StatusPollInterval = 1_000; // 1 second
  private static readonly MaxPollTimeout = 300000; // 5 minutes

  constructor(private config: NorthflankConfig) {}

  private async buildAPIClient(projectId: string, apiKey: string) {
    const contextProvider = new ApiClientInMemoryContextProvider();
    await contextProvider.addContext({
      name: "vibekit",
      project: projectId,
      token: apiKey,
    });
    return new ApiClient(contextProvider, { throwErrorOnHttpErrorCode: true });
  }

  private async getServiceStatus(
    apiClient: ApiClient,
    sandboxId: string,
    projectId: string
  ) {
    const deployment = await apiClient.get.service({
      parameters: {
        projectId: projectId,
        serviceId: sandboxId,
      },
    });
    return deployment.data?.status?.deployment?.status;
  }

  private async waitForSandbox(
    apiClient: ApiClient,
    sandboxId: string,
    projectId: string
  ): Promise<void> {
    const startTime = Date.now();

    while (Date.now() - startTime < NorthflankSandboxProvider.MaxPollTimeout) {
      const status = await this.getServiceStatus(
        apiClient,
        sandboxId,
        projectId
      );

      if (status === "COMPLETED") {
        return;
      }

      if (status === "FAILED") {
        throw new Error(`Sandbox deployment failed for ${sandboxId}`);
      }

      await new Promise((resolve) =>
        setTimeout(resolve, NorthflankSandboxProvider.StatusPollInterval)
      );
    }

    throw new Error(`Timeout waiting for sandbox ${sandboxId} to be ready`);
  }

  private generateSandboxId(): string {
    const uuid = crypto.randomUUID().split("-");
    return `sandbox-${uuid[4]}`;
  }

  async create(
    envs?: Record<string, string>,
    agentType?: AgentType,
    workingDirectory?: string
  ): Promise<SandboxInstance> {
    if (!this.config.projectId || !this.config.apiKey) {
      throw new Error(
        "Northflank sandbox configuration missing one of required parameters: projectId, apiKey"
      );
    }

    const apiClient = await this.buildAPIClient(
      this.config.projectId,
      this.config.apiKey
    );

    const sandboxId = this.generateSandboxId();

    // Use the working directory from the method parameter or config
    const finalWorkingDirectory =
      workingDirectory ||
      this.config.workingDirectory ||
      NorthflankSandboxProvider.DefaultPersistentVolume;

    await apiClient.create.service.deployment({
      parameters: {
        projectId: this.config.projectId,
      },
      data: {
        name: sandboxId,
        billing: {
          deploymentPlan:
            this.config.billingPlan ||
            NorthflankSandboxProvider.DefaultBillingPlan,
        },
        deployment: {
          instances: 0,
          external: {
            imagePath:
              this.config.image || getDockerImageFromAgentType(agentType),
          },
          storage: {
            ephemeralStorage: {
              storageSize: 2048,
            },
          },
        },
        runtimeEnvironment: envs || {},
      },
    });

    await apiClient.create.volume({
      parameters: {
        projectId: this.config.projectId,
      },
      data: {
        name: `Data-${sandboxId}`,
        mounts: [
          {
            containerMountPath: finalWorkingDirectory,
          },
        ],
        spec: {
          accessMode: "ReadWriteMany",
          storageClassName: "ssd",
          storageSize:
            this.config.persistentVolumeStorage ??
            NorthflankSandboxProvider.DefaultPersistentVolumeStorage,
        },
        attachedObjects: [
          {
            id: sandboxId,
            type: "service",
          },
        ],
      },
    });

    await apiClient.scale.service({
      parameters: {
        projectId: this.config.projectId,
        serviceId: sandboxId,
      },
      data: {
        instances: 1,
      },
    });

    await this.waitForSandbox(apiClient, sandboxId, this.config.projectId);

    return new NorthflankSandboxInstance(
      apiClient,
      sandboxId,
      this.config.projectId,
      finalWorkingDirectory
    );
  }

  async resume(sandboxId: string): Promise<SandboxInstance> {
    if (!this.config.projectId || !this.config.apiKey) {
      throw new Error(
        "Northflank sandbox configuration missing one of required parameters: projectId, apiKey"
      );
    }

    const apiClient = await this.buildAPIClient(
      this.config.projectId,
      this.config.apiKey
    );
    await apiClient.scale.service({
      parameters: {
        projectId: this.config.projectId,
        serviceId: sandboxId,
      },
      data: {
        instances: 1,
      },
    });

    // Wait for the service to be ready before returning the instance
    await this.waitForSandbox(apiClient, sandboxId, this.config.projectId);

    return new NorthflankSandboxInstance(
      apiClient,
      sandboxId,
      this.config.projectId,
      this.config.workingDirectory ||
        NorthflankSandboxProvider.DefaultPersistentVolume
    );
  }
}

export function createNorthflankProvider(
  config: NorthflankConfig
): NorthflankSandboxProvider {
  return new NorthflankSandboxProvider(config);
}



================================================
FILE: packages/sdk/README.md
================================================
# @vibe-kit/sdk

VibeKit SDK is a TypeScript library that provides a fluent interface for integrating AI coding agents into your applications. It supports multiple AI providers (Claude, Codex, Gemini, Grok, OpenCode) and various sandbox environments for secure code execution.

## Installation

```bash
npm install @vibe-kit/sdk
```

## Quick Start

```typescript
import { VibeKit } from "@vibe-kit/sdk";
import { createE2BProvider } from "@vibe-kit/e2b";

// Configure sandbox provider
const e2bProvider = createE2BProvider({
  apiKey: process.env.E2B_API_KEY!,
  templateId: "vibekit-claude",
});

// Create and configure VibeKit instance
const vibeKit = new VibeKit()
  .withAgent({
    type: "claude",
    provider: "anthropic",
    apiKey: process.env.ANTHROPIC_API_KEY!,
    model: "claude-sonnet-4-20250514",
  })
  .withSandbox(e2bProvider);

// Add event listeners
vibeKit.on("update", (update) => {
  console.log("Update:", update);
});

vibeKit.on("error", (error) => {
  console.error("Error:", error);
});

// Generate code
const result = await vibeKit.generateCode({
  prompt: "Create a simple web app that displays a list of users",
  mode: "code",
});

// Clean up when done
await vibeKit.kill();

console.log("Result:", result);
```

## Configuration

### Agent Configuration

Configure which AI agent to use:

```typescript
.withAgent({
  type: "claude",           // Agent type: "claude", "codex", "opencode", "gemini", "grok"
  provider: "anthropic",    // Provider: "anthropic", "openai", "openrouter", etc.
  apiKey: "your-api-key",   // API key for the provider
  model: "claude-sonnet-4-20250514", // Specific model to use
})
```

### Sandbox Configuration

Configure the execution environment. Install the specific provider package first:

```typescript
// E2B
import { createE2BProvider } from "@vibe-kit/e2b";
const e2bProvider = createE2BProvider({
  apiKey: "e2b_****",
  templateId: "custom-template-id" // optional
});

// Northflank
import { createNorthflankProvider } from "@vibe-kit/northflank";
const northflankProvider = createNorthflankProvider({
  apiKey: "nf_****",
  image: "your-custom-image", // optional
});

// Daytona
import { createDaytonaProvider } from "@vibe-kit/daytona";
const daytonaProvider = createDaytonaProvider({
  apiKey: "daytona_****",
  image: "my-codex-image", // optional
});

.withSandbox(provider)
```

### Additional Configuration

```typescript
// GitHub integration for PR creation
.withGithub({
  token: "ghp_****",
  repository: "owner/repo-name"
})

// Working directory
.withWorkingDirectory("/path/to/project")

// Environment variables
.withSecrets({
  "DATABASE_URL": "postgresql://...",
  "API_KEY": "secret-key"
})

// Reuse existing sandbox session
.withSession("existing-sandbox-id")
```

## API Reference

### `generateCode(options)`

Generate code using the configured AI agent.

```typescript
const result = await vibeKit.generateCode({
  prompt: "Create a React component for a todo list",
  mode: "code", // "code" for generation, "ask" for Q&A
  branch?: "feature-branch", // optional
  history?: conversationHistory, // optional
});
```

### `createPullRequest(labelOptions?, branchPrefix?)`

Create a pull request with generated code.

```typescript
const pr = await vibeKit.createPullRequest();
```

### `executeCommand(command, options?)`

Execute a command in the sandbox.

```typescript
const result = await vibeKit.executeCommand("npm test");
```

### `runTests()`

Run tests in the sandbox.

```typescript
const result = await vibeKit.runTests();
```

### Session Management

```typescript
// Get current session ID
const sessionId = await vibeKit.getSession();

// Set session ID
await vibeKit.setSession("session-id");

// Pause sandbox
await vibeKit.pause();

// Resume sandbox
await vibeKit.resume();

// Kill sandbox
await vibeKit.kill();
```

### `getHost(port)`

Get the host URL for a specific port.

```typescript
const host = await vibeKit.getHost(3000);
console.log(`App running at: ${host}`);
```

## Events

VibeKit extends EventEmitter and emits the following events:

```typescript
vibeKit.on("update", (message: string) => {
  // Streaming updates during code generation
});

vibeKit.on("error", (error: string) => {
  // Error notifications
});

vibeKit.on("stdout", (data: string) => {
  // Standard output from command execution
});

vibeKit.on("stderr", (data: string) => {
  // Standard error from command execution
});
```

## Supported Agents

- **Claude** - Anthropic's Claude models
- **Codex** - OpenAI's Codex models
- **OpenCode** - Open-source coding models
- **Gemini** - Google's Gemini models
- **Grok** - xAI's Grok models

## Supported Sandbox Providers

- **E2B** - Cloud sandboxes
- **Northflank** - Kubernetes-based environments
- **Daytona** - Development environments
- **Cloudflare** - Workers-based sandboxes
- **Dagger** - Container-based execution
- **Modal** - Serverless computing
- **Fly.io** - Edge computing

## Error Handling

```typescript
try {
  const result = await vibeKit.generateCode({
    prompt: "Create a web app",
    mode: "code"
  });
} catch (error) {
  if (error.message.includes('not initialized')) {
    // Handle initialization error
  } else {
    // Handle generation error
  }
}
```

## Examples

### With Conversation History

```typescript
const history = [
  { role: "user", content: "What is React?" },
  { role: "assistant", content: "React is a JavaScript library..." }
];

const response = await vibeKit.generateCode({
  prompt: "Now show me a React component example",
  mode: "code",
  history
});
```

### With Streaming

```typescript
const response = await vibeKit.generateCode({
  prompt: "Explain how React hooks work",
  mode: "ask"
});

// Listen to streaming updates via events
vibeKit.on("update", (message) => {
  console.log("Update:", message);
});
```

## License

MIT

## Contributing

Contributions are welcome! Please read our contributing guidelines before submitting pull requests.


================================================
FILE: packages/sdk/package.json
================================================
{
  "name": "@vibe-kit/sdk",
  "version": "0.0.63",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",

  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    },
    "./services": {
      "types": "./dist/services.d.ts",
      "import": "./dist/services.js",
      "require": "./dist/services.cjs"
    },
    "./registry": {
      "types": "./dist/registry.d.ts",
      "import": "./dist/registry.js",
      "require": "./dist/registry.cjs"
    }
  },
  "scripts": {
    "build": "tsup",
    "dev": "tsup src/index.ts --watch",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.2.12",
    "@ai-sdk/openai": "^1.3.22",
    "@ai-sdk/openai-compatible": "^0.2.14",
    "@types/uuid": "^10.0.0",
    "ai": "^4.3.16",
    "uuid": "^11.1.0",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/node": "^22.15.18",
    "tsup": "^8.4.0",
    "typescript": "^5.8.3"
  }
}



================================================
FILE: packages/sdk/tsconfig.json
================================================
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["dist", "node_modules", "**/*.test.ts"]
} 


================================================
FILE: packages/sdk/tsup.config.ts
================================================
import { defineConfig } from "tsup";

export default defineConfig({
  // Single main entry point to avoid duplication
  entry: {
    index: "src/index.ts",
    services: "src/services/index.ts",
    registry: "src/registry/index.ts",
  },
  format: ["esm", "cjs"],
  dts: true,
  clean: true,
  splitting: true, // Enable code splitting for tree shaking
  sourcemap: false,
  outDir: "dist",
  treeshake: true, // Enable tree shaking
  // No external dependencies needed - everything is bundled
});



================================================
FILE: packages/sdk/src/index.ts
================================================
// Slim core export with dynamic imports
export { VibeKit } from "./core/vibekit";

// Constants exports
export * from "./constants";

// Type exports for user consumption
export type {
  AgentType,
  AgentMode,
  ModelProvider,
  AgentModel,
  E2BConfig,
  DaytonaConfig,
  NorthflankConfig,
  EnvironmentConfig,
  GithubConfig,
  SecretsConfig,
  VibeKitConfig,
  Conversation,
  LabelOptions,
  CodexStreamCallbacks,
  ClaudeStreamCallbacks,
  OpenCodeStreamCallbacks,
  GeminiStreamCallbacks,
  GrokStreamCallbacks,
  CodexConfig,
  CodexResponse,
  ClaudeConfig,
  ClaudeResponse,
  OpenCodeConfig,
  OpenCodeResponse,
  GeminiConfig,
  GeminiResponse,
  GrokConfig,
  GrokResponse,
  SandboxExecutionResult,
  SandboxCommandOptions,
  SandboxCommands,
  SandboxInstance,
  SandboxConfig,
  SandboxProvider,
} from "./types";

// Optional exports with dynamic imports
export const createClaudeAgent = async () => {
  const { ClaudeAgent } = await import("./agents/claude");
  return ClaudeAgent;
};

export const createCodexAgent = async () => {
  const { CodexAgent } = await import("./agents/codex");
  return CodexAgent;
};

export const createOpenCodeAgent = async () => {
  const { OpenCodeAgent } = await import("./agents/opencode");
  return OpenCodeAgent;
};

export const createGeminiAgent = async () => {
  const { GeminiAgent } = await import("./agents/gemini");
  return GeminiAgent;
};

export const createGrokAgent = async () => {
  const { GrokAgent } = await import("./agents/grok");
  return GrokAgent;
};

// Authentication is handled separately via @vibe-kit/auth package
// Users should get tokens from auth package and pass them as API keys

// Additional type exports from agent base
export type { 
  BaseAgentConfig, 
  PullRequestResult,
  AgentResponse,
  ExecuteCommandOptions,
  StreamCallbacks
} from "./agents/base";



================================================
FILE: packages/sdk/src/types.ts
================================================
import { ProviderType } from './constants/providers';
import { AgentType } from './constants/agents';

// AGENTS
export { AgentType };

export type AgentMode = "ask" | "code";

export type ModelProvider =
  | "openai"
  | "anthropic"
  | "openrouter"
  | "azure"
  | "gemini"
  | "google"
  | "ollama"
  | "mistral"
  | "deepseek"
  | "xai"
  | "groq"
  | "arceeai";

export type AgentModel = {
  name?: string;
  provider?: ModelProvider;
  apiKey: string;
};

export type E2BConfig = {
  apiKey: string;
  templateId?: string;
};

export type DaytonaConfig = {
  apiKey: string;
  image?: string;
  serverUrl?: string;
};

export type NorthflankConfig = {
  apiKey: string;
  image?: string;
  projectId?: string;
  billingPlan?: string;
  persistentVolumeStorage?: number;
};

export type EnvironmentConfig = {
  e2b?: E2BConfig;
  daytona?: DaytonaConfig;
  northflank?: NorthflankConfig;
};

export type GithubConfig = {
  token: string;
  repository: string;
};

// SECRETS
export type SecretsConfig = {
  /** Environment variables to be passed to the sandbox */
  [key: string]: string;
};


export type VibeKitConfig = {
  agent: {
    type: AgentType;
    model: AgentModel;
  };
  environment: EnvironmentConfig;
  secrets?: SecretsConfig;
  github?: GithubConfig;
  sessionId?: string;
  /** Working directory inside the sandbox (defaults to "/var/vibe0") */
  workingDirectory?: string;
};

// CONVERSATION HISTORY
export type Conversation = {
  role: "user" | "assistant";
  content: string;
};

// PULL REQUEST LABELS
export interface LabelOptions {
  name: string;
  color: string;
  description: string;
}

// STREAMING CALLBACKS
export interface CodexStreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}

export interface ClaudeStreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}

export interface OpenCodeStreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}

export interface GeminiStreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}

export interface GrokStreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}

// CODEX CONFIG
export interface CodexConfig {
  providerApiKey?: string;
  provider?: ModelProvider;
  githubToken?: string;
  repoUrl?: string; // org/repo, e.g. "octocat/hello-world"
  sandboxProvider?: SandboxProvider;
  secrets?: SecretsConfig;
  model?: string;
  sandboxId?: string;
  workingDirectory?: string;
}

export interface CodexResponse {
  exitCode: number;
  stdout: string;
  stderr: string;
  sandboxId: string;
  patch?: string;
  patchApplyScript?: string;
  branchName?: string;
  commitSha?: string;
}

// CLAUDE CONFIG
export interface ClaudeConfig {
  providerApiKey?: string; // Optional - can use OAuth token instead
  oauthToken?: string; // OAuth token from CLAUDE_CODE_OAUTH_TOKEN
  provider?: ModelProvider;
  githubToken?: string;
  repoUrl?: string; // org/repo, e.g. "octocat/hello-world"
  sandboxProvider?: SandboxProvider;
  secrets?: SecretsConfig;
  model?: string;
  sandboxId?: string;
  workingDirectory?: string;
}

export interface ClaudeResponse {
  exitCode: number;
  stdout: string;
  stderr: string;
  sandboxId: string;
  patch?: string;
  patchApplyScript?: string;
  branchName?: string;
  commitSha?: string;
}

// OPENCODE CONFIG
export interface OpenCodeConfig {
  providerApiKey?: string;
  provider?: ModelProvider;
  githubToken?: string;
  repoUrl?: string; // org/repo, e.g. "octocat/hello-world"
  sandboxProvider?: SandboxProvider;
  secrets?: SecretsConfig;
  model?: string;
  sandboxId?: string;
  workingDirectory?: string;
}

export interface OpenCodeResponse {
  exitCode: number;
  stdout: string;
  stderr: string;
  sandboxId: string;
  patch?: string;
  patchApplyScript?: string;
  branchName?: string;
  commitSha?: string;
}

// GEMINI CONFIG
export interface GeminiConfig {
  providerApiKey?: string;
  provider?: ModelProvider;
  githubToken?: string;
  repoUrl?: string; // org/repo, e.g. "octocat/hello-world"
  sandboxProvider?: SandboxProvider;
  secrets?: SecretsConfig;
  model?: string;
  sandboxId?: string;
  workingDirectory?: string;
}

export interface GeminiResponse {
  exitCode: number;
  stdout: string;
  stderr: string;
  sandboxId: string;
  patch?: string;
  patchApplyScript?: string;
  branchName?: string;
  commitSha?: string;
}

// GROK CONFIG
export interface GrokConfig {
  providerApiKey?: string;
  provider?: ModelProvider;
  githubToken?: string;
  repoUrl?: string; // org/repo, e.g. "octocat/hello-world"
  sandboxProvider?: SandboxProvider;
  secrets?: SecretsConfig;
  model?: string;
  sandboxId?: string;
  workingDirectory?: string;
  baseUrl?: string; // for custom xAI API endpoints
}

export interface GrokResponse {
  exitCode: number;
  stdout: string;
  stderr: string;
  sandboxId: string;
  patch?: string;
  patchApplyScript?: string;
  branchName?: string;
  commitSha?: string;
}

// SANDBOX ABSTRACTION
export interface SandboxExecutionResult {
  exitCode: number;
  stdout: string;
  stderr: string;
}

export interface SandboxCommandOptions {
  timeoutMs?: number;
  background?: boolean;
  onStdout?: (data: string) => void;
  onStderr?: (data: string) => void;
}

export interface SandboxCommands {
  run(
    command: string,
    options?: SandboxCommandOptions
  ): Promise<SandboxExecutionResult>;
}

export interface SandboxInstance {
  sandboxId: string;
  commands: SandboxCommands;
  kill(): Promise<void>;
  pause(): Promise<void>;
  getHost(port: number): Promise<string>;
}

export interface SandboxConfig {
  type: ProviderType;
  apiKey: string;
  templateId?: string; // for E2B
  image?: string; // for Daytona
  serverUrl?: string; // for Daytona
  projectId?: string; // for Northflank
  billingPlan?: string; // for Northflank
  persistentVolume?: string; // for Northflank
  persistentVolumeStorage?: number; // for Northflank
  workingDirectory?: string; // for Nortflank
}

export interface SandboxProvider {
  create(
    envs?: Record<string, string>,
    agentType?: AgentType,
    workingDirectory?: string
  ): Promise<SandboxInstance>;
  resume(sandboxId: string): Promise<SandboxInstance>;
}



================================================
FILE: packages/sdk/src/agents/base.ts
================================================
import {
  generateCommitMessage,
  generatePRMetadata,
  ModelConfig,
} from "./utils";
import {
  Conversation,
  SandboxInstance,
  SandboxProvider,
  LabelOptions,
} from "../types";

// StreamingBuffer class to handle chunked JSON data
class StreamingBuffer {
  private buffer = "";
  private onComplete: (data: string) => void;

  constructor(onComplete: (data: string) => void) {
    this.onComplete = onComplete;
  }

  append(chunk: string): void {
    // Filter out null bytes that can corrupt JSON parsing
    const cleanChunk = chunk.replace(/\0/g, "");
    this.buffer += cleanChunk;
    this.processBuffer();
  }

  private processBuffer(): void {
    let bracketCount = 0;
    let inString = false;
    let escaped = false;
    let start = 0;

    for (let i = 0; i < this.buffer.length; i++) {
      const char = this.buffer[i];

      if (escaped) {
        escaped = false;
        continue;
      }

      if (char === "\\") {
        escaped = true;
        continue;
      }

      if (char === '"') {
        inString = !inString;
        continue;
      }

      if (inString) {
        continue;
      }

      if (char === "{") {
        bracketCount++;
      } else if (char === "}") {
        bracketCount--;

        if (bracketCount === 0) {
          // Found complete JSON object
          const jsonStr = this.buffer.slice(start, i + 1);
          try {
            // Validate JSON before calling callback
            JSON.parse(jsonStr);
            this.onComplete(jsonStr);
          } catch (e) {
            // Invalid JSON, continue buffering
          }

          // Move to next potential JSON object
          start = i + 1;

          // If there's a newline after this JSON, skip it
          if (start < this.buffer.length && this.buffer[start] === "\n") {
            start++;
          }
        }
      }
    }

    // Keep only the remaining unparsed part
    this.buffer = this.buffer.slice(start);
  }

  // Handle any remaining non-JSON output (like raw text)
  flush(): void {
    if (this.buffer.trim()) {
      // If it's not JSON, pass it through as-is
      this.onComplete(this.buffer);
      this.buffer = "";
    }
  }
}

export interface BaseAgentConfig {
  githubToken?: string;
  repoUrl?: string;
  sandboxProvider?: SandboxProvider;
  secrets?: Record<string, string>;
  sandboxId?: string;
  workingDirectory?: string;
}

export interface StreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}

export interface ExecuteCommandOptions {
  timeoutMs?: number;
  background?: boolean;
  callbacks?: StreamCallbacks;
}

export interface AgentResponse {
  sandboxId: string;
  exitCode: number;
  stdout: string;
  stderr: string;
}

export interface PullRequestResult {
  id: number;
  number: number;
  state: string;
  title: string;
  body: string | null;
  html_url: string;
  head: {
    ref: string;
    sha: string;
    repo: any;
  };
  base: {
    ref: string;
    sha: string;
    repo: any;
  };
  user: {
    login: string;
    id: number;
    avatar_url: string;
    html_url: string;
  };
  created_at: string;
  updated_at: string;
  merged: boolean;
  mergeable: boolean | null;
  merge_commit_sha: string | null;
  branchName: string;
  commitSha?: string;
}

export interface AgentCommandConfig {
  command: string;
  errorPrefix: string;
  labelName: string;
  labelColor: string;
  labelDescription: string;
}

export abstract class BaseAgent {
  protected config: BaseAgentConfig;
  protected sandboxInstance?: SandboxInstance;
  protected lastPrompt?: string;
  protected currentBranch?: string;
  protected readonly WORKING_DIR: string;

  constructor(config: BaseAgentConfig) {
    this.config = config;
    this.WORKING_DIR = config.workingDirectory || "/vibe0";
  }

  protected abstract getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig;
  protected abstract getDefaultTemplate(): string;

  private async getSandbox(): Promise<SandboxInstance> {
    if (this.sandboxInstance) return this.sandboxInstance;

    if (!this.config.sandboxProvider) {
      throw new Error("No sandbox provider configured");
    }

    const provider = this.config.sandboxProvider;

    if (this.config.sandboxId) {
      this.sandboxInstance = await provider.resume(this.config.sandboxId);
    } else {
      // Merge agent-specific environment variables with user-defined secrets
      const envVars = {
        ...this.getEnvironmentVariables(),
        ...(this.config.secrets || {}),
      };

      this.sandboxInstance = await provider.create(
        envVars,
        this.getAgentType(),
        this.WORKING_DIR
      );
    }


    return this.sandboxInstance;
  }






  protected abstract getEnvironmentVariables(): Record<string, string>;


  private getMkdirCommand(path: string): string {
    // Use non-sudo commands for better compatibility with Docker containers
    // This works for both E2B-style environments and Docker containers
    return `mkdir -p ${path} || true`;
  }

  public async killSandbox() {

    if (this.sandboxInstance) {
      await this.sandboxInstance.kill();
      this.sandboxInstance = undefined;
    }
  }

  public async pauseSandbox() {
    if (this.sandboxInstance) {
      await this.sandboxInstance.pause();
    }
  }

  public async resumeSandbox() {
    if (this.sandboxInstance && this.config.sandboxProvider) {
      this.sandboxInstance = await this.config.sandboxProvider.resume(
        this.sandboxInstance.sandboxId
      );
    }
  }

  public async getSession() {
    if (this.sandboxInstance) {
      return this.sandboxInstance.sandboxId;
    }
    return this.config.sandboxId || null;
  }

  public async setSession(sessionId: string) {
    this.config.sandboxId = sessionId;
  }

  public setGithubToken(token: string): void {
    this.config.githubToken = token;
  }

  public setGithubRepository(repoUrl: string): void {
    this.config.repoUrl = repoUrl;
  }

  public async getHost(port: number): Promise<string> {
    const sbx = await this.getSandbox();
    return await sbx.getHost(port);
  }

  public getCurrentBranch(): string | undefined {
    return this.currentBranch;
  }

  public async executeCommand(
    command: string,
    options: ExecuteCommandOptions = {}
  ): Promise<AgentResponse> {
    const { timeoutMs = 3600000, background = false, callbacks } = options;

    try {
      const sbx = await this.getSandbox();

      if (!this.config.sandboxId && sbx.sandboxId) {
        callbacks?.onUpdate?.(
          `{"type": "start", "sandbox_id": "${sbx.sandboxId}"}`
        );
      }

      // Ensure working directory exists first
      await sbx.commands.run(this.getMkdirCommand(this.WORKING_DIR), {
        timeoutMs: 30000,
        background: false,
        onStdout: (data) => console.log(data),
      });

      // For executeCommand, always use working directory directly
      const executeCommand = `cd ${this.WORKING_DIR} && ${command}`;

      // Set up streaming buffers for stdout and stderr if callbacks are provided
      let stdoutBuffer: StreamingBuffer | undefined;
      let stderrBuffer: StreamingBuffer | undefined;

      if (callbacks?.onUpdate) {
        stdoutBuffer = new StreamingBuffer(callbacks.onUpdate);
        stderrBuffer = new StreamingBuffer(callbacks.onUpdate);
      }

      const result = await sbx.commands.run(executeCommand, {
        timeoutMs,
        background,
        onStdout: (data) => stdoutBuffer?.append(data),
        onStderr: (data) => stderrBuffer?.append(data),
      });

      // Flush any remaining buffered content
      stdoutBuffer?.flush();
      stderrBuffer?.flush();

      callbacks?.onUpdate?.(
        `{"type": "end", "sandbox_id": "${
          sbx.sandboxId
        }", "output": "${JSON.stringify(result)}"}`
      );


      return {
        sandboxId: sbx.sandboxId,
        ...result,
      };
    } catch (error) {
      console.error("Error executing command:", error);
      const errorMessage = `Failed to execute command: ${
        error instanceof Error ? error.message : String(error)
      }`;
      callbacks?.onError?.(errorMessage);
      throw new Error(errorMessage);
    }
  }

  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    _history?: Conversation[],
    callbacks?: StreamCallbacks,
    background?: boolean
  ): Promise<AgentResponse> {
    const commandConfig = this.getCommandConfig(prompt, mode);

    try {
      const sbx = await this.getSandbox();

      if (!this.config.sandboxId && sbx.sandboxId) {
        callbacks?.onUpdate?.(
          `{"type": "start", "sandbox_id": "${sbx.sandboxId}"}`
        );

        // Create working directory
        await sbx.commands.run(this.getMkdirCommand(this.WORKING_DIR), {
          timeoutMs: 30000,
          background: background || false,
        });

        // Only clone repository if GitHub config is provided
        if (this.config.githubToken && this.config.repoUrl) {
          callbacks?.onUpdate?.(
            `{"type": "git", "output": "Cloning repository: ${this.config.repoUrl}"}`
          );
          // Clone directly into the working directory, not into a subdirectory
          await sbx.commands.run(
            `cd ${this.WORKING_DIR} && git clone https://x-access-token:${this.config.githubToken}@github.com/${this.config.repoUrl}.git .`,
            { timeoutMs: 3600000, background: background || false }
          );

          await sbx.commands.run(
            `cd ${this.WORKING_DIR} && git config user.name "github-actions[bot]" && git config user.email "github-actions[bot]@users.noreply.github.com"`,
            { timeoutMs: 60000, background: background || false }
          );
        }
      } else if (this.config.sandboxId) {
        callbacks?.onUpdate?.(
          `{"type": "start", "sandbox_id": "${this.config.sandboxId}"}`
        );
      }

      // Switch to specified branch if provided and repository is available
      if (branch && this.config.repoUrl) {
        // Store the branch for later use
        this.currentBranch = branch;

        callbacks?.onUpdate?.(
          `{"type": "git", "output": "Switching to branch: ${branch}"}`
        );
        try {
          // Try to checkout existing branch first
          await sbx.commands.run(
            `cd ${this.WORKING_DIR} && git checkout ${branch}`,
            {
              timeoutMs: 60000,
              background: background || false,
            }
          );
          // Pull latest changes from the remote branch
          callbacks?.onUpdate?.(
            `{"type": "git", "output": "Pulling latest changes from ${branch}"}`
          );
          await sbx.commands.run(
            `cd ${this.WORKING_DIR} && git pull origin ${branch}`,
            {
              timeoutMs: 60000,
              background: background || false,
            }
          );
        } catch (error) {
          // If branch doesn't exist, create it
          callbacks?.onUpdate?.(
            `{"type": "git", "output": "Branch ${branch} not found, creating new branch"}`
          );
          await sbx.commands.run(
            `cd ${this.WORKING_DIR} && git checkout -b ${branch}`,
            {
              timeoutMs: 60000,
              background: background || false,
            }
          );
        }
      }

      // Always use working directory for all commands (repo is cloned directly into working directory)
      const executeCommand = `cd ${this.WORKING_DIR} && ${commandConfig.command}`;

      // Set up streaming buffers for stdout and stderr if callbacks are provided
      let stdoutBuffer: StreamingBuffer | undefined;
      let stderrBuffer: StreamingBuffer | undefined;

      if (callbacks?.onUpdate) {
        stdoutBuffer = new StreamingBuffer(callbacks.onUpdate);
        stderrBuffer = new StreamingBuffer(callbacks.onUpdate);
      }

      const result = await sbx.commands.run(executeCommand, {
        timeoutMs: 3600000,
        background: background || false,
        onStdout: (data) => stdoutBuffer?.append(data),
        onStderr: (data) => stderrBuffer?.append(data),
      });

      // Flush any remaining buffered content
      stdoutBuffer?.flush();
      stderrBuffer?.flush();

      callbacks?.onUpdate?.(
        `{"type": "end", "sandbox_id": "${
          sbx.sandboxId
        }", "output": "${JSON.stringify(result)}"}`
      );

      this.lastPrompt = prompt;


      return {
        sandboxId: sbx.sandboxId,
        ...result,
      };
    } catch (error) {
      console.error(`Error calling ${commandConfig.errorPrefix}:`, error);
      const errorMessage = `Failed to generate code: ${
        error instanceof Error ? error.message : String(error)
      }`;
      callbacks?.onError?.(errorMessage);
      throw new Error(errorMessage);
    }
  }

  public async pushToBranch(branch?: string): Promise<void> {
    const targetBranch = branch || this.currentBranch;

    if (!targetBranch) {
      throw new Error(
        "No branch specified. Either pass a branch name or call generateCode with a branch first."
      );
    }

    const sbx = await this.getSandbox();

    // Check git status for changes
    const gitStatus = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git status --porcelain`,
      { timeoutMs: 3600000 }
    );

    // Check for untracked files
    const untrackedFiles = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git ls-files --others --exclude-standard`,
      { timeoutMs: 3600000 }
    );

    // Check if there are any changes to commit
    if (!gitStatus?.stdout && !untrackedFiles?.stdout) {
      throw new Error("No changes found to commit and push");
    }

    // Switch to the specified branch (create if it doesn't exist)
    try {
      await sbx.commands.run(
        `cd ${this.WORKING_DIR} && git checkout ${targetBranch}`,
        {
          timeoutMs: 60000,
        }
      );
    } catch (error) {
      // If branch doesn't exist, create it
      await sbx.commands.run(
        `cd ${this.WORKING_DIR} && git checkout -b ${targetBranch}`,
        {
          timeoutMs: 60000,
        }
      );
    }

    const diffHead = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git --no-pager diff --no-color HEAD`,
      {
        timeoutMs: 3600000,
      }
    );

    const patch = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git --no-pager diff --no-color --diff-filter=ACMR`,
      { timeoutMs: 3600000 }
    );

    let patchContent = patch?.stdout || diffHead?.stdout || "";

    // Add all changes and commit
    const { commitMessage } = await generateCommitMessage(
      patchContent,
      this.getModelConfig(),
      this.lastPrompt || ""
    );

    await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git add -A && git commit -m "${commitMessage}"`,
      { timeoutMs: 3600000 }
    );

    // Push the branch to GitHub
    await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git push origin ${targetBranch}`,
      {
        timeoutMs: 3600000,
      }
    );
  }

  public async createPullRequest(
    labelOptions?: LabelOptions,
    branchPrefix?: string
  ): Promise<PullRequestResult> {
    const { githubToken, repoUrl } = this.config;

    if (!githubToken || !repoUrl) {
      throw new Error(
        "GitHub configuration is required for creating pull requests. Please provide githubToken and repoUrl in your configuration."
      );
    }

    const commandConfig = this.getCommandConfig("", "code");
    const sbx = await this.getSandbox();
    // Get the current branch (base branch) BEFORE creating a new branch
    const baseBranch = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git rev-parse --abbrev-ref HEAD`,
      { timeoutMs: 3600000 }
    );

    // Debug: Check git status first
    await sbx.commands.run(`cd ${this.WORKING_DIR} && git status --porcelain`, {
      timeoutMs: 3600000,
    });

    // Debug: Check for untracked files
    const untrackedFiles = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git ls-files --others --exclude-standard`,
      { timeoutMs: 3600000 }
    );

    const diffHead = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git --no-pager diff --no-color HEAD`,
      {
        timeoutMs: 3600000,
      }
    );

    const patch = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git --no-pager diff --no-color --diff-filter=ACMR`,
      { timeoutMs: 3600000 }
    );

    if (
      !patch ||
      (!patch.stdout && !diffHead?.stdout && !untrackedFiles?.stdout)
    ) {
      throw new Error(
        `No changes found - check if the agent actually modified any files`
      );
    }

    // Use the diff that has content, preferring the original patch format
    let patchContent = patch?.stdout || diffHead?.stdout || "";

    // If no diff but there are untracked files, we need to add them first
    if (!patchContent && untrackedFiles?.stdout) {
      await sbx.commands.run(`cd ${this.WORKING_DIR} && git add .`, {
        timeoutMs: 3600000,
      });

      const patchAfterAdd = await sbx.commands.run(
        `cd ${this.WORKING_DIR} && git --no-pager diff --no-color --cached`,
        { timeoutMs: 3600000 }
      );
      patchContent = patchAfterAdd?.stdout || "";
    }

    if (!patchContent) {
      throw new Error("No patch content found after checking all diff methods");
    }

    const { title, body, branchName, commitMessage } = await generatePRMetadata(
      patchContent,
      this.getModelConfig(),
      this.lastPrompt || ""
    );

    const _branchName = branchPrefix
      ? `${branchPrefix}/${branchName}`
      : branchName;

    // Escape any quotes in the commit message to prevent shell parsing issues
    const escapedCommitMessage = commitMessage.replace(/"/g, '\\"');

    const checkout = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git checkout -b ${_branchName} && git add -A && git commit -m "${escapedCommitMessage}"`,
      {
        timeoutMs: 3600000,
      }
    );

    // Push the branch to GitHub
    await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git push origin ${_branchName}`,
      {
        timeoutMs: 3600000,
      }
    );

    // Extract commit SHA from checkout output
    const commitMatch = checkout?.stdout.match(/\[[\w-]+ ([a-f0-9]+)\]/);
    const commitSha = commitMatch ? commitMatch[1] : undefined;

    // Create Pull Request using GitHub API
    const [owner, repo] = repoUrl?.split("/") || [];
    const prResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/pulls`,
      {
        method: "POST",
        headers: {
          Authorization: `token ${githubToken}`,
          Accept: "application/vnd.github.v3+json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          title,
          body,
          head: _branchName,
          base: baseBranch?.stdout.trim() || "main",
        }),
      }
    );

    if (!prResponse.ok) {
      const errorText = await prResponse.text();
      throw new Error(`Failed to create PR: ${prResponse.status} ${errorText}`);
    }

    const prData = await prResponse.json();

    // Handle label creation and assignment
    const labelConfig = labelOptions || {
      name: commandConfig.labelName,
      color: commandConfig.labelColor,
      description: commandConfig.labelDescription,
    };
    await this.handlePRLabeling(owner, repo, prData.number, labelConfig);

    return {
      id: prData.id,
      number: prData.number,
      state: prData.state,
      title: prData.title,
      body: prData.body,
      html_url: prData.html_url,
      head: prData.head,
      base: prData.base,
      user: prData.user,
      created_at: prData.created_at,
      updated_at: prData.updated_at,
      merged: prData.merged,
      mergeable: prData.mergeable,
      merge_commit_sha: prData.merge_commit_sha,
      branchName: _branchName,
      commitSha,
    };
  }

  public async runTests(
    branch?: string,
    history?: Conversation[],
    callbacks?: StreamCallbacks,
    background?: boolean
  ): Promise<AgentResponse> {
    return await this.generateCode(
      "Install dependencies and run tests",
      "code",
      branch,
      history,
      callbacks,
      background
    );
  }

  protected abstract getApiKey(): string;
  protected abstract getAgentType(): "codex" | "claude" | "opencode" | "gemini" | "grok";
  protected abstract getModelConfig(): ModelConfig;

  private async handlePRLabeling(
    owner: string,
    repo: string,
    prNumber: number,
    labelConfig: LabelOptions
  ) {
    const { githubToken } = this.config;
    const {
      name: labelName,
      color: labelColor,
      description: labelDescription,
    } = labelConfig;

    // Check if label exists first
    const labelCheckResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/labels/${labelName}`,
      {
        headers: {
          Authorization: `token ${githubToken}`,
          Accept: "application/vnd.github.v3+json",
        },
      }
    );

    // Only create label if it doesn't exist (404 status)
    if (!labelCheckResponse.ok && labelCheckResponse.status === 404) {
      const labelResponse = await fetch(
        `https://api.github.com/repos/${owner}/${repo}/labels`,
        {
          method: "POST",
          headers: {
            Authorization: `token ${githubToken}`,
            Accept: "application/vnd.github.v3+json",
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            name: labelName,
            color: labelColor,
            description: labelDescription,
          }),
        }
      );

      if (!labelResponse.ok) {
        const errorText = await labelResponse.text();
        console.error(
          `Failed to create label '${labelName}': ${labelResponse.status} ${errorText}`
        );
      }
    } else if (!labelCheckResponse.ok) {
      // Handle other errors (not 404)
      const errorText = await labelCheckResponse.text();
      console.error(
        `Failed to check if label '${labelName}' exists: ${labelCheckResponse.status} ${errorText}`
      );
    }

    // Add label to PR
    const addLabelResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/issues/${prNumber}/labels`,
      {
        method: "POST",
        headers: {
          Authorization: `token ${githubToken}`,
          Accept: "application/vnd.github.v3+json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify([labelName]),
      }
    );

    if (!addLabelResponse.ok) {
      const errorText = await addLabelResponse.text();
      console.error(
        `Failed to add label '${labelName}' to PR #${prNumber}: ${addLabelResponse.status} ${errorText}`
      );
    }
  }
}



================================================
FILE: packages/sdk/src/agents/claude.ts
================================================
import { BaseAgent, BaseAgentConfig, AgentCommandConfig } from "./base";
import { ModelConfig } from "./utils";
import {
  AgentType,
  ClaudeConfig,
  ClaudeResponse,
  ClaudeStreamCallbacks,
  Conversation,
  ModelProvider,
} from "../types";

export class ClaudeAgent extends BaseAgent {
  private anthropicApiKey?: string;
  private oauthToken?: string;
  private model?: string;
  private useOAuth: boolean;
  private tokenInitialized: boolean = false;

  private escapePrompt(prompt: string): string {
    // Comprehensive escaping for bash double quotes - production ready
    return prompt
      .replace(/\\/g, '\\\\')    // Escape backslashes FIRST
      .replace(/"/g, '\\"')      // Escape double quotes
      .replace(/'/g, "'\\''")    // Escape single quotes (close quote, escaped quote, reopen)
      .replace(/\$/g, '\\$')     // Escape dollar signs
      .replace(/`/g, '\\`')      // Escape backticks (command substitution)
      .replace(/!/g, '\\!')      // Escape exclamation (history expansion)
      .replace(/\n/g, '\\n')     // Escape newlines
      .replace(/\r/g, '\\r')     // Escape carriage returns
      .replace(/\t/g, '\\t');    // Escape tabs
  }

  constructor(config: ClaudeConfig) {
    const baseConfig: BaseAgentConfig = {
      githubToken: config.githubToken,
      repoUrl: config.repoUrl,
      sandboxProvider: config.sandboxProvider,
      secrets: config.secrets,
      sandboxId: config.sandboxId,
      workingDirectory: config.workingDirectory,
    };

    super(baseConfig);

    // Validate that provider is anthropic if specified (Claude only supports anthropic)
    if (config.provider && config.provider !== "anthropic") {
      throw new Error("Claude agent only supports 'anthropic' provider");
    }

    // Store config values
    const envOAuthToken = process.env.CLAUDE_CODE_OAUTH_TOKEN;
    this.oauthToken = config.oauthToken || envOAuthToken;
    this.anthropicApiKey = config.providerApiKey;
    this.model = config.model;
    
    // Perform a preliminary check to set useOAuth based on the presence of oauthToken and absence of anthropicApiKey.
    // The final determination of the authentication method is made in initializeToken().
    this.useOAuth = !!(this.oauthToken && !this.anthropicApiKey);
  }
  
  private async initializeToken(): Promise<void> {
    if (this.tokenInitialized) return;
    
    // No automatic OAuth token loading - users must provide tokens themselves
    
    // Determine which auth method to use
    this._determineAuthMethod();
  }

  /**
   * Determines the authentication method to use (OAuth or API key).
   * Sets the `useOAuth` flag based on the available credentials.
   */
  private _determineAuthMethod(): void {
    if (this.oauthToken) {
      this.useOAuth = true;
    } else if (this.anthropicApiKey) {
      this.useOAuth = false;
    } else {
      throw new Error(
        "Claude agent requires either providerApiKey or oauthToken. Run 'vibekit auth claude' to authenticate."
      );
    }
    
    // Validate that at least one auth method is provided
    if (!this.anthropicApiKey && !this.oauthToken) {
      throw new Error(
        "Claude agent requires either providerApiKey or oauthToken. Run 'vibekit auth claude' to authenticate."
      );
    }
    
    this.tokenInitialized = true;
  }

  protected getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }
    
    // Add Claude Code system prompt when using OAuth
    if (this.useOAuth) {
      instruction = "You are Claude Code, Anthropic's official CLI for Claude. " + instruction;
    }

    const escapedPrompt = this.escapePrompt(prompt);

    return {
      command: `echo "${escapedPrompt}" | claude -p --append-system-prompt "${this.escapePrompt(instruction)}"${
        mode === "ask" ? ' --disallowedTools "Edit" "Replace" "Write"' : ""
      } --output-format stream-json --verbose --model ${
        this.model || "claude-sonnet-4-20250514"
      }`,
      errorPrefix: "Claude",
      labelName: "claude",
      labelColor: "FF6B35",
      labelDescription: "Generated by Claude AI agent",
    };
  }

  protected getDefaultTemplate(): string {
    return "vibekit-claude";
  }

  protected getEnvironmentVariables(): Record<string, string> {
    const envVars: Record<string, string> = {};
    
    if (this.useOAuth) {
      // For OAuth, pass the token as CLAUDE_CODE_OAUTH_TOKEN
      envVars.CLAUDE_CODE_OAUTH_TOKEN = this.oauthToken!;
    } else {
      // For API key authentication
      envVars.ANTHROPIC_API_KEY = this.anthropicApiKey!;
    }
    
    return envVars;
  }

  protected getApiKey(): string {
    // Return OAuth token if using OAuth, otherwise API key
    return this.useOAuth ? this.oauthToken! : this.anthropicApiKey!;
  }

  protected getAgentType(): AgentType {
    return "claude";
  }

  protected getModelConfig(): ModelConfig {
    return {
      provider: "anthropic",
      apiKey: this.useOAuth ? this.oauthToken! : this.anthropicApiKey!,
      model: this.model,
    };
  }

  // Override generateCode to support history in the instruction
  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    history?: Conversation[],
    callbacks?: ClaudeStreamCallbacks,
    background?: boolean
  ): Promise<ClaudeResponse> {
    // Ensure token is initialized
    await this.initializeToken();
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    if (history && history.length > 0) {
      instruction += `\n\nConversation history: ${history
        .map((h) => `${h.role}\n ${this.escapePrompt(h.content)}`)  // Escape history content too!
        .join("\n\n")}`;
    }
    
    // Add Claude Code system prompt when using OAuth
    if (this.useOAuth) {
      instruction = "You are Claude Code, Anthropic's official CLI for Claude. " + instruction;
    }

    const escapedPrompt = this.escapePrompt(prompt);

    // Override the command config with history-aware instruction
    const originalGetCommandConfig = this.getCommandConfig.bind(this);
    this.getCommandConfig = (p: string, m?: "ask" | "code") => ({
      ...originalGetCommandConfig(p, m),
      command: `echo "${escapedPrompt}" | claude -p --append-system-prompt "${this.escapePrompt(instruction)}"${
        mode === "ask" ? ' --disallowedTools "Edit" "Replace" "Write"' : ""
      } --output-format stream-json --verbose --allowedTools "Edit,Write,MultiEdit,Read,Bash" --model ${
        this.model || "claude-sonnet-4-20250514"
      }`,
    });

    const result = await super.generateCode(
      prompt,
      mode,
      branch,
      history,
      callbacks,
      background
    );

    // Restore original method
    this.getCommandConfig = originalGetCommandConfig;

    return result as ClaudeResponse;
  }
}



================================================
FILE: packages/sdk/src/agents/codex.ts
================================================
import { BaseAgent, BaseAgentConfig, AgentCommandConfig } from "./base";
import { ModelConfig } from "./utils";
import {
  AgentType,
  CodexConfig,
  CodexResponse,
  CodexStreamCallbacks,
  Conversation,
  ModelProvider,
} from "../types";

export class CodexAgent extends BaseAgent {
  private providerApiKey: string;
  private provider: ModelProvider;
  private model?: string;

  private escapePrompt(prompt: string): string {
    // Comprehensive escaping for bash double quotes - production ready
    return prompt
      .replace(/\\/g, '\\\\')    // Escape backslashes FIRST
      .replace(/"/g, '\\"')      // Escape double quotes
      .replace(/'/g, "'\\''")    // Escape single quotes (close quote, escaped quote, reopen)
      .replace(/\$/g, '\\$')     // Escape dollar signs
      .replace(/`/g, '\\`')      // Escape backticks (command substitution)
      .replace(/!/g, '\\!')      // Escape exclamation (history expansion)
      .replace(/\n/g, '\\n')     // Escape newlines
      .replace(/\r/g, '\\r')     // Escape carriage returns
      .replace(/\t/g, '\\t');    // Escape tabs
  }

  constructor(config: CodexConfig) {
    const baseConfig: BaseAgentConfig = {
      githubToken: config.githubToken,
      repoUrl: config.repoUrl,
      sandboxProvider: config.sandboxProvider,
      secrets: config.secrets,
      sandboxId: config.sandboxId,
      workingDirectory: config.workingDirectory,
    };

    super(baseConfig);

    // Support new providerApiKey field with fallback to deprecated fields for backward compatibility
    this.providerApiKey = config.providerApiKey || "";
    this.provider = config.provider || "openai";
    this.model = config.model;

    if (!this.providerApiKey) {
      throw new Error(
        "Provider API key is required. Please provide providerApiKey, apiKey, or openaiApiKey."
      );
    }
  }

  protected getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    return {
      command: `codex exec --full-auto --skip-git-repo-check${
        this.model ? ` --model ${this.model}` : ""
      } "${this.escapePrompt(_prompt)}"`,
      errorPrefix: "Codex",
      labelName: "codex",
      labelColor: "ededed",
      labelDescription: "Pull requests generated by Codex agent",
    };
  }

  protected getDefaultTemplate(): string {
    return "vibekit-codex";
  }

  protected getEnvironmentVariables(): Record<string, string> {
    const envKey = `${this.provider.toUpperCase()}_API_KEY`;
    return {
      [envKey]: this.providerApiKey,
    };
  }

  protected getApiKey(): string {
    return this.providerApiKey;
  }

  protected getAgentType(): AgentType {
    return "codex";
  }

  protected getModelConfig(): ModelConfig {
    return {
      provider: this.provider,
      apiKey: this.providerApiKey,
      model: this.model,
    };
  }

  // Override generateCode to support history in the prompt
  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    history?: Conversation[],
    callbacks?: CodexStreamCallbacks,
    background?: boolean
  ): Promise<CodexResponse> {
    let instruction: string;

    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    if (history) {
      _prompt += `\n\nConversation history: ${history
        .map((h) => `${h.role}\n ${this.escapePrompt(h.content)}`)
        .join("\n\n")}`;
    }
    // Override the command config with history-aware prompt
    const originalGetCommandConfig = this.getCommandConfig.bind(this);
    this.getCommandConfig = (p: string, m?: "ask" | "code") => ({
      ...originalGetCommandConfig(p, m),
      command: `codex exec --full-auto --skip-git-repo-check${
        this.model ? ` --model ${this.model}` : ""
      } "${this.escapePrompt(_prompt)}"`,
    });

    const result = await super.generateCode(
      prompt,
      mode,
      branch,
      history,
      callbacks,
      background
    );

    // Restore original method
    this.getCommandConfig = originalGetCommandConfig;

    return result as CodexResponse;
  }
}



================================================
FILE: packages/sdk/src/agents/gemini.ts
================================================
import { BaseAgent, BaseAgentConfig, AgentCommandConfig } from "./base";
import { ModelConfig } from "./utils";
import {
  GeminiConfig,
  GeminiResponse,
  GeminiStreamCallbacks,
  Conversation,
  ModelProvider,
  AgentType,
} from "../types";

export class GeminiAgent extends BaseAgent {
  private geminiApiKey: string;
  private model?: string;

  private escapePrompt(prompt: string): string {
    // Comprehensive escaping for bash double quotes - production ready
    return prompt
      .replace(/\\/g, '\\\\')    // Escape backslashes FIRST
      .replace(/"/g, '\\"')      // Escape double quotes
      .replace(/'/g, "'\\''")    // Escape single quotes (close quote, escaped quote, reopen)
      .replace(/\$/g, '\\$')     // Escape dollar signs
      .replace(/`/g, '\\`')      // Escape backticks (command substitution)
      .replace(/!/g, '\\!')      // Escape exclamation (history expansion)
      .replace(/\n/g, '\\n')     // Escape newlines
      .replace(/\r/g, '\\r')     // Escape carriage returns
      .replace(/\t/g, '\\t');    // Escape tabs
  }

  constructor(config: GeminiConfig) {
    const baseConfig: BaseAgentConfig = {
      githubToken: config.githubToken,
      repoUrl: config.repoUrl,
      sandboxProvider: config.sandboxProvider,
      secrets: config.secrets,
      sandboxId: config.sandboxId,
      workingDirectory: config.workingDirectory,
    };

    super(baseConfig);

    // Validate that provider is gemini or google if specified
    if (config.provider && !["gemini", "google"].includes(config.provider)) {
      throw new Error(
        "Gemini agent only supports 'gemini' or 'google' provider"
      );
    }

    this.geminiApiKey = config.providerApiKey || "";
    this.model = config.model;
  }

  protected getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    return {
      command: `echo "${this.escapePrompt(_prompt)}" | gemini --model ${
        this.model || "gemini-2.5-pro"
      } --yolo`,
      errorPrefix: "Gemini",
      labelName: "gemini",
      labelColor: "4285F4",
      labelDescription: "Generated by Gemini AI agent",
    };
  }

  protected getDefaultTemplate(): string {
    return "vibekit-gemini";
  }

  protected getEnvironmentVariables(): Record<string, string> {
    return {
      GEMINI_API_KEY: this.geminiApiKey,
      GOOGLE_API_KEY: this.geminiApiKey, // Some tools might expect this name
    };
  }

  protected getApiKey(): string {
    return this.geminiApiKey;
  }

  protected getAgentType(): AgentType {
    return "gemini";
  }

  protected getModelConfig(): ModelConfig {
    return {
      provider: "gemini",
      apiKey: this.geminiApiKey,
      model: this.model,
    };
  }

  // Override generateCode to support history in the instruction
  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    history?: Conversation[],
    callbacks?: GeminiStreamCallbacks,
    background?: boolean
  ): Promise<GeminiResponse> {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    if (history && history.length > 0) {
      instruction += `\n\nConversation history: ${history
        .map((h) => `${h.role}\n ${this.escapePrompt(h.content)}`)  // Escape history content too!
        .join("\n\n")}`;
    }

    const escapedPrompt = this.escapePrompt(prompt);

    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    // Override the command config with history-aware instruction
    const originalGetCommandConfig = this.getCommandConfig.bind(this);
    this.getCommandConfig = (p: string, m?: "ask" | "code") => ({
      ...originalGetCommandConfig(p, m),
      command: `echo "${this.escapePrompt(_prompt)}" | gemini --model ${
        this.model || "gemini-2.5-pro"
      } --yolo`,
    });

    const result = await super.generateCode(
      prompt,
      mode,
      branch,
      history,
      callbacks,
      background
    );

    // Restore original method
    this.getCommandConfig = originalGetCommandConfig;

    return result as GeminiResponse;
  }
}



================================================
FILE: packages/sdk/src/agents/grok.ts
================================================
import { BaseAgent, BaseAgentConfig, AgentCommandConfig } from "./base";
import { ModelConfig } from "./utils";
import {
  AgentType,
  GrokConfig,
  GrokResponse,
  GrokStreamCallbacks,
  Conversation,
  ModelProvider,
} from "../types";

export class GrokAgent extends BaseAgent {
  private grokApiKey: string;
  private model?: string;
  private baseUrl?: string;

  private escapePrompt(prompt: string): string {
    // Comprehensive escaping for bash double quotes - production ready
    return prompt
      .replace(/\\/g, '\\\\')    // Escape backslashes FIRST
      .replace(/"/g, '\\"')      // Escape double quotes
      .replace(/'/g, "'\\''")    // Escape single quotes (close quote, escaped quote, reopen)
      .replace(/\$/g, '\\$')     // Escape dollar signs
      .replace(/`/g, '\\`')      // Escape backticks (command substitution)
      .replace(/!/g, '\\!')      // Escape exclamation (history expansion)
      .replace(/\n/g, '\\n')     // Escape newlines
      .replace(/\r/g, '\\r')     // Escape carriage returns
      .replace(/\t/g, '\\t');    // Escape tabs
  }

  constructor(config: GrokConfig) {
    const baseConfig: BaseAgentConfig = {
      githubToken: config.githubToken,
      repoUrl: config.repoUrl,
      sandboxProvider: config.sandboxProvider,
      secrets: config.secrets,
      sandboxId: config.sandboxId,
      workingDirectory: config.workingDirectory,
    };

    super(baseConfig);

    // Validate that provider is xai if specified (Grok only supports xai)
    if (config.provider && config.provider !== "xai") {
      throw new Error("Grok agent only supports 'xai' provider");
    }

    // Store config values
    const envApiKey = process.env.GROK_API_KEY || process.env.XAI_API_KEY;
    const apiKey = config.providerApiKey || envApiKey;
    
    if (!apiKey) {
      throw new Error(
        "Grok agent requires providerApiKey or GROK_API_KEY environment variable"
      );
    }
    
    this.grokApiKey = apiKey;
    this.model = config.model;
    this.baseUrl = config.baseUrl;
  }

  protected getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    const modelFlag = this.model ? `--model ${this.model}` : "";
    const baseUrlFlag = this.baseUrl ? `--base-url ${this.baseUrl}` : "";

    return {
      command: `echo "${escapedPrompt}" | grok ${modelFlag} ${baseUrlFlag} --prompt "${this.escapePrompt(instruction)}"`,
      errorPrefix: "Grok",
      labelName: "grok",
      labelColor: "00D4AA",
      labelDescription: "Generated by Grok AI agent",
    };
  }

  protected getDefaultTemplate(): string {
    return "vibekit-grok";
  }

  protected getEnvironmentVariables(): Record<string, string> {
    const envVars: Record<string, string> = {
      GROK_API_KEY: this.grokApiKey,
    };

    if (this.baseUrl) {
      envVars.GROK_BASE_URL = this.baseUrl;
    }

    return envVars;
  }

  protected getApiKey(): string {
    return this.grokApiKey;
  }

  protected getAgentType(): AgentType {
    return "grok";
  }

  protected getModelConfig(): ModelConfig {
    return {
      provider: "xai",
      apiKey: this.grokApiKey,
      model: this.model,
      baseUrl: this.baseUrl,
    };
  }

  // Override generateCode to support history in the instruction
  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    history?: Conversation[],
    callbacks?: GrokStreamCallbacks,
    background?: boolean
  ): Promise<GrokResponse> {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    if (history && history.length > 0) {
      instruction += `\n\nConversation history: ${history
        .map((h) => `${h.role}\n ${this.escapePrompt(h.content)}`)
        .join("\n\n")}`;
    }

    const escapedPrompt = this.escapePrompt(prompt);
    const modelFlag = this.model ? `--model ${this.model}` : "";
    const baseUrlFlag = this.baseUrl ? `--base-url ${this.baseUrl}` : "";

    // Override the command config with history-aware instruction
    const originalGetCommandConfig = this.getCommandConfig.bind(this);
    this.getCommandConfig = (p: string, m?: "ask" | "code") => ({
      ...originalGetCommandConfig(p, m),
      command: `echo "${escapedPrompt}" | grok ${modelFlag} ${baseUrlFlag} --prompt "${this.escapePrompt(instruction)}"`,
    });

    const result = await super.generateCode(
      prompt,
      mode,
      branch,
      history,
      callbacks,
      background
    );

    // Restore original method
    this.getCommandConfig = originalGetCommandConfig;

    return result as GrokResponse;
  }
}


================================================
FILE: packages/sdk/src/agents/opencode.ts
================================================
import { BaseAgent, BaseAgentConfig, AgentCommandConfig } from "./base";
import { ModelConfig } from "./utils";
import {
  OpenCodeConfig,
  OpenCodeResponse,
  OpenCodeStreamCallbacks,
  Conversation,
  ModelProvider,
  AgentType,
} from "../types";

export class OpenCodeAgent extends BaseAgent {
  private providerApiKey: string;
  private provider: ModelProvider;
  private model?: string;

  private escapePrompt(prompt: string): string {
    // Comprehensive escaping for bash double quotes - production ready
    return prompt
      .replace(/\\/g, '\\\\')    // Escape backslashes FIRST
      .replace(/"/g, '\\"')      // Escape double quotes
      .replace(/'/g, "'\\''")    // Escape single quotes (close quote, escaped quote, reopen)
      .replace(/\$/g, '\\$')     // Escape dollar signs
      .replace(/`/g, '\\`')      // Escape backticks (command substitution)
      .replace(/!/g, '\\!')      // Escape exclamation (history expansion)
      .replace(/\n/g, '\\n')     // Escape newlines
      .replace(/\r/g, '\\r')     // Escape carriage returns
      .replace(/\t/g, '\\t');    // Escape tabs
  }

  constructor(config: OpenCodeConfig) {
    const baseConfig: BaseAgentConfig = {
      githubToken: config.githubToken,
      repoUrl: config.repoUrl,
      sandboxProvider: config.sandboxProvider,
      secrets: config.secrets,
      sandboxId: config.sandboxId,
      workingDirectory: config.workingDirectory,
    };

    super(baseConfig);

    // Support providerApiKey field
    this.providerApiKey = config.providerApiKey || "";
    this.provider = config.provider || "openai";
    this.model = config.model;

    if (!this.providerApiKey) {
      throw new Error(
        "Provider API key is required. Please provide providerApiKey."
      );
    }
  }

  protected getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    return {
      command: `echo "${this.escapePrompt(_prompt)}" | opencode run${
        this.model ? ` --model ${this.provider}/${this.model} --print-logs` : ""
      }`,
      errorPrefix: "OpenCode",
      labelName: "opencode",
      labelColor: "00D2FF",
      labelDescription: "Pull requests generated by OpenCode agent",
    };
  }

  protected getDefaultTemplate(): string {
    return "vibekit-opencode";
  }

  protected getEnvironmentVariables(): Record<string, string> {
    const envKey = `${this.provider.toUpperCase()}_API_KEY`;
    return {
      [envKey]: this.providerApiKey,
    };
  }

  protected getApiKey(): string {
    return this.providerApiKey;
  }

  protected getAgentType(): AgentType {
    return "opencode";
  }

  protected getModelConfig(): ModelConfig {
    return {
      provider: this.provider,
      apiKey: this.providerApiKey,
      model: this.model,
    };
  }

  // Override generateCode to support history in the prompt
  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    history?: Conversation[],
    callbacks?: OpenCodeStreamCallbacks,
    background?: boolean
  ): Promise<OpenCodeResponse> {
    let instruction: string;

    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    if (history) {
      _prompt += `\n\nConversation history: ${history
        .map((h) => `${h.role}\n ${this.escapePrompt(h.content)}`)
        .join("\n\n")}`;
    }

    // Override the command config with history-aware prompt
    const originalGetCommandConfig = this.getCommandConfig.bind(this);
    this.getCommandConfig = (p: string, m?: "ask" | "code") => ({
      ...originalGetCommandConfig(p, m),
      command: `echo "${this.escapePrompt(_prompt)}" | opencode run${
        this.model ? ` --model ${this.provider}/${this.model} --print-logs` : ""
      }`,
    });

    const result = await super.generateCode(
      prompt,
      mode,
      branch,
      history,
      callbacks,
      background
    );

    // Restore original method
    this.getCommandConfig = originalGetCommandConfig;

    return result as OpenCodeResponse;
  }
}



================================================
FILE: packages/sdk/src/agents/utils.ts
================================================
import { z } from "zod";
import { ModelProvider } from "../types";

export interface ModelConfig {
  provider: ModelProvider;
  apiKey: string;
  model?: string;
  baseUrl?: string; // for custom providers like OpenAI compatible
}

async function createProvider(config: ModelConfig) {
  switch (config.provider) {
    case "anthropic": {
      const { createAnthropic } = await import("@ai-sdk/anthropic");
      return createAnthropic({ apiKey: config.apiKey });
    }
    case "openai": {
      const { openai } = await import("@ai-sdk/openai");
      return openai.responses;
    }
    case "openrouter": {
      const { createOpenAICompatible } = await import(
        "@ai-sdk/openai-compatible"
      );
      return createOpenAICompatible({
        name: "openrouter",
        apiKey: config.apiKey,
        baseURL: "https://openrouter.ai/api/v1",
      });
    }
    case "azure": {
      if (!config.baseUrl) {
        throw new Error("baseUrl is required for Azure provider");
      }
      const { createOpenAICompatible } = await import(
        "@ai-sdk/openai-compatible"
      );
      return createOpenAICompatible({
        name: "azure",
        apiKey: config.apiKey,
        baseURL: config.baseUrl,
      });
    }
    case "gemini": {
      const { createOpenAICompatible } = await import(
        "@ai-sdk/openai-compatible"
      );
      return createOpenAICompatible({
        name: "gemini",
        apiKey: config.apiKey,
        baseURL: "https://generativelanguage.googleapis.com/v1beta/openai/",
      });
    }
    case "ollama": {
      const { createOpenAICompatible } = await import(
        "@ai-sdk/openai-compatible"
      );
      return createOpenAICompatible({
        name: "ollama",
        apiKey: config.apiKey || "ollama", // Ollama often doesn't require a real key
        baseURL: config.baseUrl || "http://localhost:11434/v1",
      });
    }
    case "mistral": {
      const { createOpenAICompatible } = await import(
        "@ai-sdk/openai-compatible"
      );
      return createOpenAICompatible({
        name: "mistral",
        apiKey: config.apiKey,
        baseURL: "https://api.mistral.ai/v1",
      });
    }
    case "deepseek": {
      const { createOpenAICompatible } = await import(
        "@ai-sdk/openai-compatible"
      );
      return createOpenAICompatible({
        name: "deepseek",
        apiKey: config.apiKey,
        baseURL: "https://api.deepseek.com/v1",
      });
    }
    case "xai": {
      const { createOpenAICompatible } = await import(
        "@ai-sdk/openai-compatible"
      );
      return createOpenAICompatible({
        name: "xai",
        apiKey: config.apiKey,
        baseURL: "https://api.x.ai/v1",
      });
    }
    case "groq": {
      const { createOpenAICompatible } = await import(
        "@ai-sdk/openai-compatible"
      );
      return createOpenAICompatible({
        name: "groq",
        apiKey: config.apiKey,
        baseURL: "https://api.groq.com/openai/v1",
      });
    }
    case "arceeai": {
      const { createOpenAICompatible } = await import(
        "@ai-sdk/openai-compatible"
      );
      return createOpenAICompatible({
        name: "arceeai",
        apiKey: config.apiKey,
        baseURL: "https://api.arcee.ai/v1",
      });
    }
    default:
      throw new Error(`Unsupported provider: ${config.provider}`);
  }
}

function getDefaultModel(provider: ModelProvider): string {
  switch (provider) {
    case "anthropic":
      return "claude-3-5-sonnet-20240620";
    case "openai":
      return "gpt-5";
    case "openrouter":
      return "anthropic/claude-3.5-sonnet";
    case "azure":
      return "gpt-4"; // This would typically be the deployment name
    case "gemini":
      return "gemini-1.5-pro";
    case "google":
      return "gemini-1.5-pro";
    case "ollama":
      return "llama3.1";
    case "mistral":
      return "mistral-large-latest";
    case "deepseek":
      return "deepseek-chat";
    case "xai":
      return "grok-beta";
    case "groq":
      return "llama-3.1-70b-versatile";
    case "arceeai":
      return "arcee-lite";
    default:
      return "gpt-4o-mini";
  }
}

export async function generatePRMetadata(
  patch: string,
  modelConfig: ModelConfig,
  prompt: string
) {
  const _prompt = `You are tasked to create title and body for a pull request based on the following task:\n${prompt}\n\npatch:\n\n${patch}`;
  const provider = await createProvider(modelConfig);
  const model = getDefaultModel(modelConfig.provider);

  const { generateObject } = await import("ai");
  const { object } = await generateObject({
    model: provider(model),
    prompt: _prompt,
    schema: z.object({
      title: z.string().describe("Suggested title for the pull request"),
      body: z.string().describe("Suggested body for the pull request"),
      branchName: z
        .string()
        .describe(`Suggested branch name, should be unique and descriptive`),
      commitMessage: z
        .string()
        .describe("Suggested commit message for the pull request"),
    }),
  });

  return object;
}

export async function generateCommitMessage(
  patch: string,
  modelConfig: ModelConfig,
  prompt: string
) {
  const _prompt = `You are tasked to create a commit message based on the following task:\n${prompt}\n\npatch:\n\n${patch}`;
  const provider = await createProvider(modelConfig);
  const model = modelConfig.model || getDefaultModel(modelConfig.provider);

  const { generateObject } = await import("ai");
  const { object } = await generateObject({
    model: provider(model),
    prompt: _prompt,
    schema: z.object({
      commitMessage: z
        .string()
        .describe("Suggested commit message for the changes"),
    }),
  });

  return object;
}



================================================
FILE: packages/sdk/src/constants/agents.ts
================================================
// Agent type constants
export const AGENT_TYPES = {
  CLAUDE: 'claude',
  CODEX: 'codex', 
  GEMINI: 'gemini',
  GROK: 'grok',
  OPENCODE: 'opencode',
} as const;

export type AgentType = typeof AGENT_TYPES[keyof typeof AGENT_TYPES];

// Agent list for iteration
export const AGENT_LIST: AgentType[] = [
  AGENT_TYPES.CLAUDE,
  AGENT_TYPES.CODEX,
  AGENT_TYPES.GEMINI,
  AGENT_TYPES.GROK,
  AGENT_TYPES.OPENCODE,
];

// Agent configurations with display names and descriptions
export const AGENT_TEMPLATES = [
  {
    name: AGENT_TYPES.CLAUDE,
    display: "Claude",
    message: "Claude - Anthropic's Claude Code agent",
  },
  {
    name: AGENT_TYPES.CODEX,
    display: "Codex",
    message: "Codex - OpenAI's Codex agent",
  },
  {
    name: AGENT_TYPES.GEMINI,
    display: "Gemini",
    message: "Gemini - Google's Gemini CLI agent",
  },
  {
    name: AGENT_TYPES.GROK,
    display: "Grok",
    message: "Grok - xAI's Grok agent",
  },
  {
    name: AGENT_TYPES.OPENCODE,
    display: "OpenCode",
    message: "OpenCode - Open source coding agent",
  },
];

// Agent display names mapping
export const AGENT_DISPLAY_NAMES: Record<AgentType, string> = {
  [AGENT_TYPES.CLAUDE]: 'Claude',
  [AGENT_TYPES.CODEX]: 'Codex',
  [AGENT_TYPES.GEMINI]: 'Gemini',
  [AGENT_TYPES.GROK]: 'Grok',
  [AGENT_TYPES.OPENCODE]: 'OpenCode',
};

// Agent descriptions mapping
export const AGENT_DESCRIPTIONS: Record<AgentType, string> = {
  [AGENT_TYPES.CLAUDE]: "Anthropic's Claude Code agent",
  [AGENT_TYPES.CODEX]: "OpenAI's Codex agent",
  [AGENT_TYPES.GEMINI]: "Google's Gemini CLI agent",
  [AGENT_TYPES.GROK]: "xAI's Grok agent",
  [AGENT_TYPES.OPENCODE]: "Open source coding agent",
};

// Agent provider mapping
export const AGENT_PROVIDERS: Record<AgentType, string> = {
  [AGENT_TYPES.CLAUDE]: 'anthropic',
  [AGENT_TYPES.CODEX]: 'openai',
  [AGENT_TYPES.GEMINI]: 'google',
  [AGENT_TYPES.GROK]: 'xai',
  [AGENT_TYPES.OPENCODE]: 'opensource',
};

// Agent capabilities
export const AGENT_CAPABILITIES: Record<AgentType, string[]> = {
  [AGENT_TYPES.CLAUDE]: ['code', 'chat', 'analysis', 'documentation'],
  [AGENT_TYPES.CODEX]: ['code', 'completion', 'refactoring'],
  [AGENT_TYPES.GEMINI]: ['code', 'chat', 'multimodal'],
  [AGENT_TYPES.GROK]: ['code', 'chat', 'analysis'],
  [AGENT_TYPES.OPENCODE]: ['code', 'open-source', 'customizable'],
};


================================================
FILE: packages/sdk/src/constants/index.ts
================================================
export * from './agents';
export * from './providers';


================================================
FILE: packages/sdk/src/constants/providers.ts
================================================
// Provider enums
export enum SANDBOX_PROVIDERS {
  CLOUDFLARE = "Cloudflare",
  DAGGER = "Dagger",
  DAYTONA = "Daytona",
  E2B = "E2B",
  NORTHFLANK = "Northflank",
}

// Provider type constants
export const PROVIDER_TYPES = {
  CLOUDFLARE: 'cloudflare',
  DAGGER: 'dagger',
  DAYTONA: 'daytona',
  E2B: 'e2b',
  NORTHFLANK: 'northflank',
} as const;

export type ProviderType = typeof PROVIDER_TYPES[keyof typeof PROVIDER_TYPES];

// Provider configurations with display names and descriptions
export const PROVIDER_TEMPLATES = [
  {
    name: PROVIDER_TYPES.CLOUDFLARE,
    display: "Cloudflare",
    message: "Cloudflare - Edge computing and serverless platform",
  },
  {
    name: PROVIDER_TYPES.DAGGER,
    display: "Dagger",
    message: "Dagger - Container-based CI/CD platform",
  },
  {
    name: PROVIDER_TYPES.DAYTONA,
    display: "Daytona",
    message: "Daytona - Development environment orchestration platform",
  },
  {
    name: PROVIDER_TYPES.E2B,
    display: "E2B",
    message: "E2B - Cloud development sandbox platform",
  },
  {
    name: PROVIDER_TYPES.NORTHFLANK,
    display: "Northflank",
    message: "Northflank - Cloud deployment and infrastructure platform",
  },
];

// Provider display names mapping
export const PROVIDER_DISPLAY_NAMES: Record<ProviderType, string> = {
  [PROVIDER_TYPES.CLOUDFLARE]: 'Cloudflare',
  [PROVIDER_TYPES.DAGGER]: 'Dagger',
  [PROVIDER_TYPES.DAYTONA]: 'Daytona',
  [PROVIDER_TYPES.E2B]: 'E2B',
  [PROVIDER_TYPES.NORTHFLANK]: 'Northflank',
};

// Provider descriptions mapping
export const PROVIDER_DESCRIPTIONS: Record<ProviderType, string> = {
  [PROVIDER_TYPES.CLOUDFLARE]: "Edge computing and serverless platform",
  [PROVIDER_TYPES.DAGGER]: "Container-based CI/CD platform",
  [PROVIDER_TYPES.DAYTONA]: "Development environment orchestration platform",
  [PROVIDER_TYPES.E2B]: "Cloud development sandbox platform",
  [PROVIDER_TYPES.NORTHFLANK]: "Cloud deployment and infrastructure platform",
};


================================================
FILE: packages/sdk/src/core/vibekit.ts
================================================
import { EventEmitter } from "events";
import type {
  AgentType,
  AgentMode,
  ModelProvider,
  SandboxProvider,
  Conversation,
  LabelOptions,
} from "../types";
import { AGENT_TYPES } from "../constants/agents";
import { AgentResponse, ExecuteCommandOptions, PullRequestResult } from "../agents/base";

export interface VibeKitEvents {
  stdout: (chunk: string) => void;
  stderr: (chunk: string) => void;
  update: (message: string) => void;
  error: (error: string) => void;
}

export interface VibeKitOptions {
  agent: {
    type: AgentType;
    provider?: ModelProvider;
    apiKey?: string; // Optional - can use OAuth token instead
    oauthToken?: string; // OAuth token for Claude
    model?: string;
  };
  sandbox?: SandboxProvider;
  github?: {
    token: string;
    repository: string;
  };
  workingDirectory?: string;
  secrets?: Record<string, string>;
  sandboxId?: string;
}

export class VibeKit extends EventEmitter {
  private options: Partial<VibeKitOptions> = {};
  private agent?: any;

  constructor() {
    super();
  }

  withAgent(config: {
    type: AgentType;
    provider: ModelProvider;
    apiKey?: string; // Optional - can use OAuth token instead
    oauthToken?: string; // OAuth token for Claude
    model: string;
  }): this {
    this.options.agent = config;
    return this;
  }

  withSandbox(provider: SandboxProvider): this {
    this.options.sandbox = provider;
    return this;
  }

  withGithub(config: { token: string; repository: string }): this {
    this.options.github = config;
    return this;
  }


  withWorkingDirectory(path: string): this {
    this.options.workingDirectory = path;
    return this;
  }

  withSecrets(secrets: Record<string, string>): this {
    this.options.secrets = secrets;
    return this;
  }

  withSession(sandboxId: string): this {
    this.options.sandboxId = sandboxId;
    return this;
  }

  private async initializeAgent(): Promise<void> {
    if (!this.options.agent) {
      throw new Error("Agent configuration is required");
    }

    const { type, provider, apiKey, oauthToken, model } = this.options.agent;

    // Dynamic imports for different agents
    let AgentClass;
    switch (type) {
      case AGENT_TYPES.CLAUDE:
        const { ClaudeAgent } = await import("../agents/claude");
        AgentClass = ClaudeAgent;
        break;
      case AGENT_TYPES.CODEX:
        const { CodexAgent } = await import("../agents/codex");
        AgentClass = CodexAgent;
        break;
      case AGENT_TYPES.OPENCODE:
        const { OpenCodeAgent } = await import("../agents/opencode");
        AgentClass = OpenCodeAgent;
        break;
      case AGENT_TYPES.GEMINI:
        const { GeminiAgent } = await import("../agents/gemini");
        AgentClass = GeminiAgent;
        break;
      case AGENT_TYPES.GROK:
        const { GrokAgent } = await import("../agents/grok");
        AgentClass = GrokAgent;
        break;
      default:
        throw new Error(`Unsupported agent type: ${type}`);
    }

    // Check if sandbox provider is configured
    if (!this.options.sandbox) {
      throw new Error(
        "Sandbox provider is required. Use withSandbox() to configure a provider."
      );
    }

    // Initialize agent with configuration
    const agentConfig = {
      providerApiKey: apiKey,
      oauthToken: oauthToken,
      provider,
      model,
      githubToken: this.options.github?.token,
      repoUrl: this.options.github?.repository,
      sandboxProvider: this.options.sandbox,
      secrets: this.options.secrets,
      workingDirectory: this.options.workingDirectory,
      sandboxId: this.options.sandboxId,
    };

    this.agent = new AgentClass(agentConfig);

  }

  async generateCode({
    prompt,
    mode = "code",
    branch,
    history,
  }: {
    prompt: string;
    mode?: AgentMode;
    branch?: string;
    history?: Conversation[];
  }): Promise<AgentResponse> {
    if (!this.agent) {
      await this.initializeAgent();
    }

    const callbacks = {
      onUpdate: (data: string) => this.emit("update", data),
      onError: (error: string) => this.emit("error", error),
    };

    return this.agent.generateCode(prompt, mode, branch, history, callbacks);
  }

  async createPullRequest(
    labelOptions?: LabelOptions,
    branchPrefix?: string
  ): Promise<PullRequestResult> {
    if (!this.agent) {
      await this.initializeAgent();
    }

    return this.agent.createPullRequest(labelOptions, branchPrefix);
  }

  async pushToBranch(branch?: string): Promise<void> {
    if (!this.agent) {
      await this.initializeAgent();
    }

    return this.agent.pushToBranch(branch);
  }

  async runTests(): Promise<any> {
    if (!this.agent) {
      await this.initializeAgent();
    }

    const callbacks = {
      onUpdate: (data: string) => this.emit("update", data),
      onError: (error: string) => this.emit("error", error),
    };

    return this.agent.runTests(undefined, undefined, callbacks);
  }

  async executeCommand(
    command: string,
    options: Omit<ExecuteCommandOptions, "callbacks"> = {},
  ): Promise<any> {
    if (!this.agent) {
      await this.initializeAgent();
    }

    const callbacks = {
      onUpdate: (data: string) => this.emit("stdout", data),
      onError: (error: string) => this.emit("stderr", error),
    };

    return this.agent.executeCommand(command, { ...options, callbacks });
  }

  async kill(): Promise<void> {
    if (!this.agent) return;
    return this.agent.killSandbox();
  }

  async pause(): Promise<void> {
    if (!this.agent) return;
    return this.agent.pauseSandbox();
  }

  async resume(): Promise<void> {
    if (!this.agent) return;
    return this.agent.resumeSandbox();
  }

  async getSession(): Promise<string | null> {
    if (!this.agent) return null;
    return this.agent.getSession();
  }

  async setSession(sessionId: string): Promise<void> {
    if (!this.agent) return;
    return this.agent.setSession(sessionId);
  }

  async getHost(port: number): Promise<string> {
    if (!this.agent) {
      await this.initializeAgent();
    }
    return this.agent.getHost(port);
  }
}



================================================
FILE: packages/sdk/src/registry/aws-ecr.ts
================================================
/**
 * AWS Elastic Container Registry (ECR) Implementation
 * 
 * Provides AWS ECR specific operations including image upload,
 * authentication, and registry management.
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { DockerClient } from '../services/docker-client';
import { ConfigManager, type AgentType } from '../services/config-manager';
import { RegistryProvider, type RegistryResult, type ImageUploadResult } from './registry-manager';
import { AGENT_LIST } from '../constants';

const execAsync = promisify(exec);

export interface AWSECRConfig {
  retryAttempts?: number;
  retryDelayMs?: number;
  awsRegion?: string;  // AWS region (e.g., us-east-1)
  awsAccountId?: string;  // AWS account ID
  logger?: {
    debug(message: string, meta?: any): void;
    info(message: string, meta?: any): void;
    warn(message: string, meta?: any): void;
    error(message: string, error?: Error | any, meta?: any): void;
  };
}

// Default console logger
const defaultLogger = {
  debug: (msg: string, meta?: any) => console.debug(`[ECR] ${msg}`, meta || ''),
  info: (msg: string, meta?: any) => console.log(`[ECR] ${msg}`, meta || ''),
  warn: (msg: string, meta?: any) => console.warn(`[ECR] ${msg}`, meta || ''),
  error: (msg: string, error?: any, meta?: any) => console.error(`[ECR] ${msg}`, error, meta || ''),
};

export class AWSECRRegistry implements RegistryProvider {
  private dockerClient: DockerClient;
  private configManager: ConfigManager;
  private logger: typeof defaultLogger;
  private awsRegion: string;
  private awsAccountId?: string;

  constructor(config: AWSECRConfig = {}) {
    this.logger = config.logger || defaultLogger;
    this.awsRegion = config.awsRegion || process.env.AWS_REGION || 'us-east-1';
    this.awsAccountId = config.awsAccountId || process.env.AWS_ACCOUNT_ID;
    this.dockerClient = new DockerClient({
      retryAttempts: config.retryAttempts,
      retryDelayMs: config.retryDelayMs,
      logger: this.logger,
    });
    this.configManager = new ConfigManager({ logger: this.logger });
  }

  /**
   * Get ECR registry URL (internal helper)
   */
  private getEcrUrl(): string {
    if (!this.awsAccountId) {
      throw new Error('AWS Account ID required for ECR operations');
    }
    return `${this.awsAccountId}.dkr.ecr.${this.awsRegion}.amazonaws.com`;
  }

  /**
   * Check if user is authenticated with AWS ECR
   */
  async checkLogin(): Promise<{ isLoggedIn: boolean; username?: string | null; registry?: string }> {
    try {
      const registryUrl = this.getEcrUrl();
      const { stdout } = await execAsync('docker system info --format json');
      const info = JSON.parse(stdout);
      
      // Check if ECR is in the registry credentials
      if (info.RegistryConfig?.IndexConfigs) {
        const hasEcr = Object.keys(info.RegistryConfig.IndexConfigs).some(key => 
          key.includes('.dkr.ecr.') && key.includes('.amazonaws.com')
        );
        
        if (hasEcr) {
          return {
            isLoggedIn: true,
            username: this.awsAccountId || null,
            registry: registryUrl
          };
        }
      }
      
      return { isLoggedIn: false, username: null, registry: registryUrl };
    } catch (error) {
      this.logger.debug('Failed to check ECR login status', error);
      return { isLoggedIn: false, username: null, registry: 'ecr' };
    }
  }

  /**
   * Login to AWS ECR using AWS CLI
   */
  async login(): Promise<void> {
    if (!this.awsAccountId) {
      throw new Error('AWS Account ID required for ECR login');
    }

    try {
      // Use AWS CLI to get login token
      const loginCommand = `aws ecr get-login-password --region ${this.awsRegion} | docker login --username AWS --password-stdin ${this.getEcrUrl()}`;
      await execAsync(loginCommand);
      this.logger.info(`Successfully logged into ECR in region ${this.awsRegion}`);
    } catch (error) {
      throw new Error(`Failed to login to ECR: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Create ECR repository if it doesn't exist
   */
  private async ensureRepository(repositoryName: string): Promise<void> {
    try {
      await execAsync(`aws ecr describe-repositories --repository-names ${repositoryName} --region ${this.awsRegion}`);
      this.logger.debug(`Repository ${repositoryName} already exists`);
    } catch {
      // Repository doesn't exist, create it
      try {
        await execAsync(`aws ecr create-repository --repository-name ${repositoryName} --region ${this.awsRegion}`);
        this.logger.info(`Created ECR repository: ${repositoryName}`);
      } catch (error) {
        throw new Error(`Failed to create ECR repository: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }

  /**
   * Get registry image name for an agent type
   */
  async getImageName(agentType: AgentType, username?: string): Promise<string | null> {
    // First check config file for custom images
    try {
      const customImage = await this.configManager.getRegistryImage(agentType);
      if (customImage && customImage.includes('.dkr.ecr.')) {
        return customImage;
      }
    } catch {
      // Ignore config errors
    }

    if (!this.awsAccountId) {
      return null;
    }

    const repositoryName = `vibekit-${agentType}`;
    return `${this.getEcrUrl()}/${repositoryName}:latest`;
  }

  /**
   * Upload images to AWS ECR
   */
  async uploadImages(
    username: string,  // In ECR context, this would be the AWS account ID
    selectedAgents?: AgentType[]
  ): Promise<RegistryResult> {
    const agentTypes = selectedAgents?.length ? selectedAgents : AGENT_LIST;
    const results: ImageUploadResult[] = [];

    // Set account ID if provided
    if (username && !this.awsAccountId) {
      this.awsAccountId = username;
    }

    // Ensure we're logged in
    const loginInfo = await this.checkLogin();
    if (!loginInfo.isLoggedIn) {
      await this.login();
    }

    this.logger.info(`Uploading VibeKit images to ECR in region ${this.awsRegion}`);

    for (const agentType of agentTypes) {
      try {
        this.logger.info(`Processing ${agentType} agent`);
        
        // Build local image first
        const localTag = `vibekit-${agentType}:latest`;
        const hasLocalImage = await this.dockerClient.checkLocalImage(localTag);
        
        if (!hasLocalImage) {
          throw new Error(`Local image ${localTag} not found. Build it first.`);
        }

        // Ensure repository exists
        const repositoryName = `vibekit-${agentType}`;
        await this.ensureRepository(repositoryName);

        // Tag for ECR
        const ecrTag = `${this.getEcrUrl()}/${repositoryName}:latest`;
        await this.dockerClient.tagImage(localTag, ecrTag);
        
        // Push to ECR
        await this.dockerClient.pushImage(ecrTag);
        
        this.logger.info(`âœ“ Uploaded ${agentType} to ECR`);
        results.push({
          agentType,
          success: true,
          imageUrl: ecrTag,
        });
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.logger.error(`Failed to upload ${agentType}`, error);
        results.push({
          agentType,
          success: false,
          error: errorMessage,
        });
      }
    }

    const successCount = results.filter(r => r.success).length;
    this.logger.info(`Upload complete: ${successCount}/${agentTypes.length} images uploaded to ECR`);

    return {
      success: successCount > 0,
      results,
    };
  }

  /**
   * Pull an image from AWS ECR
   */
  async pullImage(imageName: string): Promise<void> {
    // Ensure we're logged in
    const loginInfo = await this.checkLogin();
    if (!loginInfo.isLoggedIn) {
      await this.login();
    }

    // Ensure the image name includes ECR URL
    const fullImageName = imageName.includes('.dkr.ecr.') ? imageName : `${this.getEcrUrl()}/${imageName}`;
    
    try {
      await execAsync(`docker pull ${fullImageName}`);
      this.logger.debug(`Successfully pulled ${fullImageName}`);
    } catch (error) {
      throw new Error(`Failed to pull from ECR: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Check if an image exists locally
   */
  async checkLocalImage(imageName: string): Promise<boolean> {
    return await this.dockerClient.checkLocalImage(imageName);
  }

  /**
   * Get the registry URL/identifier  
   */
  getRegistryUrl(): string {
    if (!this.awsAccountId) {
      return 'ecr';
    }
    return `${this.awsAccountId}.dkr.ecr.${this.awsRegion}.amazonaws.com`;
  }

  /**
   * Get the registry name
   */
  getRegistryName(): string {
    return 'ecr';
  }

  /**
   * Setup AWS ECR for user
   */
  async setupRegistry(
    selectedAgents?: AgentType[]
  ): Promise<{ success: boolean; config?: any; error?: string }> {
    try {
      if (!this.awsAccountId) {
        return {
          success: false,
          error: 'AWS Account ID required. Set AWS_ACCOUNT_ID environment variable.',
        };
      }

      // Check AWS CLI is configured
      try {
        await execAsync('aws sts get-caller-identity');
      } catch {
        return {
          success: false,
          error: 'AWS CLI not configured. Run "aws configure" first.',
        };
      }

      // Upload images
      const uploadResult = await this.uploadImages(this.awsAccountId, selectedAgents);
      
      if (uploadResult.success) {
        // Save configuration
        const config = await this.configManager.getConfig();
        config.registryImages = config.registryImages || {};
        
        for (const result of uploadResult.results) {
          if (result.success && result.imageUrl) {
            config.registryImages[result.agentType] = result.imageUrl;
          }
        }
        
        config.preferRegistryImages = true;
        config.registryType = 'ecr';
        config.registryUser = this.awsAccountId;
        config.awsRegion = this.awsRegion;
        
        await this.configManager.saveConfig(config);
        
        return { success: true, config };
      }

      return {
        success: false,
        error: 'Failed to upload images to ECR',
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }
}


================================================
FILE: packages/sdk/src/registry/docker-hub.ts
================================================
/**
 * Docker Hub Registry Implementation
 * 
 * Provides Docker Hub specific operations including image upload,
 * user account management, and registry setup.
 */

import { DockerClient, type DockerLoginInfo } from '../services/docker-client';
import { ConfigManager, type AgentType, type VibeKitConfig } from '../services/config-manager';
import { RegistryProvider, type RegistryResult, type ImageUploadResult } from './registry-manager';
import { AGENT_LIST } from '../constants';

export interface DockerHubConfig {
  retryAttempts?: number;
  retryDelayMs?: number;
  logger?: {
    debug(message: string, meta?: any): void;
    info(message: string, meta?: any): void;
    warn(message: string, meta?: any): void;
    error(message: string, error?: Error | any, meta?: any): void;
  };
}

// Default console logger
const defaultLogger = {
  debug: (msg: string, meta?: any) => console.debug(`[DockerHub] ${msg}`, meta || ''),
  info: (msg: string, meta?: any) => console.log(`[DockerHub] ${msg}`, meta || ''),
  warn: (msg: string, meta?: any) => console.warn(`[DockerHub] ${msg}`, meta || ''),
  error: (msg: string, error?: any, meta?: any) => console.error(`[DockerHub] ${msg}`, error, meta || ''),
};

export class DockerHubRegistry implements RegistryProvider {
  private dockerClient: DockerClient;
  private configManager: ConfigManager;
  private logger: typeof defaultLogger;

  constructor(config: DockerHubConfig = {}) {
    this.logger = config.logger || defaultLogger;
    this.dockerClient = new DockerClient({
      retryAttempts: config.retryAttempts,
      retryDelayMs: config.retryDelayMs,
      logger: this.logger,
    });
    this.configManager = new ConfigManager({ logger: this.logger });
  }

  /**
   * Check if user is logged into Docker Hub
   */
  async checkLogin(): Promise<DockerLoginInfo> {
    return await this.dockerClient.checkDockerLogin();
  }

  /**
   * Get registry image name for an agent type
   */
  async getImageName(agentType: AgentType, username?: string): Promise<string | null> {
    // First check config file for custom images
    try {
      const customImage = await this.configManager.getRegistryImage(agentType);
      if (customImage) {
        return customImage;
      }
    } catch {
      // Ignore config errors
    }

    // Use provided username or get from config/login
    let dockerHubUser = username;
    if (!dockerHubUser) {
      dockerHubUser = await this.configManager.getDockerHubUser();
    }
    if (!dockerHubUser) {
      const loginInfo = await this.checkLogin();
      dockerHubUser = loginInfo.username || undefined;
    }

    if (!dockerHubUser) {
      return null;
    }

    return `${dockerHubUser}/vibekit-${agentType}:latest`;
  }

  /**
   * Upload images to user's Docker Hub account
   */
  async uploadImages(
    dockerHubUser: string,
    selectedAgents?: AgentType[]
  ): Promise<RegistryResult> {
    const defaultAgentTypes = AGENT_LIST;
    const agentTypes = selectedAgents?.length ? selectedAgents : defaultAgentTypes;
    const results: ImageUploadResult[] = [];

    this.logger.info(`Uploading VibeKit images to ${dockerHubUser}'s Docker Hub account`);

    for (const agentType of agentTypes) {
      try {
        this.logger.info(`Processing ${agentType} agent`);

        // Check if local image exists
        const localTag = `vibekit-${agentType}:latest`;
        const imageExists = await this.dockerClient.checkLocalImage(localTag);
        
        if (!imageExists) {
          this.logger.warn(`Local image ${localTag} not found, skipping upload`);
          results.push({ 
            agentType, 
            success: false, 
            error: `Local image ${localTag} not found` 
          });
          continue;
        }
        
        // Tag for user's account
        const userImageTag = `${dockerHubUser}/vibekit-${agentType}:latest`;
        
        await this.dockerClient.tagImage(localTag, userImageTag);
        this.logger.info(`Tagged as ${userImageTag}`);

        // Push to user's Docker Hub
        this.logger.info(`Pushing ${userImageTag} to Docker Hub`);
        await this.dockerClient.pushImage(userImageTag);
        
        this.logger.info(`Successfully pushed ${userImageTag}`);

        results.push({
          agentType,
          success: true,
          imageUrl: userImageTag,
        });
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.logger.error(`Failed to upload ${agentType} image`, error);
        results.push({ agentType, success: false, error: errorMessage });
      }
    }

    const successCount = results.filter(r => r.success).length;
    this.logger.info(`Upload complete: ${successCount}/${agentTypes.length} images uploaded`);

    return {
      success: successCount > 0,
      results,
    };
  }

  /**
   * Setup user's Docker Hub registry integration
   */
  async setupRegistry(selectedAgents?: AgentType[]): Promise<{
    success: boolean;
    config?: VibeKitConfig;
    error?: string;
  }> {
    try {
      this.logger.info("Setting up VibeKit Docker Registry Integration");

      // Check Docker login
      const loginInfo = await this.checkLogin();
      
      if (!loginInfo.isLoggedIn || !loginInfo.username) {
        return {
          success: false,
          error: 'Not logged into Docker Hub. Please run "docker login" first.',
        };
      }

      this.logger.info(`Logged in as: ${loginInfo.username}`);

      // Upload images to user's account
      const uploadResult = await this.uploadImages(loginInfo.username, selectedAgents);

      if (!uploadResult.success) {
        return {
          success: false,
          error: "Failed to upload images to Docker Hub",
        };
      }

      // Update configuration
      const config: VibeKitConfig = {
        dockerHubUser: loginInfo.username,
        lastImageBuild: new Date().toISOString(),
        registryImages: {},
      };

      // Map successful uploads to registry images
      for (const result of uploadResult.results) {
        if (result.success && result.imageUrl) {
          config.registryImages![result.agentType] = result.imageUrl;
        }
      }

      await this.configManager.saveConfig(config);
      this.logger.info("Configuration saved");

      return { success: true, config };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger.error("Failed to setup Docker registry", error);
      return { success: false, error: errorMessage };
    }
  }

  /**
   * Pull an image from the registry
   */
  async pullImage(imageName: string): Promise<void> {
    await this.dockerClient.pullImage(imageName);
  }

  /**
   * Check if an image exists locally
   */
  async checkLocalImage(imageName: string): Promise<boolean> {
    return await this.dockerClient.checkLocalImage(imageName);
  }

  /**
   * Get the registry URL/identifier
   */
  getRegistryUrl(): string {
    return "https://index.docker.io/v1/";
  }

  /**
   * Get the registry name
   */
  getRegistryName(): string {
    return "Docker Hub";
  }
}


================================================
FILE: packages/sdk/src/registry/github-container-registry.ts
================================================
/**
 * GitHub Container Registry (ghcr.io) Implementation
 * 
 * Provides GitHub Container Registry specific operations including image upload,
 * authentication, and registry management.
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { DockerClient } from '../services/docker-client';
import { ConfigManager, type AgentType } from '../services/config-manager';
import { RegistryProvider, type RegistryResult, type ImageUploadResult } from './registry-manager';
import { AGENT_LIST } from '../constants';

const execAsync = promisify(exec);

export interface GitHubContainerRegistryConfig {
  retryAttempts?: number;
  retryDelayMs?: number;
  githubToken?: string;  // GitHub Personal Access Token
  logger?: {
    debug(message: string, meta?: any): void;
    info(message: string, meta?: any): void;
    warn(message: string, meta?: any): void;
    error(message: string, error?: Error | any, meta?: any): void;
  };
}

// Default console logger
const defaultLogger = {
  debug: (msg: string, meta?: any) => console.debug(`[GHCR] ${msg}`, meta || ''),
  info: (msg: string, meta?: any) => console.log(`[GHCR] ${msg}`, meta || ''),
  warn: (msg: string, meta?: any) => console.warn(`[GHCR] ${msg}`, meta || ''),
  error: (msg: string, error?: any, meta?: any) => console.error(`[GHCR] ${msg}`, error, meta || ''),
};

export class GitHubContainerRegistry implements RegistryProvider {
  private dockerClient: DockerClient;
  private configManager: ConfigManager;
  private logger: typeof defaultLogger;
  private githubToken?: string;

  constructor(config: GitHubContainerRegistryConfig = {}) {
    this.logger = config.logger || defaultLogger;
    this.githubToken = config.githubToken || process.env.GITHUB_TOKEN;
    this.dockerClient = new DockerClient({
      retryAttempts: config.retryAttempts,
      retryDelayMs: config.retryDelayMs,
      logger: this.logger,
    });
    this.configManager = new ConfigManager({ logger: this.logger });
  }

  /**
   * Check if user is authenticated with GitHub Container Registry
   */
  async checkLogin(): Promise<{ isLoggedIn: boolean; username?: string | null; registry?: string }> {
    try {
      const { stdout } = await execAsync('docker system info --format json');
      const info = JSON.parse(stdout);
      
      // Check if ghcr.io is in the registry credentials
      if (info.RegistryConfig?.IndexConfigs) {
        const hasGhcr = Object.keys(info.RegistryConfig.IndexConfigs).some(key => 
          key.includes('ghcr.io')
        );
        
        if (hasGhcr) {
          // Try to get username from git config
          try {
            const { stdout: gitUser } = await execAsync('git config user.name');
            return {
              isLoggedIn: true,
              username: gitUser.trim().toLowerCase().replace(/\s+/g, '-'),
              registry: 'ghcr.io'
            };
          } catch {
            return { isLoggedIn: true, username: null, registry: 'ghcr.io' };
          }
        }
      }
      
      return { isLoggedIn: false, username: null, registry: 'ghcr.io' };
    } catch (error) {
      this.logger.debug('Failed to check GHCR login status', error);
      return { isLoggedIn: false, username: null, registry: 'ghcr.io' };
    }
  }

  /**
   * Login to GitHub Container Registry using token
   */
  async login(username: string): Promise<void> {
    if (!this.githubToken) {
      throw new Error('GitHub token required for GHCR login. Set GITHUB_TOKEN environment variable.');
    }

    try {
      await execAsync(`echo ${this.githubToken} | docker login ghcr.io -u ${username} --password-stdin`);
      this.logger.info(`Successfully logged into ghcr.io as ${username}`);
    } catch (error) {
      throw new Error(`Failed to login to ghcr.io: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Get registry image name for an agent type
   */
  async getImageName(agentType: AgentType, username?: string): Promise<string | null> {
    // First check config file for custom images
    try {
      const customImage = await this.configManager.getRegistryImage(agentType);
      if (customImage && customImage.includes('ghcr.io')) {
        return customImage;
      }
    } catch {
      // Ignore config errors
    }

    // Use provided username or try to get from login
    let ghcrUser = username;
    if (!ghcrUser) {
      const loginInfo = await this.checkLogin();
      ghcrUser = loginInfo.username || undefined;
    }

    if (!ghcrUser) {
      return null;
    }

    return `ghcr.io/${ghcrUser}/vibekit-${agentType}:latest`;
  }

  /**
   * Upload images to GitHub Container Registry
   */
  async uploadImages(
    username: string,
    selectedAgents?: AgentType[]
  ): Promise<RegistryResult> {
    const agentTypes = selectedAgents?.length ? selectedAgents : AGENT_LIST;
    const results: ImageUploadResult[] = [];

    // Ensure we're logged in
    const loginInfo = await this.checkLogin();
    if (!loginInfo.isLoggedIn) {
      await this.login(username);
    }

    this.logger.info(`Uploading VibeKit images to ghcr.io/${username}`);

    for (const agentType of agentTypes) {
      try {
        this.logger.info(`Processing ${agentType} agent`);
        
        // Build local image first
        const localTag = `vibekit-${agentType}:latest`;
        const hasLocalImage = await this.dockerClient.checkLocalImage(localTag);
        
        if (!hasLocalImage) {
          throw new Error(`Local image ${localTag} not found. Build it first.`);
        }

        // Tag for GHCR
        const ghcrTag = `ghcr.io/${username}/vibekit-${agentType}:latest`;
        await this.dockerClient.tagImage(localTag, ghcrTag);
        
        // Push to GHCR
        await this.dockerClient.pushImage(ghcrTag);
        
        this.logger.info(`âœ“ Uploaded ${agentType} to ghcr.io/${username}`);
        results.push({
          agentType,
          success: true,
          imageUrl: ghcrTag,
        });
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.logger.error(`Failed to upload ${agentType}`, error);
        results.push({
          agentType,
          success: false,
          error: errorMessage,
        });
      }
    }

    const successCount = results.filter(r => r.success).length;
    this.logger.info(`Upload complete: ${successCount}/${agentTypes.length} images uploaded to GHCR`);

    return {
      success: successCount > 0,
      results,
    };
  }

  /**
   * Pull an image from GitHub Container Registry
   */
  async pullImage(imageName: string): Promise<void> {
    // Ensure the image name includes ghcr.io
    const fullImageName = imageName.includes('ghcr.io') ? imageName : `ghcr.io/${imageName}`;
    
    try {
      await execAsync(`docker pull ${fullImageName}`);
      this.logger.debug(`Successfully pulled ${fullImageName}`);
    } catch (error) {
      throw new Error(`Failed to pull from GHCR: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Check if an image exists locally
   */
  async checkLocalImage(imageName: string): Promise<boolean> {
    return await this.dockerClient.checkLocalImage(imageName);
  }

  /**
   * Get the registry URL/identifier
   */
  getRegistryUrl(): string {
    return 'ghcr.io';
  }

  /**
   * Get the registry name
   */
  getRegistryName(): string {
    return 'ghcr';
  }

  /**
   * Setup GitHub Container Registry for user
   */
  async setupRegistry(
    selectedAgents?: AgentType[]
  ): Promise<{ success: boolean; config?: any; error?: string }> {
    try {
      // Check if logged in
      const loginInfo = await this.checkLogin();
      if (!loginInfo.isLoggedIn || !loginInfo.username) {
        return {
          success: false,
          error: 'Not logged into ghcr.io. Please set GITHUB_TOKEN and provide username.',
        };
      }

      // Upload images
      const uploadResult = await this.uploadImages(loginInfo.username, selectedAgents);
      
      if (uploadResult.success) {
        // Save configuration
        const config = await this.configManager.getConfig();
        config.registryImages = config.registryImages || {};
        
        for (const result of uploadResult.results) {
          if (result.success && result.imageUrl) {
            config.registryImages[result.agentType] = result.imageUrl;
          }
        }
        
        config.preferRegistryImages = true;
        config.registryType = 'ghcr';
        config.registryUser = loginInfo.username;
        
        await this.configManager.saveConfig(config);
        
        return { success: true, config };
      }

      return {
        success: false,
        error: 'Failed to upload images to GHCR',
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }
}


================================================
FILE: packages/sdk/src/registry/image-resolver.ts
================================================
/**
 * Image Resolver
 * 
 * Provides Docker image resolution strategy for sandbox providers that use
 * local Docker images (currently only Dagger). Handles image building, 
 * caching, and registry operations.
 */

import { existsSync } from "fs";
import { DockerClient } from '../services/docker-client';
import { ConfigManager, type AgentType } from '../services/config-manager';
import { RegistryManager } from './registry-manager';
import { AGENT_LIST, AGENT_TYPES } from '../constants';

export interface ImageResolverConfig {
  preferRegistryImages?: boolean;
  pushImages?: boolean;
  privateRegistry?: string;
  dockerHubUser?: string;  // Deprecated - use registryUser instead
  registryUser?: string;  // Universal registry username
  registryName?: string;  // Which registry to use (defaults to RegistryManager's default)
  retryAttempts?: number;
  retryDelayMs?: number;
  logger?: {
    debug(message: string, meta?: any): void;
    info(message: string, meta?: any): void;
    warn(message: string, meta?: any): void;
    error(message: string, error?: Error | any, meta?: any): void;
  };
}

// Default console logger
const defaultLogger = {
  debug: (msg: string, meta?: any) => console.debug(`[ImageResolver] ${msg}`, meta || ''),
  info: (msg: string, meta?: any) => console.log(`[ImageResolver] ${msg}`, meta || ''),
  warn: (msg: string, meta?: any) => console.warn(`[ImageResolver] ${msg}`, meta || ''),
  error: (msg: string, error?: any, meta?: any) => console.error(`[ImageResolver] ${msg}`, error, meta || ''),
};

// Helper function to get Dockerfile path based on agent type
const getDockerfilePathFromAgentType = (agentType?: AgentType): string | undefined => {
  if (!agentType) return undefined;
  
  const dockerfileMap: Record<AgentType, string> = {
    [AGENT_TYPES.CLAUDE]: "assets/dockerfiles/Dockerfile.claude",
    [AGENT_TYPES.CODEX]: "assets/dockerfiles/Dockerfile.codex",
    [AGENT_TYPES.OPENCODE]: "assets/dockerfiles/Dockerfile.opencode",
    [AGENT_TYPES.GEMINI]: "assets/dockerfiles/Dockerfile.gemini",
    [AGENT_TYPES.GROK]: "assets/dockerfiles/Dockerfile.grok"
  };
  
  return dockerfileMap[agentType];
};

export class ImageResolver {
  private dockerClient: DockerClient;
  private configManager: ConfigManager;
  private registryManager: RegistryManager;
  private config: Required<Omit<ImageResolverConfig, 'registryName'>> & { registryName?: string };

  constructor(
    config: ImageResolverConfig = {},
    registryManager?: RegistryManager
  ) {
    // Support both registryUser and dockerHubUser for backward compatibility
    const registryUser = config.registryUser ?? config.dockerHubUser ?? "";
    
    this.config = {
      preferRegistryImages: config.preferRegistryImages ?? true,
      pushImages: config.pushImages ?? true,
      privateRegistry: config.privateRegistry ?? "",
      dockerHubUser: registryUser,  // Keep for backward compatibility
      registryUser: registryUser,
      registryName: config.registryName ?? undefined,  // Use RegistryManager's default if not specified
      retryAttempts: config.retryAttempts ?? 3,
      retryDelayMs: config.retryDelayMs ?? 1000,
      logger: config.logger ?? defaultLogger,
    };

    this.dockerClient = new DockerClient({
      retryAttempts: this.config.retryAttempts,
      retryDelayMs: this.config.retryDelayMs,
      logger: this.config.logger,
    });

    this.configManager = new ConfigManager({ logger: this.config.logger });
    
    // Use provided registry manager or create a default one
    this.registryManager = registryManager || new RegistryManager({
      defaultRegistry: 'dockerhub',
      logger: this.config.logger,
    });
  }

  /**
   * Resolve the best available image for an agent type
   * 
   * Strategy:
   * 1. Check local cache
   * 2. Try to pull from user's registry
   * 3. Build locally and push to registry (if configured)
   * 4. Fallback to base image
   */
  async resolveImage(agentType?: AgentType): Promise<string> {
    if (!agentType) {
      return "ubuntu:24.04";
    }

    const localTag = this.getLocalImageTag(agentType);
    
    // Step 1: Check local cache
    try {
      const hasLocalImage = await this.dockerClient.checkLocalImage(localTag);
      if (hasLocalImage) {
        this.config.logger.debug(`Using cached local image: ${localTag}`);
        return localTag;
      }
    } catch (error) {
      this.config.logger.debug(`Local image check failed: ${error}`);
    }

    // Step 2: Try to pull from user's registry
    if (this.config.preferRegistryImages) {
      try {
        // Use configured registry or let RegistryManager use its default
        const registryImage = await this.registryManager.getImageName(
          agentType, 
          this.config.registryName,  // Could be undefined, 'dockerhub', 'ghcr', etc.
          this.config.registryUser || undefined
        );
        if (registryImage) {
          await this.registryManager.pullImage(registryImage);
          this.config.logger.info(`Successfully pulled image from registry: ${registryImage}`);
          
          // Tag it locally for cache
          await this.dockerClient.tagImage(registryImage, localTag);
          return localTag;
        }
      } catch (error) {
        this.config.logger.debug(`Registry image not found, will build locally`);
      }
    }

    // Step 3: Build locally and push to registry
    const dockerfilePath = getDockerfilePathFromAgentType(agentType);
    if (dockerfilePath && existsSync(dockerfilePath)) {
      try {
        // Validate path doesn't contain directory traversal
        if (dockerfilePath.includes('..') || dockerfilePath.includes('~')) {
          throw new Error(`Invalid dockerfile path: ${dockerfilePath}`);
        }
        // Build the image
        await this.dockerClient.buildImage(dockerfilePath, localTag);
        this.config.logger.info(`âœ“ Built ${agentType} agent`);

        // Push to registry if configured
        if (this.config.pushImages) {
          try {
            const registryImage = await this.registryManager.getImageName(
              agentType, 
              this.config.registryName,  // Use configured registry or default
              this.config.registryUser || undefined
            );
            if (registryImage) {
              await this.dockerClient.tagImage(localTag, registryImage);
              await this.dockerClient.pushImage(registryImage);
              this.config.logger.debug(`Pushed image to registry: ${registryImage}`);
            }
          } catch (pushError) {
            this.config.logger.warn(`Failed to push to registry, continuing with local image`, pushError);
          }
        }

        return localTag;
      } catch (buildError) {
        this.config.logger.error(`Failed to build image from Dockerfile`, buildError);
        throw new Error(`Failed to resolve image for ${agentType}: ${buildError instanceof Error ? buildError.message : String(buildError)}`);
      }
    }

    // Final fallback
    this.config.logger.warn(`No image available for ${agentType}, using fallback`);
    return "ubuntu:24.04";
  }

  /**
   * Get the local image tag for an agent type
   */
  private getLocalImageTag(agentType: AgentType): string {
    // If we have a registryUser, use the full image name
    if (this.config.registryUser) {
      return `${this.config.registryUser}/vibekit-${agentType}:latest`;
    }
    return `vibekit-${agentType}:latest`;
  }

  /**
   * Pre-build multiple agent images
   */
  async prebuildImages(selectedAgents?: AgentType[]): Promise<{
    success: boolean;
    results: Array<{
      agentType: AgentType;
      success: boolean;
      error?: string;
      source: "registry" | "dockerfile" | "cached";
    }>;
  }> {
    const agentTypes = selectedAgents?.length ? selectedAgents : AGENT_LIST;
    const results: Array<{
      agentType: AgentType;
      success: boolean;
      error?: string;
      source: "registry" | "dockerfile" | "cached";
    }> = [];

    // Only show pre-build message if not all images are cached
    const needsBuild = agentTypes.length > 0;
    if (needsBuild) {
      this.config.logger.info("Preparing agent images...");
    }

    for (const agentType of agentTypes) {
      try {
        await this.resolveImage(agentType);
        results.push({ agentType, success: true, source: "cached" });
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.config.logger.error(`Failed to pre-build image for ${agentType}`, error);
        results.push({ agentType, success: false, error: errorMessage, source: "dockerfile" });
      }
    }

    const successCount = results.filter(r => r.success).length;
    if (successCount === agentTypes.length) {
      this.config.logger.info(`âœ“ All agent images ready`);
    } else if (successCount > 0) {
      this.config.logger.info(`Images prepared: ${successCount}/${agentTypes.length} successful`);
    }

    return {
      success: successCount > 0,
      results,
    };
  }

  /**
   * Get available agent types that have Dockerfiles
   */
  getAvailableAgentTypes(): AgentType[] {
    return AGENT_LIST.filter(type => {
      const dockerfilePath = getDockerfilePathFromAgentType(type);
      return dockerfilePath && existsSync(dockerfilePath);
    });
  }

  /**
   * Check if an agent type has a local image
   */
  async hasLocalImage(agentType: AgentType): Promise<boolean> {
    const localTag = this.getLocalImageTag(agentType);
    return await this.dockerClient.checkLocalImage(localTag);
  }

  /**
   * Remove local image for an agent type
   */
  async removeLocalImage(agentType: AgentType, force: boolean = false): Promise<void> {
    const localTag = this.getLocalImageTag(agentType);
    await this.dockerClient.removeImage(localTag, force);
    this.config.logger.info(`Removed local image: ${localTag}`);
  }
}


================================================
FILE: packages/sdk/src/registry/index.ts
================================================
/**
 * Registry Module
 * 
 * Provides provider-agnostic container registry operations for VibeKit,
 * supporting multiple registry providers and image resolution strategies.
 */

export { DockerHubRegistry, type DockerHubConfig } from './docker-hub';
export { GitHubContainerRegistry, type GitHubContainerRegistryConfig } from './github-container-registry';
export { AWSECRRegistry, type AWSECRConfig } from './aws-ecr';
export { 
  RegistryManager, 
  type RegistryProvider, 
  type RegistryResult, 
  type ImageUploadResult, 
  type RegistryManagerConfig 
} from './registry-manager';
export { ImageResolver, type ImageResolverConfig } from './image-resolver';


================================================
FILE: packages/sdk/src/registry/registry-manager.ts
================================================
/**
 * Registry Manager
 * 
 * Provides a generic interface for container registry operations,
 * supporting multiple registry providers (Docker Hub, ECR, GCR, etc.)
 */

import { type AgentType } from '../services/config-manager';

export interface ImageUploadResult {
  agentType: AgentType;
  success: boolean;
  error?: string;
  imageUrl?: string;
}

export interface RegistryResult {
  success: boolean;
  results: ImageUploadResult[];
}

export interface RegistryProvider {
  /**
   * Check if user is authenticated with the registry
   */
  checkLogin(): Promise<{ isLoggedIn: boolean; username?: string | null; registry?: string }>;

  /**
   * Get the full image name for an agent type in this registry
   */
  getImageName(agentType: AgentType, username?: string): Promise<string | null>;

  /**
   * Upload multiple images to the registry
   */
  uploadImages(username: string, selectedAgents?: AgentType[]): Promise<RegistryResult>;

  /**
   * Pull an image from the registry
   */
  pullImage(imageName: string): Promise<void>;

  /**
   * Check if an image exists locally
   */
  checkLocalImage(imageName: string): Promise<boolean>;

  /**
   * Get the registry URL/identifier
   */
  getRegistryUrl(): string;

  /**
   * Get a human-readable registry name
   */
  getRegistryName(): string;
}

export interface RegistryManagerConfig {
  defaultRegistry?: 'dockerhub' | 'ecr' | 'gcr' | 'github';
  registries?: Record<string, RegistryProvider>;
  logger?: {
    debug(message: string, meta?: any): void;
    info(message: string, meta?: any): void;
    warn(message: string, meta?: any): void;
    error(message: string, error?: Error | any, meta?: any): void;
  };
}

// Default console logger
const defaultLogger = {
  debug: (msg: string, meta?: any) => console.debug(`[RegistryManager] ${msg}`, meta || ''),
  info: (msg: string, meta?: any) => console.log(`[RegistryManager] ${msg}`, meta || ''),
  warn: (msg: string, meta?: any) => console.warn(`[RegistryManager] ${msg}`, meta || ''),
  error: (msg: string, error?: any, meta?: any) => console.error(`[RegistryManager] ${msg}`, error, meta || ''),
};

export class RegistryManager {
  private registries: Record<string, RegistryProvider> = {};
  private defaultRegistry: string;
  private logger: typeof defaultLogger;

  constructor(config: RegistryManagerConfig = {}) {
    this.defaultRegistry = config.defaultRegistry || 'dockerhub';
    this.logger = config.logger || defaultLogger;
    
    if (config.registries) {
      this.registries = { ...config.registries };
    }
  }

  /**
   * Register a new registry provider
   */
  registerRegistry(name: string, provider: RegistryProvider): void {
    this.registries[name] = provider;
    this.logger.debug(`Registered registry provider: ${name}`);
  }

  /**
   * Get a registry provider by name
   */
  getRegistry(name?: string): RegistryProvider {
    const registryName = name || this.defaultRegistry;
    const registry = this.registries[registryName];
    
    if (!registry) {
      throw new Error(`Registry provider '${registryName}' not found. Available: ${Object.keys(this.registries).join(', ')}`);
    }
    
    return registry;
  }

  /**
   * Get list of available registry names
   */
  getAvailableRegistries(): string[] {
    return Object.keys(this.registries);
  }

  /**
   * Set the default registry
   */
  setDefaultRegistry(name: string): void {
    if (!this.registries[name]) {
      throw new Error(`Cannot set default registry to '${name}' - registry not found`);
    }
    this.defaultRegistry = name;
    this.logger.info(`Default registry set to: ${name}`);
  }

  /**
   * Check login status for a specific registry
   */
  async checkLogin(registryName?: string): Promise<{ isLoggedIn: boolean; username?: string | null; registry?: string }> {
    const registry = this.getRegistry(registryName);
    return await registry.checkLogin();
  }

  /**
   * Get image name for an agent type from a specific registry
   */
  async getImageName(agentType: AgentType, registryName?: string, username?: string): Promise<string | null> {
    const registry = this.getRegistry(registryName);
    return await registry.getImageName(agentType, username);
  }

  /**
   * Upload images to a specific registry
   */
  async uploadImages(
    username: string, 
    selectedAgents?: AgentType[], 
    registryName?: string
  ): Promise<RegistryResult> {
    const registry = this.getRegistry(registryName);
    this.logger.info(`Uploading images to ${registry.getRegistryName()}`);
    return await registry.uploadImages(username, selectedAgents);
  }

  /**
   * Pull an image from a specific registry
   */
  async pullImage(imageName: string, registryName?: string): Promise<void> {
    const registry = this.getRegistry(registryName);
    await registry.pullImage(imageName);
  }

  /**
   * Check if an image exists locally
   */
  async checkLocalImage(imageName: string, registryName?: string): Promise<boolean> {
    const registry = this.getRegistry(registryName);
    return await registry.checkLocalImage(imageName);
  }

  /**
   * Setup registry integration for a user
   */
  async setupRegistry(
    selectedAgents?: AgentType[], 
    registryName?: string
  ): Promise<{
    success: boolean;
    config?: any;
    error?: string;
  }> {
    const registry = this.getRegistry(registryName);
    
    // Check if the registry has a setup method
    if ('setupRegistry' in registry && typeof registry.setupRegistry === 'function') {
      return await (registry as any).setupRegistry(selectedAgents);
    }
    
    // Generic setup - just upload images if logged in
    const loginInfo = await registry.checkLogin();
    if (!loginInfo.isLoggedIn || !loginInfo.username) {
      return {
        success: false,
        error: `Not logged into ${registry.getRegistryName()}`,
      };
    }

    const uploadResult = await registry.uploadImages(loginInfo.username, selectedAgents);
    return {
      success: uploadResult.success,
      error: uploadResult.success ? undefined : "Failed to upload images to registry",
    };
  }

  /**
   * Get registry information
   */
  getRegistryInfo(registryName?: string): { name: string; url: string } {
    const registry = this.getRegistry(registryName);
    return {
      name: registry.getRegistryName(),
      url: registry.getRegistryUrl(),
    };
  }
}


================================================
FILE: packages/sdk/src/services/config-manager.ts
================================================
/**
 * Configuration Manager
 * 
 * Provides provider-agnostic configuration management for VibeKit,
 * including Docker Hub user settings and registry image mappings.
 */

import { readFile, writeFile, mkdir } from "fs/promises";
import { existsSync } from "fs";
import { join } from "path";
import { homedir } from "os";
import { AgentType } from '../constants';

export { AgentType };

export interface VibeKitConfig {
  dockerHubUser?: string;
  lastImageBuild?: string;
  registryImages?: Partial<Record<AgentType, string>>;
  privateRegistry?: string;
  preferRegistryImages?: boolean;
  pushImages?: boolean;
  [key: string]: any; // Allow for additional config properties
}

export interface ConfigManagerOptions {
  configPath?: string;
  logger?: {
    debug(message: string, meta?: any): void;
    info(message: string, meta?: any): void;
    warn(message: string, meta?: any): void;
    error(message: string, error?: Error | any, meta?: any): void;
  };
}

// Default console logger
const defaultLogger = {
  debug: (msg: string, meta?: any) => console.debug(`[ConfigManager] ${msg}`, meta || ''),
  info: (msg: string, meta?: any) => console.log(`[ConfigManager] ${msg}`, meta || ''),
  warn: (msg: string, meta?: any) => console.warn(`[ConfigManager] ${msg}`, meta || ''),
  error: (msg: string, error?: any, meta?: any) => console.error(`[ConfigManager] ${msg}`, error, meta || ''),
};

export class ConfigManager {
  private configPath: string;
  private configDir: string;
  private logger: typeof defaultLogger;

  constructor(options: ConfigManagerOptions = {}) {
    this.configDir = options.configPath || join(homedir(), ".vibekit");
    this.configPath = join(this.configDir, "config.json");
    this.logger = options.logger || defaultLogger;
  }

  /**
   * Get the current VibeKit configuration
   */
  async getConfig(): Promise<VibeKitConfig> {
    if (!existsSync(this.configPath)) {
      this.logger.debug(`Config file not found at ${this.configPath}, returning empty config`);
      return {};
    }

    try {
      const content = await readFile(this.configPath, "utf-8");
      const config = JSON.parse(content);
      this.logger.debug(`Loaded config from ${this.configPath}`);
      return config;
    } catch (error) {
      this.logger.warn(`Failed to read config file: ${error instanceof Error ? error.message : String(error)}`);
      return {};
    }
  }

  /**
   * Save the VibeKit configuration
   */
  async saveConfig(config: VibeKitConfig): Promise<void> {
    try {
      // Ensure directory exists
      if (!existsSync(this.configDir)) {
        await mkdir(this.configDir, { recursive: true });
        this.logger.debug(`Created config directory: ${this.configDir}`);
      }
      
      await writeFile(this.configPath, JSON.stringify(config, null, 2));
      this.logger.debug(`Saved config to ${this.configPath}`);
    } catch (error) {
      this.logger.error(`Failed to save config: ${error instanceof Error ? error.message : String(error)}`, error);
      throw error;
    }
  }

  /**
   * Update specific configuration values
   */
  async updateConfig(updates: Partial<VibeKitConfig>): Promise<VibeKitConfig> {
    const currentConfig = await this.getConfig();
    const newConfig = { ...currentConfig, ...updates };
    await this.saveConfig(newConfig);
    return newConfig;
  }

  /**
   * Get Docker Hub user from config
   */
  async getDockerHubUser(): Promise<string | undefined> {
    const config = await this.getConfig();
    return config.dockerHubUser;
  }

  /**
   * Set Docker Hub user in config
   */
  async setDockerHubUser(username: string): Promise<void> {
    await this.updateConfig({ dockerHubUser: username });
  }

  /**
   * Get registry image URL for a specific agent type
   */
  async getRegistryImage(agentType: AgentType): Promise<string | undefined> {
    const config = await this.getConfig();
    return config.registryImages?.[agentType];
  }

  /**
   * Set registry image URL for a specific agent type
   */
  async setRegistryImage(agentType: AgentType, imageUrl: string): Promise<void> {
    const config = await this.getConfig();
    const registryImages = config.registryImages || {};
    registryImages[agentType] = imageUrl;
    await this.updateConfig({ registryImages });
  }

  /**
   * Set multiple registry images at once
   */
  async setRegistryImages(images: Partial<Record<AgentType, string>>): Promise<void> {
    const config = await this.getConfig();
    const registryImages = { ...config.registryImages, ...images };
    await this.updateConfig({ registryImages });
  }

  /**
   * Check if registry images are preferred over local builds
   */
  async preferRegistryImages(): Promise<boolean> {
    const config = await this.getConfig();
    return config.preferRegistryImages ?? true;
  }

  /**
   * Check if images should be pushed to registry after building
   */
  async shouldPushImages(): Promise<boolean> {
    const config = await this.getConfig();
    return config.pushImages ?? true;
  }

  /**
   * Get the configuration file path
   */
  getConfigPath(): string {
    return this.configPath;
  }

  /**
   * Get the configuration directory path
   */
  getConfigDir(): string {
    return this.configDir;
  }

  /**
   * Check if configuration file exists
   */
  configExists(): boolean {
    return existsSync(this.configPath);
  }

  /**
   * Delete the configuration file
   */
  async deleteConfig(): Promise<void> {
    if (existsSync(this.configPath)) {
      const { unlink } = await import("fs/promises");
      await unlink(this.configPath);
      this.logger.debug(`Deleted config file: ${this.configPath}`);
    }
  }

  /**
   * Reset configuration to defaults
   */
  async resetConfig(): Promise<void> {
    const defaultConfig: VibeKitConfig = {
      preferRegistryImages: true,
      pushImages: true,
    };
    await this.saveConfig(defaultConfig);
    this.logger.info("Configuration reset to defaults");
  }
}


================================================
FILE: packages/sdk/src/services/docker-client.ts
================================================
/**
 * Docker Client Infrastructure
 * 
 * Provides provider-agnostic Docker operations including login detection,
 * image building, pushing, pulling, and tagging.
 */

import { exec } from "child_process";
import { promisify } from "util";
import { readFile } from "fs/promises";
import { join } from "path";
import { homedir } from "os";

const execAsync = promisify(exec);

export interface DockerLoginInfo {
  isLoggedIn: boolean;
  username?: string | null;
  registry?: string;
}

export interface DockerClientConfig {
  retryAttempts?: number;
  retryDelayMs?: number;
  logger?: {
    debug(message: string, meta?: any): void;
    info(message: string, meta?: any): void;
    warn(message: string, meta?: any): void;
    error(message: string, error?: Error | any, meta?: any): void;
  };
}

// Default console logger
const defaultLogger = {
  debug: (msg: string, meta?: any) => console.debug(`[DockerClient] ${msg}`, meta || ''),
  info: (msg: string, meta?: any) => console.log(`[DockerClient] ${msg}`, meta || ''),
  warn: (msg: string, meta?: any) => console.warn(`[DockerClient] ${msg}`, meta || ''),
  error: (msg: string, error?: any, meta?: any) => console.error(`[DockerClient] ${msg}`, error, meta || ''),
};

// Retry utility with exponential backoff
async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  options: {
    attempts: number;
    delayMs: number;
    logger: typeof defaultLogger;
    context: string;
  }
): Promise<T> {
  let lastError: Error | undefined;
  
  for (let attempt = 1; attempt <= options.attempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      options.logger.debug(
        `${options.context} failed (attempt ${attempt}/${options.attempts})`,
        lastError
      );
      
      if (attempt < options.attempts) {
        const delay = options.delayMs * Math.pow(2, attempt - 1);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw lastError || new Error(`${options.context} failed after ${options.attempts} attempts`);
}

export class DockerClient {
  private config: Required<DockerClientConfig>;

  constructor(config: DockerClientConfig = {}) {
    this.config = {
      retryAttempts: config.retryAttempts ?? 3,
      retryDelayMs: config.retryDelayMs ?? 1000,
      logger: config.logger ?? defaultLogger,
    };
  }

  /**
   * Sanitize image name to prevent command injection
   */
  private sanitizeImageName(imageName: string): string {
    // Allow only valid Docker image characters
    if (!/^[a-zA-Z0-9][a-zA-Z0-9._\-\/:]*(:[a-zA-Z0-9._\-]+)?$/.test(imageName)) {
      throw new Error(`Invalid image name: ${imageName}`);
    }
    return imageName;
  }

  /**
   * Sanitize file path to prevent command injection and directory traversal
   */
  private sanitizePath(path: string): string {
    // Prevent command injection characters
    if (/[;&|`$()<>]/.test(path)) {
      throw new Error(`Invalid path contains shell metacharacters: ${path}`);
    }
    // Prevent directory traversal
    if (path.includes('..')) {
      throw new Error(`Invalid path contains directory traversal: ${path}`);
    }
    return path;
  }

  /**
   * Check if user is logged into Docker Hub
   */
  async checkDockerLogin(): Promise<DockerLoginInfo> {
    const logger = this.config.logger;
    
    try {
      // Primary method: Use 'docker login' command to check current login status
      try {
        // Run docker login without credentials - this will show current login status
        const { stdout, stderr } = await execAsync('docker login', { timeout: 5000 });
        
        // Combine stdout and stderr to search for username
        const output = stdout + stderr;
        
        // Look for username in various docker login output formats
        let usernameMatch = output.match(/\[Username:\s*([^\]]+)\]/); // New format: [Username: joedanziger]
        if (!usernameMatch) {
          usernameMatch = output.match(/Username:\s*([^\s\]]+)/); // Old format: Username: joedanziger
        }
        
        if (usernameMatch) {
          return {
            isLoggedIn: true,
            username: usernameMatch[1].trim(),
            registry: "https://index.docker.io/v1/",
          };
        }
      } catch (loginError) {
        // docker login might exit with non-zero even when showing login status
        const errorStr = loginError instanceof Error ? loginError.message : String(loginError);
        
        // Look for username in error message (docker login output often goes to stderr)
        let usernameMatch = errorStr.match(/\[Username:\s*([^\]]+)\]/); // New format: [Username: joedanziger]
        if (!usernameMatch) {
          usernameMatch = errorStr.match(/Username:\s*([^\s\]]+)/); // Old format: Username: joedanziger
        }
        
        if (usernameMatch) {
          return {
            isLoggedIn: true,
            username: usernameMatch[1].trim(),
            registry: "https://index.docker.io/v1/",
          };
        }
        
        logger.debug('Docker login command check failed:', errorStr);
      }

      // Fallback method 1: Try docker info 
      try {
        const { stdout } = await execAsync("docker info");
        let usernameMatch = stdout.match(/\[Username:\s*([^\]]+)\]/); // New format
        if (!usernameMatch) {
          usernameMatch = stdout.match(/Username:\s*(.+)/); // Old format
        }
        
        if (usernameMatch) {
          return {
            isLoggedIn: true,
            username: usernameMatch[1].trim(),
            registry: "https://index.docker.io/v1/",
          };
        }
      } catch (infoError) {
        logger.debug('Docker info check failed:', infoError instanceof Error ? infoError.message : String(infoError));
      }
      
      // Fallback method 2: Check Docker config file and test authentication
      try {
        const configPath = join(homedir(), '.docker', 'config.json');
        const configContent = await readFile(configPath, 'utf-8');
        const config = JSON.parse(configContent);
        
        // Check if logged into Docker Hub
        if (config.auths && (config.auths['https://index.docker.io/v1/'] || config.auths['index.docker.io'])) {
          // Check if using credential store (common with Docker Desktop)
          const usingCredStore = config.credsStore || config.credHelpers;
          
          if (usingCredStore) {
            // When using credential store, test authentication by pulling a small image
            try {
              await execAsync('docker pull hello-world:latest', { timeout: 10000 });
              
              // We're authenticated but can't easily get username from credential store
              // Return with null username to signal that it needs to be provided
              return {
                isLoggedIn: true,
                username: null, // Will be handled by calling code
                registry: "https://index.docker.io/v1/",
              };
            } catch (pullError) {
              logger.debug('Docker Hub auth test failed:', pullError instanceof Error ? pullError.message : String(pullError));
              return { isLoggedIn: false };
            }
          } else {
            // Not using credential store, check for auth token
            const auth = config.auths['https://index.docker.io/v1/'] || config.auths['index.docker.io'];
            if (auth && auth.auth) {
              // Decode base64 auth to get username
              const decoded = Buffer.from(auth.auth, 'base64').toString('utf-8');
              const [username] = decoded.split(':');
              if (username) {
                return {
                  isLoggedIn: true,
                  username: username,
                  registry: "https://index.docker.io/v1/",
                };
              }
            }
          }
        }
      } catch (configError) {
        logger.debug('Config check failed:', configError instanceof Error ? configError.message : String(configError));
      }
      
      return { isLoggedIn: false };
    } catch (error) {
      logger.debug("Docker login check failed", error);
      return { isLoggedIn: false };
    }
  }

  /**
   * Check if a local Docker image exists
   */
  async checkLocalImage(tag: string): Promise<boolean> {
    try {
      const { stdout } = await execAsync(`docker images -q ${tag}`);
      return stdout.trim().length > 0;
    } catch {
      return false;
    }
  }

  /**
   * Pull a Docker image with retry logic
   */
  async pullImage(image: string): Promise<void> {
    await retryWithBackoff(
      async () => {
        await execAsync(`docker pull ${image}`);
      },
      {
        attempts: this.config.retryAttempts,
        delayMs: this.config.retryDelayMs,
        logger: this.config.logger,
        context: `Pulling image ${image}`
      }
    );
  }

  /**
   * Build a Docker image from Dockerfile
   */
  async buildImage(dockerfilePath: string, tag: string, contextPath: string = "."): Promise<void> {
    const buildCommand = `docker build -t ${tag} -f ${dockerfilePath} ${contextPath}`;
    await execAsync(buildCommand, { timeout: 600000 }); // 10 minute timeout
  }

  /**
   * Tag a Docker image
   */
  async tagImage(source: string, target: string): Promise<void> {
    await execAsync(`docker tag ${source} ${target}`);
  }

  /**
   * Push a Docker image with retry logic
   */
  async pushImage(image: string): Promise<void> {
    await retryWithBackoff(
      async () => {
        await execAsync(`docker push ${image}`);
      },
      {
        attempts: this.config.retryAttempts,
        delayMs: this.config.retryDelayMs,
        logger: this.config.logger,
        context: `Pushing image ${image}`
      }
    );
  }

  /**
   * Get list of local Docker images
   */
  async listImages(filter?: string): Promise<string[]> {
    const safeFilter = filter ? this.sanitizeImageName(filter) : '';
    const command = safeFilter ? `docker images "${safeFilter}" --format "{{.Repository}}:{{.Tag}}"` : 'docker images --format "{{.Repository}}:{{.Tag}}"';
    const { stdout } = await execAsync(command, { timeout: 30000 });
    return stdout.trim().split('\n').filter(line => line.trim());
  }

  /**
   * Remove a Docker image
   */
  async removeImage(tag: string, force: boolean = false): Promise<void> {
    const safeTag = this.sanitizeImageName(tag);
    const command = force ? `docker rmi -f "${safeTag}"` : `docker rmi "${safeTag}"`;
    await execAsync(command, { timeout: 30000 });
  }
}


================================================
FILE: packages/sdk/src/services/index.ts
================================================
/**
 * Services Module
 * 
 * Provides provider-agnostic infrastructure services for VibeKit including
 * Docker client operations and configuration management.
 */

export { DockerClient, type DockerLoginInfo, type DockerClientConfig } from './docker-client';
export { ConfigManager, type VibeKitConfig, type ConfigManagerOptions, type AgentType } from './config-manager';



================================================
FILE: templates/auth/README.md
================================================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.



================================================
FILE: templates/auth/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: templates/auth/eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;



================================================
FILE: templates/auth/next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;



================================================
FILE: templates/auth/package.json
================================================
{
  "name": "auth",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.2.0",
    "@radix-ui/react-accordion": "^1.2.11",
    "@radix-ui/react-alert-dialog": "^1.1.14",
    "@radix-ui/react-aspect-ratio": "^1.1.7",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.2",
    "@radix-ui/react-collapsible": "^1.1.11",
    "@radix-ui/react-context-menu": "^2.2.15",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-hover-card": "^1.1.14",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-menubar": "^1.1.15",
    "@radix-ui/react-navigation-menu": "^1.2.13",
    "@radix-ui/react-popover": "^1.1.14",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.3.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slider": "^1.3.5",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-toggle": "^1.1.9",
    "@radix-ui/react-toggle-group": "^1.1.10",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@vibe-kit/auth": "^0.0.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "date-fns": "^4.1.0",
    "embla-carousel-react": "^8.6.0",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.526.0",
    "next": "15.4.4",
    "next-themes": "^0.4.6",
    "react": "19.1.0",
    "react-day-picker": "^9.8.1",
    "react-dom": "19.1.0",
    "react-hook-form": "^7.61.1",
    "react-resizable-panels": "^3.0.3",
    "recharts": "^2.15.4",
    "sonner": "^2.0.6",
    "tailwind-merge": "^3.3.1",
    "vaul": "^1.1.2",
    "zod": "^4.0.10"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.4.4",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.6",
    "typescript": "^5"
  }
}



================================================
FILE: templates/auth/postcss.config.mjs
================================================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;



================================================
FILE: templates/auth/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: templates/auth/app/globals.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}



================================================
FILE: templates/auth/app/layout.tsx
================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "VibeKit Auth",
  description:
    "Authentication system for fetching Max subscription plan for Claude, Gemini, Grok and ChatGPT.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}



================================================
FILE: templates/auth/app/page.tsx
================================================
"use client";

import Image from "next/image";
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { ExternalLink, Copy, Check } from "lucide-react";
import { ClaudeWebAuth, LocalStorageTokenStorage } from "@vibe-kit/auth";
import { completeAuthentication } from "./actions/auth";

export default function AuthExample() {
  const [authUrl, setAuthUrl] = useState("");
  const [authCode, setAuthCode] = useState("");
  const [accessToken, setAccessToken] = useState("");
  const [loading, setLoading] = useState(false);
  const [copied, setCopied] = useState(false);
  const [authState, setAuthState] = useState("");
  const [codeVerifier, setCodeVerifier] = useState("");

  const startAuth = async () => {
    try {
      const {
        url,
        state,
        codeVerifier: verifier,
      } = await ClaudeWebAuth.createAuthorizationUrl();

      setAuthUrl(url);
      setAuthState(state);
      setCodeVerifier(verifier);

      // Open in new tab
      window.open(url, "_blank");
    } catch {
      alert(
        "Failed to start authentication. Make sure Web Crypto API is available."
      );
    }
  };

  const completeAuth = async () => {
    if (!authCode || !authState || !codeVerifier) return;

    setLoading(true);
    try {
      // Call the server action to complete authentication (avoids CORS issues)
      const result = await completeAuthentication(
        authCode,
        codeVerifier,
        authState
      );

      if (result.success && result.token) {
        // Store the token in localStorage on the client side
        const storage = new LocalStorageTokenStorage("claude_oauth_demo");
        await storage.set({
          access_token: result.token,
          token_type: "bearer",
          expires_in: 3600, // Default expiration
          refresh_token: "", // We'll handle refresh separately if needed
          created_at: Date.now(), // Required property for OAuthToken
        });

        setAccessToken(result.token);
      } else {
        alert(`Authentication failed: ${result.error || "Unknown error"}`);
      }
    } catch (error) {
      if (error instanceof Error) {
        alert(`Authentication failed: ${error.message}`);
      } else {
        alert("Authentication failed: Unknown error");
      }
    } finally {
      setLoading(false);
    }
  };

  const copyToken = () => {
    navigator.clipboard.writeText(accessToken);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const resetDemo = () => {
    setAuthUrl("");
    setAuthCode("");
    setAccessToken("");
    setAuthState("");
    setCodeVerifier("");
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 dark:from-slate-900 dark:to-slate-800 p-4">
      <div className="max-w-2xl mx-auto py-8 flex-col flex gap-y-8">
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-slate-900 dark:text-slate-100 mb-2">
            VibeKit Auth Demo
          </h1>
          <p className="text-slate-600 dark:text-slate-400">
            Authenticate with your Claude MAX subscription using @vibe-kit/auth
          </p>
        </div>
        <Card>
          <CardHeader>
            <CardTitle>How it works</CardTitle>
          </CardHeader>
          <CardContent className="space-y-3 text-sm text-slate-600 dark:text-slate-400">
            <p>
              1. <strong>Start OAuth:</strong> Generate authorization URL and
              open Claude&apos;s auth page
            </p>
            <p>
              2. <strong>User Authorization:</strong> User clicks
              &quot;Authorize&quot; and copies the authentication code
            </p>
            <p>
              3. <strong>Token Exchange:</strong> Exchange the code for an
              access token using PKCE
            </p>
            <p>
              4. <strong>Use Token:</strong> Pass the token in Authorization
              header for Claude API calls
            </p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              Step 1: Start Authentication
              {!authUrl && <Badge variant="outline">Ready</Badge>}
              {authUrl && !accessToken && (
                <Badge variant="secondary">In Progress</Badge>
              )}
              {accessToken && <Badge variant="default">Complete</Badge>}
            </CardTitle>
            <CardDescription>
              Click the button below to start the OAuth flow with Claude
            </CardDescription>
          </CardHeader>
          <CardContent>
            {!authUrl ? (
              <Button
                onClick={startAuth}
                className="w-full bg-[#d97757]"
                size="lg"
              >
                <Image
                  src="/claude.svg"
                  alt="Claude"
                  width={20}
                  height={20}
                  className="filter brightness-0 invert"
                />
                Login with Claude
              </Button>
            ) : (
              <div className="space-y-4">
                <div className="p-4 bg-blue-50 dark:bg-blue-950 rounded-lg">
                  <p className="text-sm text-blue-800 dark:text-blue-200 mb-2">
                    âœ… Authentication page opened in new tab
                  </p>
                  <p className="text-xs text-blue-600 dark:text-blue-400">
                    If the page didn&apos;t open,{" "}
                    <a href={authUrl} target="_blank" className="underline">
                      click here
                    </a>
                  </p>
                </div>
              </div>
            )}
          </CardContent>
        </Card>
        {authUrl && !accessToken && (
          <Card className="mb-6">
            <CardHeader>
              <CardTitle>Step 2: Enter Authentication Code</CardTitle>
              <CardDescription>
                After clicking &quot;Authorize&quot; in Claude, copy and paste
                the authentication code below
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <label className="text-sm font-medium text-slate-700 dark:text-slate-300 mb-2 block">
                  Authentication Code (format: code#state)
                </label>
                <Input
                  placeholder="Paste your authentication code here"
                  value={authCode}
                  onChange={(e) => setAuthCode(e.target.value)}
                  className="font-mono text-lg"
                />
              </div>
              <Button
                onClick={completeAuth}
                disabled={!authCode || loading}
                className="w-full bg-[#d97757]"
                size="lg"
              >
                <Image
                  src="/claude.svg"
                  alt="Claude"
                  width={20}
                  height={20}
                  className="filter brightness-0 invert"
                />
                {loading ? "Authenticating..." : "Complete Authentication"}
              </Button>
            </CardContent>
          </Card>
        )}
        {accessToken && (
          <Card className="mb-6">
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                Success! ðŸŽ‰
                <Badge variant="default">Authenticated</Badge>
              </CardTitle>
              <CardDescription>
                You&apos;re now authenticated with your Claude MAX subscription.
                Here&apos;s your access token:
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div>
                <label className="text-sm font-medium text-slate-700 dark:text-slate-300 mb-2 block">
                  MAX Subscription Access Token
                </label>
                <div className="flex gap-2">
                  <Input
                    value={accessToken}
                    readOnly
                    type="password"
                    className="font-mono text-xs"
                  />
                  <Button variant="outline" size="icon" onClick={copyToken}>
                    {copied ? (
                      <Check className="h-4 w-4" />
                    ) : (
                      <Copy className="h-4 w-4" />
                    )}
                  </Button>
                </div>
              </div>

              <div className="p-4 bg-green-50 dark:bg-green-950 rounded-lg">
                <h4 className="font-medium text-green-800 dark:text-green-200 mb-2">
                  Next Steps:
                </h4>
                <ul className="text-sm text-green-700 dark:text-green-300 space-y-1">
                  <li>
                    â€¢ Use this token to access your MAX subscription models
                  </li>
                  <li>â€¢ Higher rate limits than pay-per-use APIs</li>
                  <li>
                    â€¢ Access to latest Claude models with your subscription
                  </li>
                  <li>â€¢ Token auto-refreshes when needed</li>
                </ul>
              </div>

              <div className="border-t pt-4">
                <h4 className="font-medium text-slate-700 dark:text-slate-300 mb-2">
                  Use with Claude Code CLI:
                </h4>
                <pre className="bg-slate-100 dark:bg-slate-800 p-3 rounded-lg text-xs overflow-x-auto">
                  {`export CLAUDE_CODE_OAUTH_TOKEN=${accessToken}
claude -p 'hi'`}
                </pre>
              </div>

              <Button onClick={resetDemo} variant="outline" className="w-full">
                Try Again
              </Button>
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  );
}



================================================
FILE: templates/auth/app/actions/auth.ts
================================================
"use server";

import { ClaudeWebAuth } from "@vibe-kit/auth";

export async function completeAuthentication(
  authCode: string,
  codeVerifier: string,
  authState: string
): Promise<{ success: boolean; token?: string; error?: string }> {
  try {
    // Use the static method to exchange code for token (no storage needed on server)
    const result = await ClaudeWebAuth.exchangeCodeForToken(
      authCode,
      codeVerifier,
      authState
    );

    if (result.access_token) {
      return {
        success: true,
        token: result.access_token,
      };
    } else {
      return {
        success: false,
        error: "Failed to obtain access token",
      };
    }
  } catch (error) {
    console.error("Authentication error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error occurred",
    };
  }
}



================================================
FILE: templates/auth/components/ui/accordion.tsx
================================================
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }



================================================
FILE: templates/auth/components/ui/alert-dialog.tsx
================================================
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}



================================================
FILE: templates/auth/components/ui/alert.tsx
================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }



================================================
FILE: templates/auth/components/ui/aspect-ratio.tsx
================================================
"use client"

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

function AspectRatio({
  ...props
}: React.ComponentProps<typeof AspectRatioPrimitive.Root>) {
  return <AspectRatioPrimitive.Root data-slot="aspect-ratio" {...props} />
}

export { AspectRatio }



================================================
FILE: templates/auth/components/ui/avatar.tsx
================================================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }



================================================
FILE: templates/auth/components/ui/badge.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }



================================================
FILE: templates/auth/components/ui/breadcrumb.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className
      )}
      {...props}
    />
  )
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  )
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  )
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  )
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  )
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  )
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}



================================================
FILE: templates/auth/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: templates/auth/components/ui/calendar.tsx
================================================
"use client"

import * as React from "react"
import {
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from "lucide-react"
import { DayButton, DayPicker, getDefaultClassNames } from "react-day-picker"

import { cn } from "@/lib/utils"
import { Button, buttonVariants } from "@/components/ui/button"

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  captionLayout = "label",
  buttonVariant = "ghost",
  formatters,
  components,
  ...props
}: React.ComponentProps<typeof DayPicker> & {
  buttonVariant?: React.ComponentProps<typeof Button>["variant"]
}) {
  const defaultClassNames = getDefaultClassNames()

  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn(
        "bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent",
        String.raw`rtl:**:[.rdp-button\_next>svg]:rotate-180`,
        String.raw`rtl:**:[.rdp-button\_previous>svg]:rotate-180`,
        className
      )}
      captionLayout={captionLayout}
      formatters={{
        formatMonthDropdown: (date) =>
          date.toLocaleString("default", { month: "short" }),
        ...formatters,
      }}
      classNames={{
        root: cn("w-fit", defaultClassNames.root),
        months: cn(
          "flex gap-4 flex-col md:flex-row relative",
          defaultClassNames.months
        ),
        month: cn("flex flex-col w-full gap-4", defaultClassNames.month),
        nav: cn(
          "flex items-center gap-1 w-full absolute top-0 inset-x-0 justify-between",
          defaultClassNames.nav
        ),
        button_previous: cn(
          buttonVariants({ variant: buttonVariant }),
          "size-(--cell-size) aria-disabled:opacity-50 p-0 select-none",
          defaultClassNames.button_previous
        ),
        button_next: cn(
          buttonVariants({ variant: buttonVariant }),
          "size-(--cell-size) aria-disabled:opacity-50 p-0 select-none",
          defaultClassNames.button_next
        ),
        month_caption: cn(
          "flex items-center justify-center h-(--cell-size) w-full px-(--cell-size)",
          defaultClassNames.month_caption
        ),
        dropdowns: cn(
          "w-full flex items-center text-sm font-medium justify-center h-(--cell-size) gap-1.5",
          defaultClassNames.dropdowns
        ),
        dropdown_root: cn(
          "relative has-focus:border-ring border border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] rounded-md",
          defaultClassNames.dropdown_root
        ),
        dropdown: cn(
          "absolute bg-popover inset-0 opacity-0",
          defaultClassNames.dropdown
        ),
        caption_label: cn(
          "select-none font-medium",
          captionLayout === "label"
            ? "text-sm"
            : "rounded-md pl-2 pr-1 flex items-center gap-1 text-sm h-8 [&>svg]:text-muted-foreground [&>svg]:size-3.5",
          defaultClassNames.caption_label
        ),
        table: "w-full border-collapse",
        weekdays: cn("flex", defaultClassNames.weekdays),
        weekday: cn(
          "text-muted-foreground rounded-md flex-1 font-normal text-[0.8rem] select-none",
          defaultClassNames.weekday
        ),
        week: cn("flex w-full mt-2", defaultClassNames.week),
        week_number_header: cn(
          "select-none w-(--cell-size)",
          defaultClassNames.week_number_header
        ),
        week_number: cn(
          "text-[0.8rem] select-none text-muted-foreground",
          defaultClassNames.week_number
        ),
        day: cn(
          "relative w-full h-full p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md group/day aspect-square select-none",
          defaultClassNames.day
        ),
        range_start: cn(
          "rounded-l-md bg-accent",
          defaultClassNames.range_start
        ),
        range_middle: cn("rounded-none", defaultClassNames.range_middle),
        range_end: cn("rounded-r-md bg-accent", defaultClassNames.range_end),
        today: cn(
          "bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none",
          defaultClassNames.today
        ),
        outside: cn(
          "text-muted-foreground aria-selected:text-muted-foreground",
          defaultClassNames.outside
        ),
        disabled: cn(
          "text-muted-foreground opacity-50",
          defaultClassNames.disabled
        ),
        hidden: cn("invisible", defaultClassNames.hidden),
        ...classNames,
      }}
      components={{
        Root: ({ className, rootRef, ...props }) => {
          return (
            <div
              data-slot="calendar"
              ref={rootRef}
              className={cn(className)}
              {...props}
            />
          )
        },
        Chevron: ({ className, orientation, ...props }) => {
          if (orientation === "left") {
            return (
              <ChevronLeftIcon className={cn("size-4", className)} {...props} />
            )
          }

          if (orientation === "right") {
            return (
              <ChevronRightIcon
                className={cn("size-4", className)}
                {...props}
              />
            )
          }

          return (
            <ChevronDownIcon className={cn("size-4", className)} {...props} />
          )
        },
        DayButton: CalendarDayButton,
        WeekNumber: ({ children, ...props }) => {
          return (
            <td {...props}>
              <div className="flex size-(--cell-size) items-center justify-center text-center">
                {children}
              </div>
            </td>
          )
        },
        ...components,
      }}
      {...props}
    />
  )
}

function CalendarDayButton({
  className,
  day,
  modifiers,
  ...props
}: React.ComponentProps<typeof DayButton>) {
  const defaultClassNames = getDefaultClassNames()

  const ref = React.useRef<HTMLButtonElement>(null)
  React.useEffect(() => {
    if (modifiers.focused) ref.current?.focus()
  }, [modifiers.focused])

  return (
    <Button
      ref={ref}
      variant="ghost"
      size="icon"
      data-day={day.date.toLocaleDateString()}
      data-selected-single={
        modifiers.selected &&
        !modifiers.range_start &&
        !modifiers.range_end &&
        !modifiers.range_middle
      }
      data-range-start={modifiers.range_start}
      data-range-end={modifiers.range_end}
      data-range-middle={modifiers.range_middle}
      className={cn(
        "data-[selected-single=true]:bg-primary data-[selected-single=true]:text-primary-foreground data-[range-middle=true]:bg-accent data-[range-middle=true]:text-accent-foreground data-[range-start=true]:bg-primary data-[range-start=true]:text-primary-foreground data-[range-end=true]:bg-primary data-[range-end=true]:text-primary-foreground group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-ring/50 dark:hover:text-accent-foreground flex aspect-square size-auto w-full min-w-(--cell-size) flex-col gap-1 leading-none font-normal group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:ring-[3px] data-[range-end=true]:rounded-md data-[range-end=true]:rounded-r-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md data-[range-start=true]:rounded-l-md [&>span]:text-xs [&>span]:opacity-70",
        defaultClassNames.day,
        className
      )}
      {...props}
    />
  )
}

export { Calendar, CalendarDayButton }



================================================
FILE: templates/auth/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}



================================================
FILE: templates/auth/components/ui/carousel.tsx
================================================
"use client"

import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

function Carousel({
  orientation = "horizontal",
  opts,
  setApi,
  plugins,
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & CarouselProps) {
  const [carouselRef, api] = useEmblaCarousel(
    {
      ...opts,
      axis: orientation === "horizontal" ? "x" : "y",
    },
    plugins
  )
  const [canScrollPrev, setCanScrollPrev] = React.useState(false)
  const [canScrollNext, setCanScrollNext] = React.useState(false)

  const onSelect = React.useCallback((api: CarouselApi) => {
    if (!api) return
    setCanScrollPrev(api.canScrollPrev())
    setCanScrollNext(api.canScrollNext())
  }, [])

  const scrollPrev = React.useCallback(() => {
    api?.scrollPrev()
  }, [api])

  const scrollNext = React.useCallback(() => {
    api?.scrollNext()
  }, [api])

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (event.key === "ArrowLeft") {
        event.preventDefault()
        scrollPrev()
      } else if (event.key === "ArrowRight") {
        event.preventDefault()
        scrollNext()
      }
    },
    [scrollPrev, scrollNext]
  )

  React.useEffect(() => {
    if (!api || !setApi) return
    setApi(api)
  }, [api, setApi])

  React.useEffect(() => {
    if (!api) return
    onSelect(api)
    api.on("reInit", onSelect)
    api.on("select", onSelect)

    return () => {
      api?.off("select", onSelect)
    }
  }, [api, onSelect])

  return (
    <CarouselContext.Provider
      value={{
        carouselRef,
        api: api,
        opts,
        orientation:
          orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
        scrollPrev,
        scrollNext,
        canScrollPrev,
        canScrollNext,
      }}
    >
      <div
        onKeyDownCapture={handleKeyDown}
        className={cn("relative", className)}
        role="region"
        aria-roledescription="carousel"
        data-slot="carousel"
        {...props}
      >
        {children}
      </div>
    </CarouselContext.Provider>
  )
}

function CarouselContent({ className, ...props }: React.ComponentProps<"div">) {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div
      ref={carouselRef}
      className="overflow-hidden"
      data-slot="carousel-content"
    >
      <div
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CarouselItem({ className, ...props }: React.ComponentProps<"div">) {
  const { orientation } = useCarousel()

  return (
    <div
      role="group"
      aria-roledescription="slide"
      data-slot="carousel-item"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
}

function CarouselPrevious({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      data-slot="carousel-previous"
      variant={variant}
      size={size}
      className={cn(
        "absolute size-8 rounded-full",
        orientation === "horizontal"
          ? "top-1/2 -left-12 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
}

function CarouselNext({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      data-slot="carousel-next"
      variant={variant}
      size={size}
      className={cn(
        "absolute size-8 rounded-full",
        orientation === "horizontal"
          ? "top-1/2 -right-12 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight />
      <span className="sr-only">Next slide</span>
    </Button>
  )
}

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}



================================================
FILE: templates/auth/components/ui/chart.tsx
================================================
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

function ChartContainer({
  id,
  className,
  children,
  config,
  ...props
}: React.ComponentProps<"div"> & {
  config: ChartConfig
  children: React.ComponentProps<
    typeof RechartsPrimitive.ResponsiveContainer
  >["children"]
}) {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-slot="chart"
        data-chart={chartId}
        className={cn(
          "[&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border flex aspect-video justify-center text-xs [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-sector]:outline-hidden [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-surface]:outline-hidden",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
}

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

function ChartTooltipContent({
  active,
  payload,
  className,
  indicator = "dot",
  hideLabel = false,
  hideIndicator = false,
  label,
  labelFormatter,
  labelClassName,
  formatter,
  color,
  nameKey,
  labelKey,
}: React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
  React.ComponentProps<"div"> & {
    hideLabel?: boolean
    hideIndicator?: boolean
    indicator?: "line" | "dot" | "dashed"
    nameKey?: string
    labelKey?: string
  }) {
  const { config } = useChart()

  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) {
      return null
    }

    const [item] = payload
    const key = `${labelKey || item?.dataKey || item?.name || "value"}`
    const itemConfig = getPayloadConfigFromPayload(config, item, key)
    const value =
      !labelKey && typeof label === "string"
        ? config[label as keyof typeof config]?.label || label
        : itemConfig?.label

    if (labelFormatter) {
      return (
        <div className={cn("font-medium", labelClassName)}>
          {labelFormatter(value, payload)}
        </div>
      )
    }

    if (!value) {
      return null
    }

    return <div className={cn("font-medium", labelClassName)}>{value}</div>
  }, [
    label,
    labelFormatter,
    payload,
    hideLabel,
    labelClassName,
    config,
    labelKey,
  ])

  if (!active || !payload?.length) {
    return null
  }

  const nestLabel = payload.length === 1 && indicator !== "dot"

  return (
    <div
      className={cn(
        "border-border/50 bg-background grid min-w-[8rem] items-start gap-1.5 rounded-lg border px-2.5 py-1.5 text-xs shadow-xl",
        className
      )}
    >
      {!nestLabel ? tooltipLabel : null}
      <div className="grid gap-1.5">
        {payload.map((item, index) => {
          const key = `${nameKey || item.name || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)
          const indicatorColor = color || item.payload.fill || item.color

          return (
            <div
              key={item.dataKey}
              className={cn(
                "[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5",
                indicator === "dot" && "items-center"
              )}
            >
              {formatter && item?.value !== undefined && item.name ? (
                formatter(item.value, item.name, item, index, item.payload)
              ) : (
                <>
                  {itemConfig?.icon ? (
                    <itemConfig.icon />
                  ) : (
                    !hideIndicator && (
                      <div
                        className={cn(
                          "shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)",
                          {
                            "h-2.5 w-2.5": indicator === "dot",
                            "w-1": indicator === "line",
                            "w-0 border-[1.5px] border-dashed bg-transparent":
                              indicator === "dashed",
                            "my-0.5": nestLabel && indicator === "dashed",
                          }
                        )}
                        style={
                          {
                            "--color-bg": indicatorColor,
                            "--color-border": indicatorColor,
                          } as React.CSSProperties
                        }
                      />
                    )
                  )}
                  <div
                    className={cn(
                      "flex flex-1 justify-between leading-none",
                      nestLabel ? "items-end" : "items-center"
                    )}
                  >
                    <div className="grid gap-1.5">
                      {nestLabel ? tooltipLabel : null}
                      <span className="text-muted-foreground">
                        {itemConfig?.label || item.name}
                      </span>
                    </div>
                    {item.value && (
                      <span className="text-foreground font-mono font-medium tabular-nums">
                        {item.value.toLocaleString()}
                      </span>
                    )}
                  </div>
                </>
              )}
            </div>
          )
        })}
      </div>
    </div>
  )
}

const ChartLegend = RechartsPrimitive.Legend

function ChartLegendContent({
  className,
  hideIcon = false,
  payload,
  verticalAlign = "bottom",
  nameKey,
}: React.ComponentProps<"div"> &
  Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
    hideIcon?: boolean
    nameKey?: string
  }) {
  const { config } = useChart()

  if (!payload?.length) {
    return null
  }

  return (
    <div
      className={cn(
        "flex items-center justify-center gap-4",
        verticalAlign === "top" ? "pb-3" : "pt-3",
        className
      )}
    >
      {payload.map((item) => {
        const key = `${nameKey || item.dataKey || "value"}`
        const itemConfig = getPayloadConfigFromPayload(config, item, key)

        return (
          <div
            key={item.value}
            className={cn(
              "[&>svg]:text-muted-foreground flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3"
            )}
          >
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }}
              />
            )}
            {itemConfig?.label}
          </div>
        )
      })}
    </div>
  )
}

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}



================================================
FILE: templates/auth/components/ui/checkbox.tsx
================================================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }



================================================
FILE: templates/auth/components/ui/collapsible.tsx
================================================
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />
}

function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  )
}

function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  )
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent }



================================================
FILE: templates/auth/components/ui/command.tsx
================================================
"use client"

import * as React from "react"
import { Command as CommandPrimitive } from "cmdk"
import { SearchIcon } from "lucide-react"

import { cn } from "@/lib/utils"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        className
      )}
      {...props}
    />
  )
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  className,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string
  description?: string
  className?: string
  showCloseButton?: boolean
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent
        className={cn("overflow-hidden p-0", className)}
        showCloseButton={showCloseButton}
      >
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
        className
      )}
      {...props}
    />
  )
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  )
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
        className
      )}
      {...props}
    />
  )
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("bg-border -mx-1 h-px", className)}
      {...props}
    />
  )
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}



================================================
FILE: templates/auth/components/ui/context-menu.tsx
================================================
"use client"

import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />
}

function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  )
}

function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  )
}

function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  )
}

function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />
}

function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  )
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  )
}

function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-context-menu-content-available-height) min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  )
}

function ContextMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  )
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  )
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn(
        "text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}



================================================
FILE: templates/auth/components/ui/dialog.tsx
================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}



================================================
FILE: templates/auth/components/ui/drawer.tsx
================================================
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

function Drawer({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) {
  return <DrawerPrimitive.Root data-slot="drawer" {...props} />
}

function DrawerTrigger({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Trigger>) {
  return <DrawerPrimitive.Trigger data-slot="drawer-trigger" {...props} />
}

function DrawerPortal({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Portal>) {
  return <DrawerPrimitive.Portal data-slot="drawer-portal" {...props} />
}

function DrawerClose({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Close>) {
  return <DrawerPrimitive.Close data-slot="drawer-close" {...props} />
}

function DrawerOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Overlay>) {
  return (
    <DrawerPrimitive.Overlay
      data-slot="drawer-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DrawerContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Content>) {
  return (
    <DrawerPortal data-slot="drawer-portal">
      <DrawerOverlay />
      <DrawerPrimitive.Content
        data-slot="drawer-content"
        className={cn(
          "group/drawer-content bg-background fixed z-50 flex h-auto flex-col",
          "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg data-[vaul-drawer-direction=top]:border-b",
          "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg data-[vaul-drawer-direction=bottom]:border-t",
          "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:border-l data-[vaul-drawer-direction=right]:sm:max-w-sm",
          "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:border-r data-[vaul-drawer-direction=left]:sm:max-w-sm",
          className
        )}
        {...props}
      >
        <div className="bg-muted mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full group-data-[vaul-drawer-direction=bottom]/drawer-content:block" />
        {children}
      </DrawerPrimitive.Content>
    </DrawerPortal>
  )
}

function DrawerHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-header"
      className={cn(
        "flex flex-col gap-0.5 p-4 group-data-[vaul-drawer-direction=bottom]/drawer-content:text-center group-data-[vaul-drawer-direction=top]/drawer-content:text-center md:gap-1.5 md:text-left",
        className
      )}
      {...props}
    />
  )
}

function DrawerFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function DrawerTitle({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Title>) {
  return (
    <DrawerPrimitive.Title
      data-slot="drawer-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function DrawerDescription({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Description>) {
  return (
    <DrawerPrimitive.Description
      data-slot="drawer-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}



================================================
FILE: templates/auth/components/ui/dropdown-menu.tsx
================================================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}



================================================
FILE: templates/auth/components/ui/form.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}



================================================
FILE: templates/auth/components/ui/hover-card.tsx
================================================
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

function HoverCard({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Root>) {
  return <HoverCardPrimitive.Root data-slot="hover-card" {...props} />
}

function HoverCardTrigger({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Trigger>) {
  return (
    <HoverCardPrimitive.Trigger data-slot="hover-card-trigger" {...props} />
  )
}

function HoverCardContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Content>) {
  return (
    <HoverCardPrimitive.Portal data-slot="hover-card-portal">
      <HoverCardPrimitive.Content
        data-slot="hover-card-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 origin-(--radix-hover-card-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </HoverCardPrimitive.Portal>
  )
}

export { HoverCard, HoverCardTrigger, HoverCardContent }



================================================
FILE: templates/auth/components/ui/input-otp.tsx
================================================
"use client"

import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { MinusIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function InputOTP({
  className,
  containerClassName,
  ...props
}: React.ComponentProps<typeof OTPInput> & {
  containerClassName?: string
}) {
  return (
    <OTPInput
      data-slot="input-otp"
      containerClassName={cn(
        "flex items-center gap-2 has-disabled:opacity-50",
        containerClassName
      )}
      className={cn("disabled:cursor-not-allowed", className)}
      {...props}
    />
  )
}

function InputOTPGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="input-otp-group"
      className={cn("flex items-center", className)}
      {...props}
    />
  )
}

function InputOTPSlot({
  index,
  className,
  ...props
}: React.ComponentProps<"div"> & {
  index: number
}) {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext?.slots[index] ?? {}

  return (
    <div
      data-slot="input-otp-slot"
      data-active={isActive}
      className={cn(
        "data-[active=true]:border-ring data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:ring-destructive/20 dark:data-[active=true]:aria-invalid:ring-destructive/40 aria-invalid:border-destructive data-[active=true]:aria-invalid:border-destructive dark:bg-input/30 border-input relative flex h-9 w-9 items-center justify-center border-y border-r text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md data-[active=true]:z-10 data-[active=true]:ring-[3px]",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink bg-foreground h-4 w-px duration-1000" />
        </div>
      )}
    </div>
  )
}

function InputOTPSeparator({ ...props }: React.ComponentProps<"div">) {
  return (
    <div data-slot="input-otp-separator" role="separator" {...props}>
      <MinusIcon />
    </div>
  )
}

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }



================================================
FILE: templates/auth/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }



================================================
FILE: templates/auth/components/ui/label.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }



================================================
FILE: templates/auth/components/ui/menubar.tsx
================================================
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Menubar({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Root>) {
  return (
    <MenubarPrimitive.Root
      data-slot="menubar"
      className={cn(
        "bg-background flex h-9 items-center gap-1 rounded-md border p-1 shadow-xs",
        className
      )}
      {...props}
    />
  )
}

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu data-slot="menubar-menu" {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group data-slot="menubar-group" {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal data-slot="menubar-portal" {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return (
    <MenubarPrimitive.RadioGroup data-slot="menubar-radio-group" {...props} />
  )
}

function MenubarTrigger({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Trigger>) {
  return (
    <MenubarPrimitive.Trigger
      data-slot="menubar-trigger"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex items-center rounded-sm px-2 py-1 text-sm font-medium outline-hidden select-none",
        className
      )}
      {...props}
    />
  )
}

function MenubarContent({
  className,
  align = "start",
  alignOffset = -4,
  sideOffset = 8,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Content>) {
  return (
    <MenubarPortal>
      <MenubarPrimitive.Content
        data-slot="menubar-content"
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[12rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </MenubarPortal>
  )
}

function MenubarItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <MenubarPrimitive.Item
      data-slot="menubar-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function MenubarCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.CheckboxItem>) {
  return (
    <MenubarPrimitive.CheckboxItem
      data-slot="menubar-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.CheckboxItem>
  )
}

function MenubarRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioItem>) {
  return (
    <MenubarPrimitive.RadioItem
      data-slot="menubar-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.RadioItem>
  )
}

function MenubarLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.Label
      data-slot="menubar-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function MenubarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Separator>) {
  return (
    <MenubarPrimitive.Separator
      data-slot="menubar-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function MenubarShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="menubar-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

function MenubarSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.SubTrigger
      data-slot="menubar-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto h-4 w-4" />
    </MenubarPrimitive.SubTrigger>
  )
}

function MenubarSubContent({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubContent>) {
  return (
    <MenubarPrimitive.SubContent
      data-slot="menubar-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  Menubar,
  MenubarPortal,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarGroup,
  MenubarSeparator,
  MenubarLabel,
  MenubarItem,
  MenubarShortcut,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSub,
  MenubarSubTrigger,
  MenubarSubContent,
}



================================================
FILE: templates/auth/components/ui/navigation-menu.tsx
================================================
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function NavigationMenu({
  className,
  children,
  viewport = true,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Root> & {
  viewport?: boolean
}) {
  return (
    <NavigationMenuPrimitive.Root
      data-slot="navigation-menu"
      data-viewport={viewport}
      className={cn(
        "group/navigation-menu relative flex max-w-max flex-1 items-center justify-center",
        className
      )}
      {...props}
    >
      {children}
      {viewport && <NavigationMenuViewport />}
    </NavigationMenuPrimitive.Root>
  )
}

function NavigationMenuList({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.List>) {
  return (
    <NavigationMenuPrimitive.List
      data-slot="navigation-menu-list"
      className={cn(
        "group flex flex-1 list-none items-center justify-center gap-1",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuItem({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Item>) {
  return (
    <NavigationMenuPrimitive.Item
      data-slot="navigation-menu-item"
      className={cn("relative", className)}
      {...props}
    />
  )
}

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 outline-none transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1"
)

function NavigationMenuTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Trigger>) {
  return (
    <NavigationMenuPrimitive.Trigger
      data-slot="navigation-menu-trigger"
      className={cn(navigationMenuTriggerStyle(), "group", className)}
      {...props}
    >
      {children}{" "}
      <ChevronDownIcon
        className="relative top-[1px] ml-1 size-3 transition duration-300 group-data-[state=open]:rotate-180"
        aria-hidden="true"
      />
    </NavigationMenuPrimitive.Trigger>
  )
}

function NavigationMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Content>) {
  return (
    <NavigationMenuPrimitive.Content
      data-slot="navigation-menu-content"
      className={cn(
        "data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 top-0 left-0 w-full p-2 pr-2.5 md:absolute md:w-auto",
        "group-data-[viewport=false]/navigation-menu:bg-popover group-data-[viewport=false]/navigation-menu:text-popover-foreground group-data-[viewport=false]/navigation-menu:data-[state=open]:animate-in group-data-[viewport=false]/navigation-menu:data-[state=closed]:animate-out group-data-[viewport=false]/navigation-menu:data-[state=closed]:zoom-out-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:zoom-in-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:fade-in-0 group-data-[viewport=false]/navigation-menu:data-[state=closed]:fade-out-0 group-data-[viewport=false]/navigation-menu:top-full group-data-[viewport=false]/navigation-menu:mt-1.5 group-data-[viewport=false]/navigation-menu:overflow-hidden group-data-[viewport=false]/navigation-menu:rounded-md group-data-[viewport=false]/navigation-menu:border group-data-[viewport=false]/navigation-menu:shadow group-data-[viewport=false]/navigation-menu:duration-200 **:data-[slot=navigation-menu-link]:focus:ring-0 **:data-[slot=navigation-menu-link]:focus:outline-none",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuViewport({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Viewport>) {
  return (
    <div
      className={cn(
        "absolute top-full left-0 isolate z-50 flex justify-center"
      )}
    >
      <NavigationMenuPrimitive.Viewport
        data-slot="navigation-menu-viewport"
        className={cn(
          "origin-top-center bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border shadow md:w-[var(--radix-navigation-menu-viewport-width)]",
          className
        )}
        {...props}
      />
    </div>
  )
}

function NavigationMenuLink({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Link>) {
  return (
    <NavigationMenuPrimitive.Link
      data-slot="navigation-menu-link"
      className={cn(
        "data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus-visible:ring-ring/50 [&_svg:not([class*='text-'])]:text-muted-foreground flex flex-col gap-1 rounded-sm p-2 text-sm transition-all outline-none focus-visible:ring-[3px] focus-visible:outline-1 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuIndicator({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Indicator>) {
  return (
    <NavigationMenuPrimitive.Indicator
      data-slot="navigation-menu-indicator"
      className={cn(
        "data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden",
        className
      )}
      {...props}
    >
      <div className="bg-border relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm shadow-md" />
    </NavigationMenuPrimitive.Indicator>
  )
}

export {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
  navigationMenuTriggerStyle,
}



================================================
FILE: templates/auth/components/ui/pagination.tsx
================================================
import * as React from "react"
import {
  ChevronLeftIcon,
  ChevronRightIcon,
  MoreHorizontalIcon,
} from "lucide-react"

import { cn } from "@/lib/utils"
import { Button, buttonVariants } from "@/components/ui/button"

function Pagination({ className, ...props }: React.ComponentProps<"nav">) {
  return (
    <nav
      role="navigation"
      aria-label="pagination"
      data-slot="pagination"
      className={cn("mx-auto flex w-full justify-center", className)}
      {...props}
    />
  )
}

function PaginationContent({
  className,
  ...props
}: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="pagination-content"
      className={cn("flex flex-row items-center gap-1", className)}
      {...props}
    />
  )
}

function PaginationItem({ ...props }: React.ComponentProps<"li">) {
  return <li data-slot="pagination-item" {...props} />
}

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<React.ComponentProps<typeof Button>, "size"> &
  React.ComponentProps<"a">

function PaginationLink({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) {
  return (
    <a
      aria-current={isActive ? "page" : undefined}
      data-slot="pagination-link"
      data-active={isActive}
      className={cn(
        buttonVariants({
          variant: isActive ? "outline" : "ghost",
          size,
        }),
        className
      )}
      {...props}
    />
  )
}

function PaginationPrevious({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to previous page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pl-2.5", className)}
      {...props}
    >
      <ChevronLeftIcon />
      <span className="hidden sm:block">Previous</span>
    </PaginationLink>
  )
}

function PaginationNext({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to next page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pr-2.5", className)}
      {...props}
    >
      <span className="hidden sm:block">Next</span>
      <ChevronRightIcon />
    </PaginationLink>
  )
}

function PaginationEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      aria-hidden
      data-slot="pagination-ellipsis"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontalIcon className="size-4" />
      <span className="sr-only">More pages</span>
    </span>
  )
}

export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
}



================================================
FILE: templates/auth/components/ui/popover.tsx
================================================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }



================================================
FILE: templates/auth/components/ui/progress.tsx
================================================
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}

export { Progress }



================================================
FILE: templates/auth/components/ui/radio-group.tsx
================================================
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  )
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
}

export { RadioGroup, RadioGroupItem }



================================================
FILE: templates/auth/components/ui/resizable.tsx
================================================
"use client"

import * as React from "react"
import { GripVerticalIcon } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

function ResizablePanelGroup({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) {
  return (
    <ResizablePrimitive.PanelGroup
      data-slot="resizable-panel-group"
      className={cn(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        className
      )}
      {...props}
    />
  )
}

function ResizablePanel({
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.Panel>) {
  return <ResizablePrimitive.Panel data-slot="resizable-panel" {...props} />
}

function ResizableHandle({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) {
  return (
    <ResizablePrimitive.PanelResizeHandle
      data-slot="resizable-handle"
      className={cn(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:translate-x-0 data-[panel-group-direction=vertical]:after:-translate-y-1/2 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        className
      )}
      {...props}
    >
      {withHandle && (
        <div className="bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border">
          <GripVerticalIcon className="size-2.5" />
        </div>
      )}
    </ResizablePrimitive.PanelResizeHandle>
  )
}

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }



================================================
FILE: templates/auth/components/ui/scroll-area.tsx
================================================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }



================================================
FILE: templates/auth/components/ui/select.tsx
================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}



================================================
FILE: templates/auth/components/ui/separator.tsx
================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }



================================================
FILE: templates/auth/components/ui/sheet.tsx
================================================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}



================================================
FILE: templates/auth/components/ui/sidebar.tsx
================================================
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, VariantProps } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}



================================================
FILE: templates/auth/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: templates/auth/components/ui/slider.tsx
================================================
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }



================================================
FILE: templates/auth/components/ui/sonner.tsx
================================================
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }



================================================
FILE: templates/auth/components/ui/switch.tsx
================================================
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }



================================================
FILE: templates/auth/components/ui/table.tsx
================================================
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}



================================================
FILE: templates/auth/components/ui/tabs.tsx
================================================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: templates/auth/components/ui/textarea.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }



================================================
FILE: templates/auth/components/ui/toggle-group.tsx
================================================
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

function ToggleGroup({
  className,
  variant,
  size,
  children,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <ToggleGroupPrimitive.Root
      data-slot="toggle-group"
      data-variant={variant}
      data-size={size}
      className={cn(
        "group/toggle-group flex w-fit items-center rounded-md data-[variant=outline]:shadow-xs",
        className
      )}
      {...props}
    >
      <ToggleGroupContext.Provider value={{ variant, size }}>
        {children}
      </ToggleGroupContext.Provider>
    </ToggleGroupPrimitive.Root>
  )
}

function ToggleGroupItem({
  className,
  children,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Item> &
  VariantProps<typeof toggleVariants>) {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      data-slot="toggle-group-item"
      data-variant={context.variant || variant}
      data-size={context.size || size}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        "min-w-0 flex-1 shrink-0 rounded-none shadow-none first:rounded-l-md last:rounded-r-md focus:z-10 focus-visible:z-10 data-[variant=outline]:border-l-0 data-[variant=outline]:first:border-l",
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
}

export { ToggleGroup, ToggleGroupItem }



================================================
FILE: templates/auth/components/ui/toggle.tsx
================================================
"use client"

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-9 px-2 min-w-9",
        sm: "h-8 px-1.5 min-w-8",
        lg: "h-10 px-2.5 min-w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Toggle({
  className,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof TogglePrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <TogglePrimitive.Root
      data-slot="toggle"
      className={cn(toggleVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Toggle, toggleVariants }



================================================
FILE: templates/auth/components/ui/tooltip.tsx
================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



================================================
FILE: templates/auth/hooks/use-mobile.ts
================================================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}



================================================
FILE: templates/auth/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================
FILE: templates/cloudflare/package.json
================================================
{
	"name": "cloudflare",
	"version": "0.0.0",
	"private": true,
	"scripts": {
		"deploy": "wrangler deploy",
		"dev": "wrangler dev",
		"start": "wrangler dev",
		"cf-typegen": "wrangler types"
	},
	"devDependencies": {
		"typescript": "^5.5.2",
		"wrangler": "^4.26.0"
	},
	"dependencies": {
		"@vibe-kit/cloudflare": "^0.0.6",
		"@vibe-kit/sdk": "^0.0.55"
	}
}



================================================
FILE: templates/cloudflare/tsconfig.json
================================================
{
	"compilerOptions": {
		/* Visit https://aka.ms/tsconfig.json to read more about this file */

		/* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
		"target": "es2021",
		/* Specify a set of bundled library declaration files that describe the target runtime environment. */
		"lib": ["es2021"],
		/* Specify what JSX code is generated. */
		"jsx": "react-jsx",

		/* Specify what module code is generated. */
		"module": "es2022",
		/* Specify how TypeScript looks up a file from a given module specifier. */
		"moduleResolution": "Bundler",
		/* Enable importing .json files */
		"resolveJsonModule": true,

		/* Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. */
		"allowJs": true,
		/* Enable error reporting in type-checked JavaScript files. */
		"checkJs": false,

		/* Disable emitting files from a compilation. */
		"noEmit": true,

		/* Ensure that each file can be safely transpiled without relying on other imports. */
		"isolatedModules": true,
		/* Allow 'import x from y' when a module doesn't have a default export. */
		"allowSyntheticDefaultImports": true,
		/* Ensure that casing is correct in imports. */
		"forceConsistentCasingInFileNames": true,

		/* Enable all strict type-checking options. */
		"strict": true,

		/* Skip type checking all .d.ts files. */
		"skipLibCheck": true,
		"types": [
			"./worker-configuration.d.ts"
		]
	},
	"exclude": ["test"],
	"include": ["worker-configuration.d.ts", "src/**/*.ts"]
}



================================================
FILE: templates/cloudflare/wrangler.jsonc
================================================
/**
 * For more details on how to configure Wrangler, refer to:
 * https://developers.cloudflare.com/workers/wrangler/configuration/
 */
{
	"$schema": "node_modules/wrangler/config-schema.json",
	"name": "cloudflare",
	"main": "src/index.ts",
	"compatibility_date": "2025-07-26",
	"compatibility_flags": ["nodejs_compat"],
	"observability": {
		"enabled": true
	},
	"containers": [
		{
			"class_name": "Sandbox",
			"image": "./node_modules/@vibe-kit/cloudflare/Dockerfile",
			"max_instances": 1
		}
	],
	"durable_objects": {
		"bindings": [
			{
				"class_name": "Sandbox",
				"name": "Sandbox"
			}
		]
	},
	"migrations": [
		{
			"new_sqlite_classes": ["Sandbox"],
			"tag": "v1"
		}
	]
}



================================================
FILE: templates/cloudflare/.dev.vars.example
================================================
ANTHROPIC_API_KEY=xxxx



================================================
FILE: templates/cloudflare/.editorconfig
================================================
# http://editorconfig.org
root = true

[*]
indent_style = tab
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.yml]
indent_style = space



================================================
FILE: templates/cloudflare/.prettierrc
================================================
{
	"printWidth": 140,
	"singleQuote": true,
	"semi": true,
	"useTabs": true
}



================================================
FILE: templates/cloudflare/src/index.ts
================================================
import { proxyToSandbox } from "@cloudflare/sandbox";
import { createCloudflareProvider } from "@vibe-kit/cloudflare";
import { VibeKit } from "@vibe-kit/sdk";
export { Sandbox } from "@cloudflare/sandbox";

export default {
	async fetch(request, env): Promise<Response> {
		// @ts-ignore
		const proxyResponse = await proxyToSandbox(request, env);
		if (proxyResponse) return proxyResponse;

		// @ts-ignore
		const sandbox = createCloudflareProvider({ env: env, hostname: request.headers.get("host") });
		const vibeKit = new VibeKit()
			.withAgent({
				type: "claude",
				provider: "anthropic",
				apiKey: env.ANTHROPIC_API_KEY,
				model: "claude-sonnet-4-20250514",
			})
			.withSandbox(sandbox);

		// Set up event listeners
		// @ts-ignore
		vibeKit.on("update", (message) => console.log("Update:", message));
		// @ts-ignore
		vibeKit.on("error", (error) => console.error("Error:", error));

		await vibeKit.generateCode({
			prompt: "Run 'bun init -r' to create a new bun + react project, set default port 3001",
			mode: "code",
		});
		const previewUrl = await vibeKit.getHost(3001);

		return new Response(previewUrl);
	},
} satisfies ExportedHandler<Env>;



================================================
FILE: templates/codex-clone/README.md
================================================
# CloneDex

An OpenAI Codex clone built with Next.js, VibeKit SDK, and Inngest. This application allows you to generate code using AI models with real-time updates and GitHub integration.

## ðŸ”— Demo 

[https://clonedex.vercel.app/](https://clonedex.vercel.app/)

## âœ¨ Features

- ðŸ¤– AI-powered code generation using OpenAI
- ðŸ”„ Real-time task updates with Inngest
- ðŸ™ GitHub integration for repository management
- ðŸŒ E2B sandboxed environment execution
- ðŸŽ¨ Modern UI with Tailwind CSS and shadcn/ui
- ðŸ“ Markdown rendering with syntax highlighting
- ðŸ—ƒï¸ Zustand state management (easily replaceable with any remote database)

## ðŸš€ Prerequisites

Before you begin, make sure you have:

- **Node.js** (v18 or higher)
- **npm** or **yarn**
- **Inngest CLI** (required for local development)
- An **OpenAI API key**
- An **E2B API key**
- A **GitHub OAuth app** (for GitHub integration)

## ðŸ“¦ Installation

### 1. Install Dependencies

```bash
npm install
```

### 2. Install Inngest CLI

The Inngest CLI is essential for running background functions locally:

```bash
# Install globally
npm install -g inngest

# Or using npx (recommended)
npx inngest-cli@latest
```

### 3. Set Up Environment Variables

Create a `.env.local` file in the root directory with the following variables:

```bash
# OpenAI Configuration
OPENAI_API_KEY=your_openai_api_key_here

# E2B Configuration (for sandboxed environments)
E2B_API_KEY=your_e2b_api_key_here

# GitHub OAuth Configuration
GITHUB_CLIENT_ID=your_github_client_id
GITHUB_CLIENT_SECRET=your_github_client_secret
```

#### Getting API Keys:

- **OpenAI API Key**: Get it from [OpenAI Platform](https://platform.openai.com/api-keys)
- **E2B API Key**: Sign up at [E2B](https://e2b.dev/) and get your API key
- **GitHub OAuth**: Create a new OAuth app in your [GitHub Developer Settings](https://github.com/settings/developers)

## ðŸ› ï¸ Development

### 1. Start the Inngest Dev Server

In one terminal, start the Inngest development server:

```bash
npx inngest-cli@latest dev
```

This will start the Inngest development server on `http://localhost:8288`.

### 2. Start the Next.js Development Server

In another terminal, start the Next.js application:

```bash
npm run dev
```

The application will be available at `http://localhost:3000`.

## ðŸ“‹ Available Scripts

- `npm run dev` - Start the development server with Turbopack
- `npm run build` - Build the application for production
- `npm start` - Start the production server
- `npm run lint` - Run ESLint for code quality

## ðŸ—ï¸ Project Structure

```
â”œâ”€â”€ app/                    # Next.js App Router
â”‚   â”œâ”€â”€ _components/        # Page-specific components
â”‚   â”œâ”€â”€ actions/           # Server actions
â”‚   â”œâ”€â”€ api/               # API routes
â”‚   â””â”€â”€ auth/              # Authentication routes
â”œâ”€â”€ components/            # Reusable UI components
â”‚   â””â”€â”€ ui/                # shadcn/ui components
â”œâ”€â”€ hooks/                 # Custom React hooks
â”œâ”€â”€ lib/                   # Utility libraries and configurations
â”œâ”€â”€ stores/                # Zustand state management
â””â”€â”€ public/                # Static assets
```

## ðŸ”§ Configuration

### Inngest Functions

The application uses Inngest for background task processing. The main function is defined in `lib/inngest.ts`:

- **`createTask`**: Handles AI code generation with real-time updates
- **Task Channel**: Manages real-time communication for task status and updates

### VibeKit Integration

The app integrates with VibeKit SDK for AI code generation, supporting:

- Multiple AI models (currently OpenAI)
- E2B sandboxed environments
- GitHub repository integration
- Real-time streaming updates

## ðŸŒ Deployment

### Environment Variables for Production

Make sure to set all required environment variables in your production environment:

```bash
GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=
E2B_API_KEY=
OPENAI_API_KEY=
ANTHROPIC_API_KEY=
```

### Deploy to Vercel

1. Connect your repository to Vercel
2. Set the environment variables in the Vercel dashboard
3. Deploy

### Inngest in Production

For production, you'll need to configure Inngest properly:

1. Set up an Inngest account at [inngest.com](https://inngest.com)
2. Configure your production Inngest endpoint
3. Update your deployment to use the production Inngest configuration

## ðŸ¤ Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## ðŸ“„ License

This project is licensed under the MIT License.

## ðŸ†˜ Troubleshooting

### Common Issues

1. **Inngest functions not working**: Make sure the Inngest CLI is running (`npx inngest-cli@latest dev`)
2. **API key errors**: Verify all environment variables are set correctly
3. **GitHub OAuth issues**: Check your GitHub OAuth app configuration and callback URLs
4. **E2B connection problems**: Ensure your E2B API key is valid and has sufficient credits

### Getting Help

- Check the [Inngest Documentation](https://www.inngest.com/docs)
- Visit [VibeKit Documentation](https://vibekit.dev/docs)
- Review [Next.js Documentation](https://nextjs.org/docs)

---

Built with â¤ï¸ using Next.js, VibeKit, and Inngest



================================================
FILE: templates/codex-clone/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: templates/codex-clone/eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;



================================================
FILE: templates/codex-clone/next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;



================================================
FILE: templates/codex-clone/package.json
================================================
{
  "name": "codex-clone",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.3.22",
    "@inngest/realtime": "^0.3.1",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@vibe-kit/sdk": "^0.0.21",
    "ai": "^4.3.16",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "framer-motion": "^12.16.0",
    "inngest": "^3.39.1",
    "lucide-react": "^0.513.0",
    "next": "15.3.3",
    "next-themes": "^0.4.6",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-markdown": "^10.1.0",
    "react-syntax-highlighter": "^15.6.1",
    "rehype-raw": "^7.0.0",
    "remark-gfm": "^4.0.1",
    "tailwind-merge": "^3.3.0",
    "zod": "^3.25.56",
    "zustand": "^5.0.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/react-syntax-highlighter": "^15.5.13",
    "eslint": "^9",
    "eslint-config-next": "15.3.3",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.4",
    "typescript": "^5"
  }
}



================================================
FILE: templates/codex-clone/postcss.config.mjs
================================================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;



================================================
FILE: templates/codex-clone/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: templates/codex-clone/.env.example
================================================
#Github OAuth app credentials
GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=

# Sandbox
E2B_API_KEY=

# If using Codex
OPENAI_API_KEY=

# If using Claude Code
ANTHROPIC_API_KEY=


================================================
FILE: templates/codex-clone/app/client-page.tsx
================================================
"use client";

import Navbar from "@/components/navbar";
import TaskList from "./_components/task-list";
import TaskForm from "./_components/task-form";

export default function ClientPage() {
  return (
    <div className="flex flex-col px-4 py-2 h-screen gap-y-4">
      <Navbar />
      <TaskForm />
      <TaskList />
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/container.tsx
================================================
"use client";
import { useInngestSubscription } from "@inngest/realtime/hooks";
import { useEffect } from "react";

import { fetchRealtimeSubscriptionToken } from "@/app/actions/inngest";
import { useTaskStore } from "@/stores/tasks";

export default function Container({ children }: { children: React.ReactNode }) {
  const { updateTask, getTaskById } = useTaskStore();
  const { latestData } = useInngestSubscription({
    refreshToken: fetchRealtimeSubscriptionToken,
    bufferInterval: 0,
    enabled: true,
  });

  useEffect(() => {
    if (latestData?.channel === "tasks" && latestData.topic === "status") {
      updateTask(latestData.data.taskId, {
        status: latestData.data.status,
        hasChanges: true,
        sessionId: latestData.data.sessionId,
      });
    }

    if (latestData?.channel === "tasks" && latestData.topic === "update") {
      if (latestData.data.message.type === "git") {
        updateTask(latestData.data.taskId, {
          statusMessage: latestData.data.message.output as string,
        });
      }

      if (latestData.data.message.type === "local_shell_call") {
        const task = getTaskById(latestData.data.taskId);
        updateTask(latestData.data.taskId, {
          statusMessage: `Running command ${(
            latestData.data.message as { action: { command: string[] } }
          ).action.command.join(" ")}`,
          messages: [
            ...(task?.messages || []),
            {
              role: "assistant",
              type: "local_shell_call",
              data: latestData.data.message,
            },
          ],
        });
      }

      if (latestData.data.message.type === "local_shell_call_output") {
        const task = getTaskById(latestData.data.taskId);
        updateTask(latestData.data.taskId, {
          messages: [
            ...(task?.messages || []),
            {
              role: "assistant",
              type: "local_shell_call_output",
              data: latestData.data.message,
            },
          ],
        });
      }

      if (
        latestData.data.message.type === "message" &&
        latestData.data.message.status === "completed" &&
        latestData.data.message.role === "assistant"
      ) {
        const task = getTaskById(latestData.data.taskId);

        updateTask(latestData.data.taskId, {
          messages: [
            ...(task?.messages || []),
            {
              role: "assistant",
              type: "message",
              data: (latestData.data.message.content as { text: string }[])[0],
            },
          ],
        });
      }
    }
  }, [latestData]);

  return children;
}



================================================
FILE: templates/codex-clone/app/globals.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@layer utilities {
  /* Custom animations for chat messages */
  @keyframes slide-in-from-left {
    0% {
      transform: translateX(-20px);
      opacity: 0;
    }
    100% {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes slide-in-from-right {
    0% {
      transform: translateX(20px);
      opacity: 0;
    }
    100% {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes slide-in-from-bottom {
    0% {
      transform: translateY(10px);
      opacity: 0;
    }
    100% {
      transform: translateY(0);
      opacity: 1;
    }
  }

  .animate-in {
    animation-fill-mode: both;
  }

  .slide-in-from-left {
    animation-name: slide-in-from-left;
  }

  .slide-in-from-right {
    animation-name: slide-in-from-right;
  }

  .slide-in-from-bottom {
    animation-name: slide-in-from-bottom;
  }

  .duration-300 {
    animation-duration: 300ms;
  }

  /* Custom scrollbar styling */
  .scroll-area-custom::-webkit-scrollbar {
    width: 6px;
  }

  .scroll-area-custom::-webkit-scrollbar-track {
    background: transparent;
  }

  .scroll-area-custom::-webkit-scrollbar-thumb {
    @apply bg-muted-foreground/20 rounded-full;
  }

  .scroll-area-custom::-webkit-scrollbar-thumb:hover {
    @apply bg-muted-foreground/30;
  }

  /* Smooth transitions for theme switching */
  * {
    @apply transition-colors duration-200;
  }
}



================================================
FILE: templates/codex-clone/app/layout.tsx
================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { ThemeProvider } from "next-themes";
import "./globals.css";
import "./streaming.css";

import Container from "./container";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "VibeX | An open-source OpenAI Codex clone",
  description:
    "Codex UI is a modern, open-source, and fully customizable UI for OpenAI Codex.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          <Container>{children}</Container>
        </ThemeProvider>
      </body>
    </html>
  );
}



================================================
FILE: templates/codex-clone/app/page.tsx
================================================
import ClientPage from "./client-page";

export default function Home() {
  return <ClientPage />;
}



================================================
FILE: templates/codex-clone/app/streaming.css
================================================
@keyframes shimmer {
  0% { 
    transform: translateX(-100%); 
  }
  100% { 
    transform: translateX(100%); 
  }
}


================================================
FILE: templates/codex-clone/app/_components/task-form.tsx
================================================
"use client";
import { HardDrive, Split } from "lucide-react";
import { useRef, useEffect, useState } from "react";

import { Button } from "@/components/ui/button";
import { useEnvironmentStore } from "@/stores/environments";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useGitHubAuth } from "@/hooks/use-github-auth";
import { useTaskStore } from "@/stores/tasks";
import { createTaskAction } from "@/app/actions/inngest";
import Link from "next/link";

export default function TaskForm() {
  const { environments } = useEnvironmentStore();
  const { addTask } = useTaskStore();
  const { branches, fetchBranches } = useGitHubAuth();
  const [selectedBranch, setSelectedBranch] = useState<string>(
    branches.find((branch) => branch.isDefault)?.name || ""
  );
  const [selectedEnvironment, setSelectedEnvironment] = useState<string>(
    environments[0]?.id || ""
  );
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const [value, setValue] = useState("");

  const adjustHeight = () => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = "100px"; // Reset to min height
      textarea.style.height = Math.max(100, textarea.scrollHeight) + "px";
    }
  };

  const handleAddTask = async (mode: "code" | "ask") => {
    if (value) {
      const task = addTask({
        title: value,
        hasChanges: false,
        description: "",
        messages: [],
        status: "IN_PROGRESS",
        branch: selectedBranch,
        sessionId: "",
        repository:
          environments.find((env) => env.id === selectedEnvironment)
            ?.githubRepository || "",
        mode,
      });
      await createTaskAction({ task });
      setValue("");
    }
  };

  useEffect(() => {
    adjustHeight();
  }, [value]);

  // Set initial environment when environments load
  useEffect(() => {
    if (environments.length > 0 && !selectedEnvironment) {
      setSelectedEnvironment(environments[0].id);
    }
  }, [environments, selectedEnvironment]);

  useEffect(() => {
    if (selectedEnvironment) {
      const environment = environments.find(
        (env) => env.id === selectedEnvironment
      );

      if (environment?.githubRepository) {
        fetchBranches(environment.githubRepository);
      }
    }
  }, [selectedEnvironment]);

  useEffect(() => {
    if (branches.length > 0) {
      setSelectedBranch(
        branches.find((branch) => branch.isDefault)?.name || ""
      );
    }
  }, [branches]);

  return (
    <div className="max-w-3xl mx-auto w-full flex flex-col gap-y-10 mt-14">
      <h1 className="text-4xl text-center font-bold">
        Ready to ship something new?
      </h1>
      <div className="p-0.5 rounded-lg bg-muted">
        <div className="flex flex-col gap-y-2 border bg-background rounded-lg p-4">
          <textarea
            ref={textareaRef}
            value={value}
            onChange={(e) => setValue(e.target.value)}
            placeholder="Describe a task you want to ship..."
            className="w-full min-h-[100px] resize-none border-none p-0 focus:outline-none focus:border-transparent overflow-hidden"
          />
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-x-2">
              {environments.length > 0 ? (
                <Select
                  onValueChange={(value) => setSelectedEnvironment(value)}
                  value={selectedEnvironment || ""}
                >
                  <SelectTrigger>
                    <HardDrive />
                    <SelectValue placeholder="Choose a repository" />
                  </SelectTrigger>
                  <SelectContent>
                    {environments.map((environment) => (
                      <SelectItem key={environment.id} value={environment.id}>
                        <div className="flex w-full">
                          <span className="truncate max-w-[150px]">
                            {environment.githubRepository}
                          </span>
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              ) : (
                <Link passHref href="/environments">
                  <Button className="rounded-lg" variant="outline">
                    <HardDrive />
                    Create an environment
                  </Button>
                </Link>
              )}
              {selectedEnvironment && (
                <Select
                  onValueChange={(value) => setSelectedBranch(value)}
                  value={selectedBranch}
                >
                  <SelectTrigger>
                    <Split />
                    <SelectValue placeholder="Branch..." />
                  </SelectTrigger>
                  <SelectContent>
                    {branches.map((branch) => (
                      <SelectItem key={branch.name} value={branch.name}>
                        <div className="flex w-full">
                          <span>{branch.name}</span>
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}
            </div>
            {value && (
              <div className="flex items-center gap-x-2">
                <Button variant="outline" onClick={() => handleAddTask("ask")}>
                  Ask
                </Button>
                <Button onClick={() => handleAddTask("code")}>Code</Button>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/_components/task-list.tsx
================================================
"use client";
import { Archive, Check, Dot, Trash2 } from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { useEffect, useState } from "react";

import { useTaskStore } from "@/stores/tasks";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { TextShimmer } from "@/components/ui/text-shimmer";
import Link from "next/link";

export default function TaskList() {
  const [isHydrated, setIsHydrated] = useState(false);
  const { getActiveTasks, getArchivedTasks, archiveTask, removeTask } =
    useTaskStore();
  const activeTasks = getActiveTasks();
  const archivedTasks = getArchivedTasks();

  useEffect(() => {
    setIsHydrated(true);
  }, []);

  return (
    <div className="max-w-3xl mx-auto w-full p-1 rounded-lg bg-muted">
      <Tabs defaultValue="active">
        <TabsList>
          <TabsTrigger value="active">
            <Check />
            Tasks
          </TabsTrigger>
          <TabsTrigger value="archived">
            <Archive />
            Archive
          </TabsTrigger>
        </TabsList>
        <TabsContent value="active">
          <div className="flex flex-col gap-1">
            {!isHydrated ? (
              <p className="text-muted-foreground p-2">Loading tasks...</p>
            ) : activeTasks.length === 0 ? (
              <p className="text-muted-foreground p-2">No active tasks yet.</p>
            ) : (
              activeTasks.map((task) => (
                <div
                  key={task.id}
                  className="border rounded-lg bg-background p-4 flex items-center justify-between hover:bg-sidebar"
                >
                  <Link href={`/task/${task.id}`} className="flex-1">
                    <div>
                      <div className="flex items-center gap-x-2">
                        {task.hasChanges && (
                          <div className="size-2 rounded-full bg-blue-500 " />
                        )}
                        <h3 className="font-medium">{task.title}</h3>
                      </div>
                      {task.status === "IN_PROGRESS" ? (
                        <div>
                          <TextShimmer className="text-sm">
                            {`${
                              task.statusMessage || "Working on your task"
                            }...`}
                          </TextShimmer>
                        </div>
                      ) : (
                        <div className="flex items-center gap-0">
                          <p className="text-sm text-muted-foreground">
                            {task.createdAt
                              ? formatDistanceToNow(new Date(task.createdAt), {
                                  addSuffix: true,
                                })
                              : "Just now"}
                          </p>
                          <Dot className="size-4 text-muted-foreground" />
                          <p className="text-sm text-muted-foreground">
                            {task.repository}
                          </p>
                        </div>
                      )}
                    </div>
                  </Link>
                  {task.status === "DONE" && (
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={() => archiveTask(task.id)}
                    >
                      <Archive />
                    </Button>
                  )}
                </div>
              ))
            )}
          </div>
        </TabsContent>
        <TabsContent value="archived">
          <div className="flex flex-col gap-1">
            {!isHydrated ? (
              <p className="text-muted-foreground p-2">Loading tasks...</p>
            ) : archivedTasks.length === 0 ? (
              <p className="text-muted-foreground p-2">
                No archived tasks yet.
              </p>
            ) : (
              archivedTasks.map((task) => (
                <div
                  key={task.id}
                  className="border rounded-lg p-4 flex items-center justify-between bg-background"
                >
                  <div>
                    <h3 className="font-medium text-muted-foreground">
                      {task.title}
                    </h3>
                    <p className="text-sm text-muted-foreground">
                      Status: {task.status} â€¢ Branch: {task.branch}
                    </p>
                  </div>
                  <Button
                    variant="outline"
                    size="icon"
                    onClick={(e) => {
                      e.stopPropagation();
                      removeTask(task.id);
                    }}
                  >
                    <Trash2 />
                  </Button>
                </div>
              ))
            )}
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/actions/inngest.ts
================================================
"use server";
import { cookies } from "next/headers";
import { getSubscriptionToken, Realtime } from "@inngest/realtime";

import { inngest } from "@/lib/inngest";
import { Task } from "@/stores/tasks";
import { getInngestApp, taskChannel } from "@/lib/inngest";

export type TaskChannelToken = Realtime.Token<
  typeof taskChannel,
  ["status", "update"]
>;

export const createTaskAction = async ({
  task,
  sessionId,
  prompt,
}: {
  task: Task;
  sessionId?: string;
  prompt?: string;
}) => {
  const cookieStore = await cookies();
  const githubToken = cookieStore.get("github_access_token")?.value;

  if (!githubToken) {
    throw new Error("No GitHub token found. Please authenticate first.");
  }

  await inngest.send({
    name: "clonedex/create.task",
    data: {
      task,
      token: githubToken,
      sessionId: sessionId,
      prompt: prompt,
    },
  });
};

export const createPullRequestAction = async ({
  sessionId,
}: {
  sessionId?: string;
}) => {
  const cookieStore = await cookies();
  const githubToken = cookieStore.get("github_access_token")?.value;

  if (!githubToken) {
    throw new Error("No GitHub token found. Please authenticate first.");
  }

  await inngest.send({
    name: "clonedex/create.pull-request",
    data: {
      token: githubToken,
      sessionId: sessionId,
    },
  });
};

export async function fetchRealtimeSubscriptionToken(): Promise<TaskChannelToken> {
  const token = await getSubscriptionToken(getInngestApp(), {
    channel: taskChannel(),
    topics: ["status", "update"],
  });

  return token;
}



================================================
FILE: templates/codex-clone/app/actions/vibekit.ts
================================================
"use server";

import { cookies } from "next/headers";
import { VibeKit, VibeKitConfig } from "@vibe-kit/sdk";
import { Task } from "@/stores/tasks";

export const createPullRequestAction = async ({ task }: { task: Task }) => {
  const cookieStore = await cookies();
  const githubToken = cookieStore.get("github_access_token")?.value;

  if (!githubToken) {
    throw new Error("No GitHub token found. Please authenticate first.");
  }

  const config: VibeKitConfig = {
    agent: {
      type: "codex",
      model: {
        apiKey: process.env.OPENAI_API_KEY!,
      },
    },
    environment: {
      e2b: {
        apiKey: process.env.E2B_API_KEY!,
      },
    },
    github: {
      token: githubToken,
      repository: task.repository,
    },
    sessionId: task.sessionId,
  };

  const vibekit = new VibeKit(config);

  const pr = await vibekit.createPullRequest();

  return pr;
};



================================================
FILE: templates/codex-clone/app/api/auth/github/branches/route.ts
================================================
import { NextRequest, NextResponse } from "next/server";

interface GitHubBranch {
  name: string;
  commit: {
    sha: string;
    url: string;
  };
  protected: boolean;
}

export async function GET(request: NextRequest) {
  try {
    // Get the access token from the httpOnly cookie
    const accessToken = request.cookies.get("github_access_token")?.value;

    if (!accessToken) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }

    // Get repository from query parameters
    const { searchParams } = new URL(request.url);
    const owner = searchParams.get("owner");
    const repo = searchParams.get("repo");

    if (!owner || !repo) {
      return NextResponse.json(
        { error: "Owner and repo parameters are required" },
        { status: 400 }
      );
    }

    // First fetch repository info to get the default branch
    const repoResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}`,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: "application/vnd.github.v3+json",
        },
      }
    );

    if (!repoResponse.ok) {
      if (repoResponse.status === 404) {
        return NextResponse.json(
          { error: "Repository not found" },
          { status: 404 }
        );
      }
      throw new Error(`Failed to fetch repository: ${repoResponse.statusText}`);
    }

    const repoData = await repoResponse.json();
    const defaultBranch = repoData.default_branch;

    // Fetch branches from GitHub API
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/branches`,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: "application/vnd.github.v3+json",
        },
      }
    );

    if (!response.ok) {
      if (response.status === 404) {
        return NextResponse.json(
          { error: "Repository not found" },
          { status: 404 }
        );
      }
      throw new Error(`Failed to fetch branches: ${response.statusText}`);
    }

    const branches: GitHubBranch[] = await response.json();

    return NextResponse.json({
      branches: branches.map((branch: GitHubBranch) => ({
        name: branch.name,
        commit: {
          sha: branch.commit.sha,
          url: branch.commit.url,
        },
        protected: branch.protected || false,
        isDefault: branch.name === defaultBranch,
      })),
    });
  } catch (error) {
    console.error("Error fetching branches:", error);
    return NextResponse.json(
      { error: "Failed to fetch branches" },
      { status: 500 }
    );
  }
}



================================================
FILE: templates/codex-clone/app/api/auth/github/callback/route.ts
================================================
import { NextRequest, NextResponse } from "next/server";
import { githubAuth } from "@/lib/github";

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const code = searchParams.get("code");
  const error = searchParams.get("error");

  // Handle OAuth errors
  if (error) {
    return NextResponse.redirect(new URL(`/?error=${error}`, request.url));
  }

  if (!code) {
    return NextResponse.redirect(new URL("/?error=missing_code", request.url));
  }

  try {
    // Exchange code for access token
    const accessToken = await githubAuth.exchangeCodeForToken(code);

    // Get user info
    const user = await githubAuth.getUser(accessToken);

    // Create the response with a redirect to close the popup
    const response = NextResponse.redirect(
      new URL("/auth/success", request.url)
    );

    // Set the access token in an httpOnly cookie (secure)
    response.cookies.set("github_access_token", accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      maxAge: 60 * 60 * 24 * 7, // 7 days
    });

    // Set user info in a readable cookie for the frontend
    response.cookies.set(
      "github_user",
      JSON.stringify({
        id: user.id,
        login: user.login,
        avatar_url: user.avatar_url,
        name: user.name,
      }),
      {
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        maxAge: 60 * 60 * 24 * 7, // 7 days
      }
    );

    return response;
  } catch (error) {
    console.error("GitHub OAuth error:", error);
    return NextResponse.redirect(new URL("/?error=oauth_failed", request.url));
  }
}



================================================
FILE: templates/codex-clone/app/api/auth/github/repositories/route.ts
================================================
import { NextRequest, NextResponse } from "next/server";
import { githubAuth } from "@/lib/github";

export async function GET(request: NextRequest) {
  try {
    // Get the access token from the httpOnly cookie
    const accessToken = request.cookies.get("github_access_token")?.value;

    if (!accessToken) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }

    // Fetch repositories
    const repositories = await githubAuth.getUserRepositories(accessToken);

    // Filter to only include repositories the user has push access to
    const userRepos = repositories.filter(
      (repo) =>
        !repo.fork && // Exclude forks
        repo.permissions?.push !== false // Only repos with push access
    );

    return NextResponse.json({
      repositories: userRepos.map((repo) => ({
        id: repo.id,
        name: repo.name,
        full_name: repo.full_name,
        private: repo.private,
        description: repo.description,
        html_url: repo.html_url,
        default_branch: repo.default_branch,
      })),
    });
  } catch (error) {
    console.error("Error fetching repositories:", error);
    return NextResponse.json(
      { error: "Failed to fetch repositories" },
      { status: 500 }
    );
  }
}



================================================
FILE: templates/codex-clone/app/api/auth/github/url/route.ts
================================================
import { NextResponse } from "next/server";
import { githubAuth } from "@/lib/github";

export async function GET() {
  try {
    const authUrl = githubAuth.getAuthUrl();

    return NextResponse.json({ url: authUrl });
  } catch (error) {
    console.error("Error generating auth URL:", error);
    return NextResponse.json(
      { error: "Failed to generate auth URL" },
      { status: 500 }
    );
  }
}



================================================
FILE: templates/codex-clone/app/api/inngest/route.ts
================================================
import { serve } from "inngest/next";
import { inngest, createTask } from "@/lib/inngest";

export const maxDuration = 800;

export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [createTask],
});



================================================
FILE: templates/codex-clone/app/auth/success/page.tsx
================================================
"use client";

import { useEffect } from "react";

export default function AuthSuccessPage() {
  useEffect(() => {
    // Close the popup and notify the parent window
    if (window.opener) {
      window.opener.postMessage({ type: "GITHUB_AUTH_SUCCESS" }, "*");
      window.close();
    } else {
      // If not in a popup, redirect to home
      window.location.href = "/";
    }
  }, []);

  return (
    <div className="flex items-center justify-center min-h-screen">
      <div className="text-center">
        <h1 className="text-2xl font-bold mb-4">Authentication Successful!</h1>
        <p className="text-muted-foreground">
          This window will close automatically...
        </p>
      </div>
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/environments/client-page.tsx
================================================
"use client";
import Navbar from "@/components/navbar";
import EnvironmentsList from "./_components/environments-list";

export default function EnvironmentsClientPage() {
  return (
    <div className="flex flex-col gap-y-4 px-4 py-2 h-screen">
      <Navbar />
      <EnvironmentsList />
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/environments/page.tsx
================================================
import EnvironmentsClientPage from "./client-page";

export default function EnvironmentsPage() {
  return <EnvironmentsClientPage />;
}



================================================
FILE: templates/codex-clone/app/environments/_components/create-environment-dialog.tsx
================================================
"use client";
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useEnvironmentStore } from "@/stores/environments";
import { useGitHubAuth } from "@/hooks/use-github-auth";

interface CreateEnvironmentDialogProps {
  isOpen: boolean;
  onOpenChange: (open: boolean) => void;
}

export function CreateEnvironmentDialog({
  isOpen,
  onOpenChange,
}: CreateEnvironmentDialogProps) {
  const { isAuthenticated, repositories, fetchRepositories } = useGitHubAuth();
  const { createEnvironment } = useEnvironmentStore();

  // Form state
  const [formData, setFormData] = useState({
    name: "",
    description: "",
    selectedRepository: "",
  });
  const [isCreating, setIsCreating] = useState(false);

  useEffect(() => {
    if (isAuthenticated && isOpen) {
      fetchRepositories();
    }
  }, [isAuthenticated, isOpen, fetchRepositories]);

  const resetForm = () => {
    setFormData({
      name: "",
      description: "",
      selectedRepository: "",
    });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.name.trim() || !formData.selectedRepository) {
      return;
    }

    setIsCreating(true);

    try {
      // Get GitHub access token from cookies
      const githubTokenCookie = document.cookie
        .split("; ")
        .find((row) => row.startsWith("github_access_token="));

      const githubToken = githubTokenCookie?.split("=")[1] || "";

      // Parse organization and repository from full_name (owner/repo)
      const [githubOrganization] = formData.selectedRepository.split("/");

      // Create the environment
      createEnvironment({
        name: formData.name.trim(),
        description: formData.description.trim(),
        githubOrganization,
        githubToken,
        githubRepository: formData.selectedRepository,
      });

      // Reset form and close dialog
      resetForm();
      onOpenChange(false);
    } catch (error) {
      console.error("Failed to create environment:", error);
    } finally {
      setIsCreating(false);
    }
  };

  const isFormValid = formData.name.trim() && formData.selectedRepository;

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => {
        onOpenChange(open);
        if (!open) {
          resetForm();
        }
      }}
    >
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Create a new environment</DialogTitle>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="flex flex-col gap-y-4">
          <div className="flex flex-col gap-y-2">
            <label htmlFor="name" className="text-sm font-medium">
              Environment name *
            </label>
            <input
              id="name"
              type="text"
              value={formData.name}
              onChange={(e) =>
                setFormData((prev) => ({ ...prev, name: e.target.value }))
              }
              placeholder="Enter environment name"
              className="w-full h-9 px-3 py-2 text-sm border border-input rounded-md bg-background focus:outline-none focus:ring-[3px] focus:ring-ring/50 focus:border-ring disabled:cursor-not-allowed disabled:opacity-50"
              required
            />
          </div>

          <div className="flex flex-col gap-y-2">
            <label htmlFor="description" className="text-sm font-medium">
              Description
            </label>
            <textarea
              id="description"
              value={formData.description}
              onChange={(e) =>
                setFormData((prev) => ({
                  ...prev,
                  description: e.target.value,
                }))
              }
              placeholder="Enter environment description"
              rows={3}
              className="w-full px-3 py-2 text-sm border border-input rounded-md bg-background focus:outline-none focus:ring-[3px] focus:ring-ring/50 focus:border-ring disabled:cursor-not-allowed disabled:opacity-50 resize-none"
            />
          </div>

          <div className="flex flex-col gap-y-2">
            <label htmlFor="repository" className="text-sm font-medium">
              Select your Github repository *
            </label>
            <Select
              value={formData.selectedRepository}
              onValueChange={(value) =>
                setFormData((prev) => ({
                  ...prev,
                  selectedRepository: value,
                }))
              }
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Choose a repository" />
              </SelectTrigger>
              <SelectContent>
                {repositories.map((repo) => (
                  <SelectItem key={repo.id} value={repo.full_name}>
                    <div className="flex">
                      <span>{repo.full_name}</span>
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="flex justify-end gap-2 pt-4">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
              disabled={isCreating}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={!isFormValid || isCreating}>
              {isCreating ? "Creating..." : "Create Environment"}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}



================================================
FILE: templates/codex-clone/app/environments/_components/environments-list.tsx
================================================
"use client";
import { Dot, FolderGit, GithubIcon, Plus, Trash2 } from "lucide-react";
import { useState } from "react";
import { format } from "date-fns";

import { Button } from "@/components/ui/button";
import { useEnvironmentStore } from "@/stores/environments";
import { useGitHubAuth } from "@/hooks/use-github-auth";
import { Skeleton } from "@/components/ui/skeleton";
import Link from "next/link";
import { CreateEnvironmentDialog } from "./create-environment-dialog";

export default function EnvironmentsList() {
  const { isAuthenticated, login, isLoading } = useGitHubAuth();
  const { environments, deleteEnvironment } = useEnvironmentStore();
  const [isDialogOpen, setIsDialogOpen] = useState<boolean>(false);

  const handleGitHubAuth = async () => {
    await login();
  };

  const handleDeleteEnvironment = (environmentId: string) => {
    if (confirm("Are you sure you want to delete this environment?")) {
      deleteEnvironment(environmentId);
    }
  };

  if (isLoading) {
    return (
      <div className="max-w-2xl mx-auto w-full flex flex-col gap-y-10 mt-14">
        <div className="flex items-center justify-between">
          <p className="font-medium">Environments</p>
          <Skeleton className="w-22 h-9" />
        </div>
        <div className="flex flex-col gap-y-4">
          {Array.from({ length: 5 }).map((_, index) => (
            <Skeleton className="h-20 w-full" key={index} />
          ))}
        </div>
      </div>
    );
  }

  console.log(isAuthenticated);

  return (
    <>
      <div className="max-w-2xl mx-auto w-full flex flex-col gap-y-10 mt-14">
        <div className="flex items-center justify-between">
          <p className="font-medium">Environments</p>
          {isAuthenticated ? (
            <Button onClick={() => setIsDialogOpen(true)}>
              <Plus />
              Add new
            </Button>
          ) : (
            <Button onClick={handleGitHubAuth}>
              <GithubIcon />
              Connect your Github account
            </Button>
          )}
        </div>
        {isAuthenticated ? (
          <div className="flex flex-col gap-y-4">
            {environments.map((environment) => (
              <div
                key={environment.id}
                className="flex items-center justify-between border rounded-lg p-4"
              >
                <div className="flex flex-col">
                  <p className="font-medium">{environment.name}</p>
                  <div className="flex items-center gap-x-0">
                    <Link
                      href={`https://github.com/${environment.githubRepository}`}
                      passHref
                    >
                      <div className="flex items-center gap-x-1">
                        <FolderGit className="size-4 text-muted-foreground" />
                        <p className="text-muted-foreground hover:text-primary transition-colors text-sm">
                          {environment.githubOrganization}
                        </p>
                      </div>
                    </Link>
                    {environment.createdAt && (
                      <>
                        <Dot className="text-muted-foreground/40" />
                        <p className="text-muted-foreground text-sm">
                          Created{" "}
                          {format(
                            new Date(environment.createdAt),
                            "MMM d, yyyy"
                          )}
                        </p>
                      </>
                    )}
                  </div>
                </div>
                <Button
                  variant="outline"
                  size="icon"
                  onClick={() => handleDeleteEnvironment(environment.id)}
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </div>
            ))}
          </div>
        ) : (
          <div className="flex flex-col gap-y-4">
            <p className="text-muted-foreground">
              Connect your Github account to get started
            </p>
          </div>
        )}
      </div>
      <CreateEnvironmentDialog
        isOpen={isDialogOpen}
        onOpenChange={setIsDialogOpen}
      />
    </>
  );
}



================================================
FILE: templates/codex-clone/app/task/[id]/client-page.tsx
================================================
"use client";
import { useInngestSubscription } from "@inngest/realtime/hooks";
import { useEffect, useRef, useState } from "react";

import TaskNavbar from "./_components/navbar";
import MessageInput from "./_components/message-input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { fetchRealtimeSubscriptionToken } from "@/app/actions/inngest";
import { useTaskStore } from "@/stores/tasks";
import { Terminal, Bot, User, Loader } from "lucide-react";
import { TextShimmer } from "@/components/ui/text-shimmer";
import { Markdown } from "@/components/markdown";
import { StreamingIndicator } from "@/components/streaming-indicator";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";

interface Props {
  id: string;
}

interface StreamingMessage {
  role: "user" | "assistant";
  type: string;
  data: Record<string, unknown> & {
    text?: string;
    isStreaming?: boolean;
    streamId?: string;
    chunkIndex?: number;
    totalChunks?: number;
  };
}

interface IncomingMessage {
  role: "user" | "assistant";
  type: string;
  data: Record<string, unknown> & {
    text?: string;
    isStreaming?: boolean;
    streamId?: string;
    chunkIndex?: number;
    totalChunks?: number;
    call_id?: string;
    action?: {
      command?: string[];
    };
    output?: string;
  };
}

// Type guard to check if a message has streaming properties
function isStreamingMessage(message: unknown): message is IncomingMessage & {
  data: { isStreaming: true; streamId: string };
} {
  return (
    typeof message === "object" &&
    message !== null &&
    "type" in message &&
    message.type === "message" &&
    "data" in message &&
    typeof message.data === "object" &&
    message.data !== null &&
    "isStreaming" in message.data &&
    message.data.isStreaming === true &&
    "streamId" in message.data &&
    typeof message.data.streamId === "string"
  );
}

// Type guard to check if a message is a completed stream
function isCompletedStreamMessage(
  message: unknown
): message is IncomingMessage & {
  data: { streamId: string; isStreaming: false };
} {
  return (
    typeof message === "object" &&
    message !== null &&
    "type" in message &&
    message.type === "message" &&
    "data" in message &&
    typeof message.data === "object" &&
    message.data !== null &&
    "streamId" in message.data &&
    typeof message.data.streamId === "string" &&
    (!("isStreaming" in message.data) || message.data.isStreaming === false)
  );
}

// Type guard to check if message is a valid incoming message
function isValidIncomingMessage(message: unknown): message is IncomingMessage {
  return (
    typeof message === "object" &&
    message !== null &&
    "role" in message &&
    "type" in message &&
    "data" in message &&
    (message.role === "user" || message.role === "assistant") &&
    typeof message.type === "string" &&
    typeof message.data === "object"
  );
}

export default function TaskClientPage({ id }: Props) {
  const { getTaskById, updateTask } = useTaskStore();
  const task = getTaskById(id);
  const scrollAreaRef = useRef<HTMLDivElement>(null);
  const chatScrollAreaRef = useRef<HTMLDivElement>(null);
  const [subscriptionEnabled, setSubscriptionEnabled] = useState(true);
  const [streamingMessages, setStreamingMessages] = useState<
    Map<string, StreamingMessage>
  >(new Map());

  // Function to get the output message for a given shell call message
  const getOutputForCall = (callId: string) => {
    return task?.messages.find(
      (message) =>
        message.type === "local_shell_call_output" &&
        message.data?.call_id === callId
    );
  };

  const { latestData } = useInngestSubscription({
    refreshToken: fetchRealtimeSubscriptionToken,
    bufferInterval: 0,
    enabled: subscriptionEnabled,
  });

  useEffect(() => {
    if (latestData?.channel === "tasks" && latestData.topic === "update") {
      const { taskId, message } = latestData.data;

      if (taskId === id && message && isValidIncomingMessage(message)) {
        // Handle streaming messages
        if (isStreamingMessage(message)) {
          const streamId = message.data.streamId;

          setStreamingMessages((prev) => {
            const newMap = new Map(prev);
            const existingMessage = newMap.get(streamId);

            if (existingMessage) {
              // Append to existing streaming message
              newMap.set(streamId, {
                ...existingMessage,
                data: {
                  ...existingMessage.data,
                  text:
                    (existingMessage.data.text || "") +
                    (message.data.text || ""),
                  chunkIndex: message.data.chunkIndex,
                  totalChunks: message.data.totalChunks,
                },
              });
            } else {
              // New streaming message
              newMap.set(streamId, message as StreamingMessage);
            }

            return newMap;
          });
        } else if (isCompletedStreamMessage(message)) {
          // Stream ended, move to regular messages
          const streamId = message.data.streamId;
          const streamingMessage = streamingMessages.get(streamId);

          if (streamingMessage) {
            updateTask(id, {
              messages: [
                ...(task?.messages || []),
                {
                  ...streamingMessage,
                  data: {
                    ...streamingMessage.data,
                    text: message.data.text || streamingMessage.data.text,
                    isStreaming: false,
                  },
                },
              ],
            });

            setStreamingMessages((prev) => {
              const newMap = new Map(prev);
              newMap.delete(streamId);
              return newMap;
            });
          }
        } else {
          // Regular non-streaming message
          updateTask(id, {
            messages: [...(task?.messages || []), message],
          });
        }
      }
    }
  }, [latestData, id, task?.messages, streamingMessages, updateTask]);

  // Auto-scroll to bottom when messages change or streaming messages update
  useEffect(() => {
    if (chatScrollAreaRef.current) {
      const viewport = chatScrollAreaRef.current.querySelector(
        "[data-radix-scroll-area-viewport]"
      );
      if (viewport) {
        viewport.scrollTo({
          top: viewport.scrollHeight,
          behavior: "smooth",
        });
      }
    }
  }, [task?.messages, streamingMessages]);

  useEffect(() => {
    if (task) {
      updateTask(task.id, {
        hasChanges: false,
      });
    }
  }, []);

  // Cleanup subscription on unmount to prevent stream cancellation errors
  useEffect(() => {
    return () => {
      setSubscriptionEnabled(false);
    };
  }, []);

  return (
    <div className="flex flex-col h-screen">
      <TaskNavbar id={id} />
      <div className="flex flex-1 overflow-hidden">
        {/* Sidebar for chat messages */}
        <div className="w-full max-w-3xl mx-auto border-r border-border bg-gradient-to-b from-background to-muted/5 flex flex-col h-full">
          <ScrollArea
            ref={chatScrollAreaRef}
            className="flex-1 overflow-y-auto scroll-area-custom"
          >
            <div className="p-6 flex flex-col gap-y-6">
              {/* Initial task message */}
              <div className="flex justify-end animate-in slide-in-from-right duration-300">
                <div className="max-w-[85%] flex gap-3">
                  <div className="bg-primary text-primary-foreground rounded-2xl px-5 py-3 shadow-sm">
                    <p className="text-sm leading-relaxed">{task?.title}</p>
                  </div>
                  <div className="flex-shrink-0">
                    <div className="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                      <User className="w-4 h-4 text-primary" />
                    </div>
                  </div>
                </div>
              </div>
              {/* Render regular messages */}
              {task?.messages
                .filter(
                  (message) =>
                    (message.role === "assistant" || message.role === "user") &&
                    message.type === "message"
                )
                .map((message, index) => {
                  const isAssistant = message.role === "assistant";
                  return (
                    <div
                      key={
                        (message.data as { id?: string })?.id ||
                        `message-${index}-${message.role}` ||
                        index
                      }
                      className={cn(
                        "flex gap-3 animate-in duration-300",
                        isAssistant
                          ? "justify-start slide-in-from-left"
                          : "justify-end slide-in-from-right"
                      )}
                    >
                      {isAssistant && (
                        <div className="flex-shrink-0">
                          <div className="w-8 h-8 rounded-full bg-muted flex items-center justify-center border border-border">
                            <Bot className="w-4 h-4 text-muted-foreground" />
                          </div>
                        </div>
                      )}
                      <div
                        className={cn(
                          "max-w-[85%] rounded-2xl px-5 py-3 shadow-sm",
                          isAssistant
                            ? "bg-card border border-border"
                            : "bg-primary text-primary-foreground"
                        )}
                      >
                        {isAssistant ? (
                          <div className="prose prose-sm dark:prose-invert max-w-none overflow-hidden">
                            <Markdown
                              repoUrl={
                                task?.repository
                                  ? `https://github.com/${task.repository}`
                                  : undefined
                              }
                              branch={task?.branch}
                            >
                              {message.data?.text as string}
                            </Markdown>
                          </div>
                        ) : (
                          <p className="text-sm leading-relaxed break-words">
                            {message.data?.text as string}
                          </p>
                        )}
                      </div>
                      {!isAssistant && (
                        <div className="flex-shrink-0">
                          <div className="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                            <User className="w-4 h-4 text-primary" />
                          </div>
                        </div>
                      )}
                    </div>
                  );
                })}

              {/* Render streaming messages */}
              {Array.from(streamingMessages.values()).map((message) => {
                const isAssistant = message.role === "assistant";
                return (
                  <div
                    key={message.data.streamId as string}
                    className={cn(
                      "flex gap-3 animate-in duration-300",
                      isAssistant
                        ? "justify-start slide-in-from-left"
                        : "justify-end slide-in-from-right"
                    )}
                  >
                    {isAssistant && (
                      <div className="flex-shrink-0">
                        <div className="w-8 h-8 rounded-full bg-muted flex items-center justify-center border border-border relative overflow-hidden">
                          <Bot className="w-4 h-4 text-muted-foreground z-10 relative" />
                          <div
                            className="absolute inset-0 bg-gradient-to-r from-transparent via-primary/20 to-transparent"
                            style={{
                              animation: "shimmer 2s linear infinite",
                              backgroundSize: "200% 100%",
                            }}
                          />
                        </div>
                      </div>
                    )}
                    <div
                      className={cn(
                        "max-w-[85%] rounded-2xl px-5 py-3 shadow-sm",
                        isAssistant
                          ? "bg-card border border-border"
                          : "bg-primary text-primary-foreground"
                      )}
                    >
                      {isAssistant ? (
                        <div className="prose prose-sm dark:prose-invert max-w-none overflow-hidden">
                          <Markdown
                            repoUrl={
                              task?.repository
                                ? `https://github.com/${task.repository}`
                                : undefined
                            }
                            branch={task?.branch}
                          >
                            {message.data?.text as string}
                          </Markdown>
                          {/* Enhanced streaming indicator */}
                          <span className="inline-flex items-center gap-2 ml-1">
                            <StreamingIndicator size="sm" variant="cursor" />
                            {typeof message.data.chunkIndex === "number" &&
                              typeof message.data.totalChunks === "number" && (
                                <span className="text-[10px] text-muted-foreground/60 font-mono">
                                  {Math.round(
                                    ((message.data.chunkIndex + 1) /
                                      message.data.totalChunks) *
                                      100
                                  )}
                                  %
                                </span>
                              )}
                          </span>
                        </div>
                      ) : (
                        <p className="text-sm leading-relaxed break-words">
                          {message.data?.text as string}
                        </p>
                      )}
                    </div>
                    {!isAssistant && (
                      <div className="flex-shrink-0">
                        <div className="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                          <User className="w-4 h-4 text-primary" />
                        </div>
                      </div>
                    )}
                  </div>
                );
              })}

              {task?.status === "IN_PROGRESS" &&
                streamingMessages.size === 0 && (
                  <div className="flex justify-start animate-in slide-in-from-left duration-300">
                    <div className="flex gap-3">
                      <div className="flex-shrink-0">
                        <div className="w-8 h-8 rounded-full bg-muted flex items-center justify-center border border-border animate-pulse">
                          <Bot className="w-4 h-4 text-muted-foreground" />
                        </div>
                      </div>
                      <div className="bg-card border border-border rounded-2xl px-5 py-3 shadow-sm">
                        <div className="flex items-center gap-2">
                          <Loader className="w-4 h-4 text-muted-foreground animate-spin" />
                          <TextShimmer className="text-sm">
                            {task?.statusMessage
                              ? `${task.statusMessage}`
                              : "Working on task..."}
                          </TextShimmer>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
            </div>
          </ScrollArea>

          {/* Message input component - fixed at bottom */}
          <div className="flex-shrink-0">
            <MessageInput task={task!} />
          </div>
        </div>

        {/* Right panel for details */}
        <div className="flex-1 bg-gradient-to-br from-muted/50 to-background relative">
          {/* Fade overlay at the top */}
          <div className="absolute top-0 left-0 right-0 h-20 bg-gradient-to-b from-muted/50 to-transparent pointer-events-none z-10" />
          <ScrollArea ref={scrollAreaRef} className="h-full scroll-area-custom">
            <div className="max-w-4xl mx-auto w-full py-10 px-6">
              {/* Details content will go here */}
              <div className="flex flex-col gap-y-10">
                {task?.messages.map((message) => {
                  if (message.type === "local_shell_call") {
                    const output = getOutputForCall(
                      message.data?.call_id as string
                    );
                    return (
                      <div
                        key={message.data?.call_id as string}
                        className="flex flex-col"
                      >
                        <div className="flex items-start gap-x-2">
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <p className="font-medium font-mono text-sm -mt-1 truncate max-w-md cursor-help">
                                  {(
                                    message.data as {
                                      action?: { command?: string[] };
                                    }
                                  )?.action?.command
                                    ?.slice(1)
                                    .join(" ")}
                                </p>
                              </TooltipTrigger>
                              <TooltipContent>
                                <p className="max-w-sm break-words">
                                  {(
                                    message.data as {
                                      action?: { command?: string[] };
                                    }
                                  )?.action?.command
                                    ?.slice(1)
                                    .join(" ")}
                                </p>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        </div>
                        {output && (
                          <div className="mt-3 animate-in slide-in-from-bottom duration-300">
                            <div className="rounded-xl bg-card border-2 border-border shadow-sm overflow-hidden transition-all duration-200 hover:shadow-md">
                              <div className="flex items-center gap-2 bg-muted/50 border-b px-4 py-3">
                                <Terminal className="size-4 text-muted-foreground" />
                                <span className="font-medium text-sm text-muted-foreground">
                                  Output
                                </span>
                              </div>
                              <ScrollArea className="max-h-[400px]">
                                <pre className="whitespace-pre-wrap font-mono text-xs leading-relaxed p-4 text-muted-foreground">
                                  {(() => {
                                    try {
                                      const parsed = JSON.parse(
                                        (output.data as { output?: string })
                                          ?.output || "{}"
                                      );
                                      return parsed.output || "No output";
                                    } catch {
                                      return "Failed to parse output";
                                    }
                                  })()}
                                </pre>
                              </ScrollArea>
                            </div>
                          </div>
                        )}
                      </div>
                    );
                  }
                  return null;
                })}
              </div>
            </div>
          </ScrollArea>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/task/[id]/page.tsx
================================================
import TaskClientPage from "./client-page";

interface Props {
  params: Promise<{ id: string }>;
}

export default async function TaskPage({ params }: Props) {
  const { id } = await params;

  return <TaskClientPage id={id} />;
}



================================================
FILE: templates/codex-clone/app/task/[id]/_components/message-input.tsx
================================================
"use client";
import { useEffect, useRef, useState } from "react";
import { Send } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Task } from "@/stores/tasks";
import { createTaskAction } from "@/app/actions/inngest";
import { useTaskStore } from "@/stores/tasks";

export default function MessageInput({ task }: { task: Task }) {
  const { updateTask } = useTaskStore();
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const [messageValue, setMessageValue] = useState("");

  const adjustHeight = () => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = "60px"; // Reset to min height
      textarea.style.height = Math.max(60, textarea.scrollHeight) + "px";
    }
  };

  const handleSendMessage = async () => {
    if (messageValue.trim()) {
      await createTaskAction({
        task,
        prompt: messageValue,
        sessionId: task.sessionId,
      });

      updateTask(task.id, {
        ...task,
        status: "IN_PROGRESS",
        statusMessage: "Working on task",
        messages: [
          ...task.messages,
          {
            role: "user",
            type: "message",
            data: { text: messageValue, id: crypto.randomUUID() },
          },
        ],
      });

      setMessageValue("");
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  useEffect(() => {
    adjustHeight();
  }, [messageValue]);

  return (
    <div className="p-6 border-t border-border bg-background">
      <div className="relative">
        <div className="bg-card border-2 border-border rounded-2xl shadow-lg transition-all duration-200 hover:shadow-xl focus-within:border-primary/50 focus-within:shadow-xl">
          <div className="flex flex-col gap-y-3 p-4">
            <textarea
              ref={textareaRef}
              value={messageValue}
              onChange={(e) => setMessageValue(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Type your message..."
              className="w-full min-h-[60px] max-h-[200px] resize-none border-none p-0 focus:outline-none bg-transparent placeholder:text-muted-foreground/60 text-sm leading-relaxed"
              style={{ scrollbarWidth: "thin" }}
            />
            <div className="flex items-center justify-between">
              <span className="text-xs text-muted-foreground">
                Press Enter to send, Shift+Enter for new line
              </span>
              <Button
                size="sm"
                onClick={handleSendMessage}
                disabled={!messageValue.trim()}
                className="rounded-xl transition-all duration-200 hover:scale-105"
              >
                <Send className="size-4 mr-1" />
                Send
              </Button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/task/[id]/_components/navbar.tsx
================================================
"use client";
import Link from "next/link";
import {
  Archive,
  ArrowLeft,
  Dot,
  GitBranchPlus,
  GithubIcon,
  Loader,
} from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { useCallback, useState } from "react";

import { Button } from "@/components/ui/button";
import { useTaskStore } from "@/stores/tasks";
import { createPullRequestAction } from "@/app/actions/vibekit";

interface Props {
  id: string;
}

export default function TaskNavbar({ id }: Props) {
  const [isCreatingPullRequest, setIsCreatingPullRequest] = useState(false);
  const { getTaskById, updateTask } = useTaskStore();
  const task = getTaskById(id);

  const handleCreatePullRequest = useCallback(async () => {
    if (!task) return;

    setIsCreatingPullRequest(true);

    const pr = await createPullRequestAction({ task });

    updateTask(id, {
      pullRequest: pr,
    });

    setIsCreatingPullRequest(false);
  }, [task, id, updateTask]);

  const handleArchiveTask = useCallback(() => {
    if (!task) return;

    updateTask(id, {
      isArchived: !task.isArchived,
    });
  }, [task, id, updateTask]);

  return (
    <div className="h-14 border-b flex items-center justify-between px-4">
      <div className="flex items-center gap-x-2">
        <Link href="/">
          <Button variant="ghost" size="icon">
            <ArrowLeft />
          </Button>
        </Link>
        <div className="h-8 border-r" />
        <div className="flex flex-col gap-x-2 ml-4">
          <h3 className=" font-medium">{task?.title}</h3>
          <div className="flex items-center gap-x-0">
            <p className="text-sm text-muted-foreground">
              {task?.createdAt
                ? formatDistanceToNow(new Date(task.createdAt), {
                    addSuffix: true,
                  })
                : "Loading..."}
            </p>
            <Dot className="size-4 text-muted-foreground" />
            <p className="text-sm text-muted-foreground">{task?.repository}</p>
          </div>
        </div>
      </div>
      <div className="flex items-center gap-x-2">
        {task?.isArchived ? (
          <Button
            variant="outline"
            className="rounded-full"
            onClick={handleArchiveTask}
          >
            <Archive />
            Unarchive
          </Button>
        ) : (
          <Button
            variant="outline"
            className="rounded-full"
            onClick={handleArchiveTask}
          >
            <Archive />
            Archive
          </Button>
        )}
        {task?.pullRequest ? (
          <Link href={task.pullRequest.html_url} target="_blank">
            <Button className="rounded-full">
              <GithubIcon />
              View Pull Request
            </Button>
          </Link>
        ) : (
          <Button
            className="rounded-full"
            onClick={handleCreatePullRequest}
            disabled={isCreatingPullRequest}
          >
            {isCreatingPullRequest ? (
              <Loader className="animate-spin size-4" />
            ) : (
              <GitBranchPlus />
            )}
            Create Pull Request
          </Button>
        )}
      </div>
    </div>
  );
}



================================================
FILE: templates/codex-clone/components/markdown.tsx
================================================
import React, { memo, useState } from "react";
import ReactMarkdown, { type Components } from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeRaw from "rehype-raw";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { CopyIcon, CheckIcon } from "lucide-react";
import { useTheme } from "next-themes";
import {
  oneDark,
  oneLight,
} from "react-syntax-highlighter/dist/cjs/styles/prism";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Separator } from "@/components/ui/separator";
import {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
} from "@/components/ui/table";
import { ScrollArea, ScrollBar } from "@/components/ui/scroll-area";

type CodeComponentProps = React.ComponentPropsWithoutRef<"code"> & {
  inline?: boolean;
  className?: string;
  children?: React.ReactNode;
  style?: React.CSSProperties;
};

export const CodeComponent: React.FC<CodeComponentProps> = ({
  inline,
  className,
  children,
  ...props
}) => {
  const match = /language-(\w+)/.exec(className || "");
  const { theme } = useTheme();
  const [copied, setCopied] = useState(false);

  if (inline) {
    return (
      <code
        className="text-sm bg-background dark:bg-zinc-800 py-0.5 px-1 rounded-md"
        style={{ wordBreak: "break-all" }}
        {...props}
      >
        {children}
      </code>
    );
  }

  // Code block with language
  if (match) {
    return (
      <div className="border rounded-lg bg-background my-2 overflow-hidden">
        <div className="flex items-center justify-between bg-sidebar px-2 py-1 border-b">
          <span className="text-xs text-muted-foreground">{match[1]}</span>
          <Button
            variant="ghost"
            size="icon"
            className="size-7"
            onClick={() => {
              navigator.clipboard.writeText(String(children));
              setCopied(true);
              setTimeout(() => setCopied(false), 2000);
            }}
          >
            {copied ? (
              <CheckIcon className="w-4 h-4 text-green-500" />
            ) : (
              <CopyIcon className="w-4 h-4" />
            )}
          </Button>
        </div>
        <ScrollArea className="max-w-full">
          <div className="px-4 py-2" style={{ maxWidth: "100%" }}>
            <SyntaxHighlighter
              language={match[1]}
              style={theme === "dark" ? oneDark : oneLight}
              customStyle={{
                fontSize: "12.5px",
                backgroundColor: "transparent",
                padding: "0",
                margin: "0",
                background: "none",
                overflow: "visible",
              }}
              wrapLongLines={false}
              PreTag="div"
              codeTagProps={{
                style: {
                  whiteSpace: "pre",
                  display: "block",
                },
              }}
            >
              {String(children).replace(/\n$/, "")}
            </SyntaxHighlighter>
          </div>
        </ScrollArea>
      </div>
    );
  }

  // Code block without language
  return (
    <code
      className="relative rounded !bg-sidebar border border-muted-foreground/20 px-[0.3rem] py-[0.2rem] font-mono text-xs"
      style={{ wordBreak: "break-word" }}
    >
      {children}
    </code>
  );
};

const components: Partial<Components> = {
  code: CodeComponent,
  pre: ({ children }) => <>{children}</>,
  ol: ({ children, ...props }) => (
    <ol className="list-decimal list-outside ml-4" {...props}>
      {children}
    </ol>
  ),
  li: ({ children, ...props }) => (
    <li className="py-1" {...props}>
      {children}
    </li>
  ),
  ul: ({ children, ...props }) => (
    <ul className="list-disc list-outside ml-4" {...props}>
      {children}
    </ul>
  ),
  strong: ({ children, ...props }) => (
    <span className="font-semibold" {...props}>
      {children}
    </span>
  ),
  p: ({ children, ...props }) => (
    <p
      className="mb-2"
      style={{ wordBreak: "break-word", overflowWrap: "break-word" }}
      {...props}
    >
      {children}
    </p>
  ),
  a: ({ children, href, ...props }) => {
    // Check if the URL is external (starts with http/https) or internal
    const isExternal = href?.startsWith("http") || href?.startsWith("https");

    if (isExternal) {
      return (
        <a
          className="text-blue-500 hover:underline"
          style={{
            wordBreak: "break-word",
            overflowWrap: "break-word",
          }}
          href={href}
          target="_blank"
          rel="noreferrer"
          {...props}
        >
          {children}
        </a>
      );
    }

    return (
      <Link
        passHref
        className="text-blue-500 hover:underline"
        style={{
          wordBreak: "break-word",
          overflowWrap: "break-word",
        }}
        href={href || "#"}
        target="_blank"
        rel="noreferrer"
        {...props}
      >
        {children}
      </Link>
    );
  },
  h1: ({ children, ...props }) => (
    <h1
      className="text-3xl font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h1>
  ),
  h2: ({ children, ...props }) => (
    <h2
      className="text-2xl font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h2>
  ),
  h3: ({ children, ...props }) => (
    <h3
      className="text-xl font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h3>
  ),
  h4: ({ children, ...props }) => (
    <h4
      className="text-lg font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h4>
  ),
  h5: ({ children, ...props }) => (
    <h5
      className="text-base font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h5>
  ),
  h6: ({ children, ...props }) => (
    <h6
      className="text-sm font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h6>
  ),
  img: ({ alt, src, title, ...props }) => (
    <img
      className="max-w-full h-auto my-2 rounded"
      alt={alt}
      src={src}
      title={title}
      {...props}
    />
  ),
  blockquote: ({ children, ...props }) => (
    <blockquote
      className="border-l-4 border-gray-300 dark:border-gray-700 pl-4 italic my-4"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </blockquote>
  ),
  table: ({ children, ...props }) => (
    <ScrollArea className="w-140 border rounded-lg my-4">
      <Table className="w-full" {...props}>
        {children}
      </Table>
      <ScrollBar orientation="horizontal" />
    </ScrollArea>
  ),
  thead: ({ children, ...props }) => (
    <TableHeader {...props}>{children}</TableHeader>
  ),
  tbody: ({ children, ...props }) => (
    <TableBody {...props}>{children}</TableBody>
  ),
  tfoot: ({ children, ...props }) => (
    <TableFooter {...props}>{children}</TableFooter>
  ),
  tr: ({ children, ...props }) => <TableRow {...props}>{children}</TableRow>,
  th: ({ children, ...props }) => <TableHead {...props}>{children}</TableHead>,
  td: ({ children, ...props }) => <TableCell {...props}>{children}</TableCell>,
  hr: () => <Separator className="my-8 h-1" />,
};

const remarkPlugins = [remarkGfm];
const rehypePlugins = [rehypeRaw];

// Function to process citations and convert them to proper format
const processCitations = (
  content: string,
  repoUrl?: string,
  branch?: string
): string => {
  // Match citations in format ã€F:filenameâ€ L1-L1ã€‘
  const citationRegex = /ã€F:([^â€ ]+)â€ L(\d+)-L(\d+)ã€‘/g;

  return content.replace(
    citationRegex,
    (match, filename, startLine, endLine) => {
      const displayText =
        startLine === endLine
          ? `${filename}:${startLine}`
          : `${filename}:${startLine}-${endLine}`;

      const repoBaseUrl = repoUrl ? `${repoUrl}/blob/${branch || "main"}` : "#";
      const linkUrl =
        startLine === endLine
          ? `${repoBaseUrl}/${filename}#L${startLine}`
          : `${repoBaseUrl}/${filename}#L${startLine}-L${endLine}`;

      return `[${displayText}](${linkUrl}) `;
    }
  );
};

interface MarkdownProps {
  children: string;
  repoUrl?: string;
  branch?: string;
}

const NonMemoizedMarkdown = ({ children, repoUrl, branch }: MarkdownProps) => {
  const processedContent = processCitations(children, repoUrl, branch);

  return (
    <div style={{ width: "100%", maxWidth: "100%" }}>
      <ReactMarkdown
        remarkPlugins={remarkPlugins}
        rehypePlugins={rehypePlugins}
        components={components}
      >
        {processedContent}
      </ReactMarkdown>
    </div>
  );
};

export const Markdown = memo(
  NonMemoizedMarkdown,
  (prevProps, nextProps) =>
    prevProps.children === nextProps.children &&
    prevProps.repoUrl === nextProps.repoUrl &&
    prevProps.branch === nextProps.branch
);



================================================
FILE: templates/codex-clone/components/navbar.tsx
================================================
import { Dot } from "lucide-react";
import Link from "next/link";

import { ThemeToggle } from "@/components/ui/theme-toggle";

export default function Navbar() {
  return (
    <div className="flex justify-between items-center">
      <Link href="/" passHref>
        <h1 className="text-lg font-bold">VibeX</h1>
      </Link>
      <div className="flex items-center gap-2">
        <div className="flex items-center gap-0">
          <Link
            href="/"
            className="hover:opacity-45 transition-opacity duration-300"
          >
            Home
          </Link>
          <Dot className="text-muted-foreground/40" />
          <Link
            href="/environments"
            className="hover:opacity-45 transition-opacity duration-300"
          >
            Environments
          </Link>
        </div>
        <ThemeToggle />
      </div>
    </div>
  );
}



================================================
FILE: templates/codex-clone/components/streaming-indicator.tsx
================================================
import { cn } from "@/lib/utils"

interface StreamingIndicatorProps {
  className?: string
  size?: "sm" | "md" | "lg"
  variant?: "dots" | "cursor" | "wave"
}

export function StreamingIndicator({ 
  className, 
  size = "md", 
  variant = "dots" 
}: StreamingIndicatorProps) {
  const sizeClasses = {
    sm: "gap-0.5",
    md: "gap-1",
    lg: "gap-1.5"
  }

  const dotSizeClasses = {
    sm: "w-1 h-1",
    md: "w-1.5 h-1.5",
    lg: "w-2 h-2"
  }

  if (variant === "cursor") {
    return (
      <span className={cn(
        "inline-block w-0.5 h-4 bg-primary animate-pulse",
        className
      )} />
    )
  }

  if (variant === "wave") {
    return (
      <div className={cn("flex items-center", sizeClasses[size], className)}>
        {[0, 1, 2].map((i) => (
          <div
            key={i}
            className={cn(
              "bg-primary/70 rounded-full animate-bounce",
              dotSizeClasses[size]
            )}
            style={{
              animationDelay: `${i * 0.15}s`,
              animationDuration: "1s"
            }}
          />
        ))}
      </div>
    )
  }

  // Default dots variant
  return (
    <div className={cn("flex items-center", sizeClasses[size], className)}>
      {[0, 1, 2].map((i) => (
        <div
          key={i}
          className={cn(
            "bg-primary/60 rounded-full animate-pulse",
            dotSizeClasses[size]
          )}
          style={{
            animationDelay: `${i * 0.2}s`,
            animationDuration: "1.4s"
          }}
        />
      ))}
    </div>
  )
}


================================================
FILE: templates/codex-clone/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: templates/codex-clone/components/ui/dialog.tsx
================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}



================================================
FILE: templates/codex-clone/components/ui/scroll-area.tsx
================================================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }



================================================
FILE: templates/codex-clone/components/ui/select.tsx
================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}



================================================
FILE: templates/codex-clone/components/ui/separator.tsx
================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }



================================================
FILE: templates/codex-clone/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: templates/codex-clone/components/ui/table.tsx
================================================
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}



================================================
FILE: templates/codex-clone/components/ui/tabs.tsx
================================================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: templates/codex-clone/components/ui/text-shimmer.tsx
================================================
"use client";
import React, { useMemo, type JSX } from "react";
import { motion } from "framer-motion";
import { cn } from "@/lib/utils";

interface TextShimmerProps {
  children: string;
  as?: React.ElementType;
  className?: string;
  duration?: number;
  spread?: number;
}

export function TextShimmer({
  children,
  as: Component = "p",
  className,
  duration = 2,
  spread = 2,
}: TextShimmerProps) {
  const MotionComponent = motion(Component as keyof JSX.IntrinsicElements);

  const dynamicSpread = useMemo(() => {
    return children.length * spread;
  }, [children, spread]);

  return (
    <MotionComponent
      className={cn(
        "relative inline-block bg-[length:250%_100%,auto] bg-clip-text",
        "text-transparent [--base-color:#a1a1aa] [--base-gradient-color:#000]",
        "[--bg:linear-gradient(90deg,#0000_calc(50%-var(--spread)),var(--base-gradient-color),#0000_calc(50%+var(--spread)))] [background-repeat:no-repeat,padding-box]",
        "dark:[--base-color:#71717a] dark:[--base-gradient-color:#ffffff] dark:[--bg:linear-gradient(90deg,#0000_calc(50%-var(--spread)),var(--base-gradient-color),#0000_calc(50%+var(--spread)))]",
        className
      )}
      initial={{ backgroundPosition: "100% center" }}
      animate={{ backgroundPosition: "0% center" }}
      transition={{
        repeat: Infinity,
        duration,
        ease: "linear",
      }}
      style={
        {
          "--spread": `${dynamicSpread}px`,
          backgroundImage: `var(--bg), linear-gradient(var(--base-color), var(--base-color))`,
        } as React.CSSProperties
      }
    >
      {children}
    </MotionComponent>
  );
}



================================================
FILE: templates/codex-clone/components/ui/theme-toggle.tsx
================================================
"use client"

import * as React from "react"
import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"

import { Button } from "@/components/ui/button"

export function ThemeToggle() {
  const { theme, setTheme } = useTheme()
  const [mounted, setMounted] = React.useState(false)

  React.useEffect(() => {
    setMounted(true)
  }, [])

  if (!mounted) {
    return (
      <Button variant="ghost" size="icon" disabled>
        <Sun className="h-[1.2rem] w-[1.2rem]" />
        <span className="sr-only">Toggle theme</span>
      </Button>
    )
  }

  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
    >
      <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
      <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
      <span className="sr-only">Toggle theme</span>
    </Button>
  )
}


================================================
FILE: templates/codex-clone/components/ui/tooltip.tsx
================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



================================================
FILE: templates/codex-clone/hooks/use-github-auth.ts
================================================
"use client";

import { useState, useEffect } from "react";
import { GitHubRepository, GitHubUser, GitHubBranch } from "@/lib/github";

interface UseGitHubAuthReturn {
  isAuthenticated: boolean;
  user: GitHubUser | null;
  repositories: GitHubRepository[];
  branches: GitHubBranch[];
  isLoading: boolean;
  error: string | null;
  login: () => Promise<void>;
  logout: () => void;
  fetchRepositories: () => Promise<void>;
  fetchBranches: (repositoryName: string) => Promise<void>;
}

export function useGitHubAuth(): UseGitHubAuthReturn {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState<GitHubUser | null>(null);
  const [repositories, setRepositories] = useState<GitHubRepository[]>([]);
  const [branches, setBranches] = useState<GitHubBranch[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Check authentication status on mount
  useEffect(() => {
    const abortController = new AbortController();
    
    const checkAuth = async () => {
      try {
        setIsLoading(true);
        const userCookie = document.cookie
          .split("; ")
          .find((row) => row.startsWith("github_user="));

        if (userCookie) {
          const userData = JSON.parse(
            decodeURIComponent(userCookie.split("=")[1])
          );

          // Verify the access token is still valid by making a test API call
          const response = await fetch("/api/auth/github/repositories", {
            signal: abortController.signal,
          });

          if (response.ok) {
            setUser(userData);
            setIsAuthenticated(true);
          } else {
            // Token is invalid, clear cookies and auth state
            document.cookie =
              "github_access_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie =
              "github_user=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            setIsAuthenticated(false);
            setUser(null);
          }
        } else {
          setIsAuthenticated(false);
          setUser(null);
        }
      } catch (error) {
        if (error instanceof Error && error.name === 'AbortError') {
          // Ignore abort errors
          return;
        }
        console.error("Error checking auth status:", error);
        setIsAuthenticated(false);
        setUser(null);
      } finally {
        if (!abortController.signal.aborted) {
          setIsLoading(false);
        }
      }
    };

    checkAuth();
    
    return () => {
      abortController.abort("Component unmounted");
    };
  }, []);

  // Listen for auth success from popup
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (event.data.type === "GITHUB_AUTH_SUCCESS") {
        // Wait a bit for cookies to be set, then check auth status
        setTimeout(() => {
          // Instead of reloading the page, just check auth status again
          const userCookie = document.cookie
            .split("; ")
            .find((row) => row.startsWith("github_user="));

          if (userCookie) {
            try {
              const userData = JSON.parse(
                decodeURIComponent(userCookie.split("=")[1])
              );
              setUser(userData);
              setIsAuthenticated(true);
              setIsLoading(false);
            } catch (error) {
              console.error("Error parsing user data:", error);
              setIsAuthenticated(false);
              setUser(null);
              setIsLoading(false);
            }
          }
        }, 1000);
      }
    };

    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  }, []);

  const login = async (): Promise<void> => {
    try {
      setIsLoading(true);
      setError(null);

      // Get the auth URL from our API
      const response = await fetch("/api/auth/github/url");
      const { url } = await response.json();

      // Open popup window for OAuth (centered on screen)
      const width = 600;
      const height = 700;
      const left = (window.screen.width - width) / 2;
      const top = (window.screen.height - height) / 2;

      const popup = window.open(
        url,
        "github-oauth",
        `width=${width},height=${height},left=${left},top=${top},scrollbars=yes,resizable=yes`
      );

      // Check if popup was blocked
      if (!popup) {
        throw new Error("Popup blocked. Please allow popups for this site.");
      }

      // Wait for popup to close
      const checkClosed = setInterval(() => {
        if (popup.closed) {
          clearInterval(checkClosed);
          setIsLoading(false);
        }
      }, 1000);
    } catch (error) {
      setError(
        error instanceof Error ? error.message : "Authentication failed"
      );
      setIsLoading(false);
    }
  };

  const logout = (): void => {
    // Clear cookies
    document.cookie =
      "github_access_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
    document.cookie =
      "github_user=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";

    setIsAuthenticated(false);
    setUser(null);
    setRepositories([]);
    setBranches([]);
  };

  const fetchRepositories = async (): Promise<void> => {
    if (!isAuthenticated) return;
    console.log("isAuthenticated", isAuthenticated);
    
    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch("/api/auth/github/repositories");

      if (!response.ok) {
        throw new Error("Failed to fetch repositories");
      }

      const data = await response.json();
      setRepositories(data.repositories || []);
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        // Ignore abort errors
        return;
      }
      setError(
        error instanceof Error ? error.message : "Failed to fetch repositories"
      );
    } finally {
      setIsLoading(false);
    }
  };

  const fetchBranches = async (repositoryName: string): Promise<void> => {
    try {
      setIsLoading(true);
      setError(null);

      // Parse repository name to extract owner and repo
      // Repository name should be in format "owner/repo"
      const [owner, repo] = repositoryName.split("/");

      if (!owner || !repo) {
        throw new Error('Repository name must be in format "owner/repo"');
      }

      const response = await fetch(
        `/api/auth/github/branches?owner=${encodeURIComponent(
          owner
        )}&repo=${encodeURIComponent(repo)}`
      );

      if (!response.ok) {
        throw new Error("Failed to fetch branches");
      }

      const data = await response.json();
      setBranches(data.branches || []);
    } catch (error) {
      setError(
        error instanceof Error ? error.message : "Failed to fetch branches"
      );
    } finally {
      setIsLoading(false);
    }
  };

  return {
    isAuthenticated,
    user,
    repositories,
    branches,
    isLoading,
    error,
    login,
    logout,
    fetchRepositories,
    fetchBranches,
  };
}



================================================
FILE: templates/codex-clone/lib/github.ts
================================================
export interface GitHubBranch {
  name: string;
  commit: {
    sha: string;
    url: string;
  };
  protected: boolean;
  isDefault: boolean;
}

export interface GitHubRepository {
  id: number;
  name: string;
  full_name: string;
  private: boolean;
  description?: string;
  html_url: string;
  default_branch: string;
  fork: boolean;
  permissions?: {
    admin: boolean;
    push: boolean;
    pull: boolean;
  };
}

export interface GitHubUser {
  id: number;
  login: string;
  avatar_url: string;
  name?: string;
  email?: string;
}

export class GitHubAuth {
  private clientId: string;
  private clientSecret: string;
  private redirectUri: string;

  constructor() {
    this.clientId = process.env.GITHUB_CLIENT_ID!;
    this.clientSecret = process.env.GITHUB_CLIENT_SECRET!;
    this.redirectUri =
      process.env.NODE_ENV === "production"
        ? "https://clonedex.vercel.app/api/auth/github/callback"
        : "http://localhost:3000/api/auth/github/callback";
  }

  // Generate GitHub OAuth URL
  getAuthUrl(state?: string): string {
    const params = new URLSearchParams({
      client_id: this.clientId,
      redirect_uri: this.redirectUri,
      scope: "repo user:email",
      state: state || Math.random().toString(36).substring(7),
    });

    return `https://github.com/login/oauth/authorize?${params.toString()}`;
  }

  // Exchange code for access token
  async exchangeCodeForToken(code: string): Promise<string> {
    const response = await fetch(
      "https://github.com/login/oauth/access_token",
      {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          client_id: this.clientId,
          client_secret: this.clientSecret,
          code,
        }),
      }
    );

    const data = await response.json();

    if (data.error) {
      throw new Error(`GitHub OAuth error: ${data.error_description}`);
    }

    return data.access_token;
  }

  // Get user information
  async getUser(accessToken: string): Promise<GitHubUser> {
    const response = await fetch("https://api.github.com/user", {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/vnd.github.v3+json",
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch user: ${response.statusText}`);
    }

    return response.json();
  }

  // Get user repositories
  async getUserRepositories(accessToken: string): Promise<GitHubRepository[]> {
    const response = await fetch(
      "https://api.github.com/user/repos?sort=updated&per_page=100",
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: "application/vnd.github.v3+json",
        },
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to fetch repositories: ${response.statusText}`);
    }

    return response.json();
  }

  // Create a pull request
  async createPullRequest(
    accessToken: string,
    owner: string,
    repo: string,
    title: string,
    body: string,
    head: string,
    base: string = "main"
  ) {
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/pulls`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: "application/vnd.github.v3+json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          title,
          body,
          head,
          base,
        }),
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to create pull request: ${response.statusText}`);
    }

    return response.json();
  }
}

export const githubAuth = new GitHubAuth();



================================================
FILE: templates/codex-clone/lib/inngest.ts
================================================
import { Inngest } from "inngest";
import { realtimeMiddleware, channel, topic } from "@inngest/realtime";
import { VibeKit, VibeKitConfig } from "@vibe-kit/sdk";

// Create a client to send and receive events
export const inngest = new Inngest({
  id: "clonedex",
  middleware: [realtimeMiddleware()],
});

export const taskChannel = channel("tasks")
  .addTopic(
    topic("status").type<{
      taskId: string;
      status: "IN_PROGRESS" | "DONE" | "MERGED";
      sessionId: string;
    }>()
  )
  .addTopic(
    topic("update").type<{
      taskId: string;
      message: Record<string, unknown>;
    }>()
  );

// Helper function to simulate streaming by chunking text
function* chunkText(text: string, chunkSize: number = 10): Generator<string, void, unknown> {
  const words = text.split(' ');
  for (let i = 0; i < words.length; i += chunkSize) {
    yield words.slice(i, i + chunkSize).join(' ') + (i + chunkSize < words.length ? ' ' : '');
  }
}

export const createTask = inngest.createFunction(
  { id: "create-task" },
  { event: "clonedex/create.task" },
  async ({ event, step, publish }) => {
    const { task, token, sessionId, prompt } = event.data;
    const config: VibeKitConfig = {
      agent: {
        type: "codex",
        model: {
          apiKey: process.env.OPENAI_API_KEY!,
        },
      },
      environment: {
        e2b: {
          apiKey: process.env.E2B_API_KEY!,
        },
      },
      github: {
        token,
        repository: task.repository,
      },
    };

    const result = await step.run("generate-code", async () => {
      const vibekit = new VibeKit(config);

      if (sessionId) {
        await vibekit.setSession(sessionId);
      }

      const response = await vibekit.generateCode({
        prompt: prompt || task.title,
        mode: task.mode,
        callbacks: {
          onUpdate(message) {
            try {
              const parsedMessage = JSON.parse(message);
              
              // For assistant messages, implement streaming
              if (parsedMessage.type === "message" && parsedMessage.role === "assistant") {
                const messageId = parsedMessage.data?.id || crypto.randomUUID();
                const fullText = parsedMessage.data?.text || "";
                
                // Stream the message in chunks
                let accumulatedText = "";
                const chunks = Array.from(chunkText(fullText, 5)); // 5 words per chunk
                
                chunks.forEach((chunk, index) => {
                  accumulatedText += chunk;
                  
                  setTimeout(() => {
                    publish(
                      taskChannel().update({
                        taskId: task.id,
                        message: {
                          ...parsedMessage,
                          data: {
                            ...parsedMessage.data,
                            id: messageId,
                            text: accumulatedText,
                            isStreaming: index < chunks.length - 1,
                            streamId: messageId,
                            chunkIndex: index,
                            totalChunks: chunks.length,
                          }
                        },
                      })
                    );
                  }, index * 50); // 50ms delay between chunks for smooth streaming
                });
              } else {
                // Non-message updates (like git operations, etc.)
                publish(
                  taskChannel().update({
                    taskId: task.id,
                    message: parsedMessage,
                  })
                );
              }
            } catch {
              // If it's not JSON, it might be raw streaming output
              // Create a streaming message for it
              const streamId = `stream-${Date.now()}`;
              publish(
                taskChannel().update({
                  taskId: task.id,
                  message: {
                    type: "message",
                    role: "assistant",
                    data: {
                      text: message,
                      isStreaming: true,
                      streamId: streamId,
                      raw: true
                    }
                  },
                })
              );
            }
          },
        },
      });

      await vibekit.pause();

      return response;
    });

    if ("stdout" in result) {
      const lines = result.stdout.trim().split("\n");
      const parsedLines = lines.map((line) => JSON.parse(line));
      await publish(
        taskChannel().status({
          taskId: task.id,
          status: "DONE",
          sessionId: result.sandboxId,
        })
      );

      return { message: parsedLines };
    } else {
      return { message: result };
    }
  }
);

let app: Inngest | undefined;

export const getInngestApp = () => {
  return (app ??= new Inngest({
    id: typeof window !== "undefined" ? "client" : "server",
    middleware: [realtimeMiddleware()],
  }));
};



================================================
FILE: templates/codex-clone/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}



================================================
FILE: templates/codex-clone/stores/environments.ts
================================================
import { create } from "zustand";
import { persist } from "zustand/middleware";

export interface Environment {
  id: string;
  name: string;
  description: string;
  githubOrganization: string;
  githubToken: string;
  githubRepository: string;
  createdAt: Date;
  updatedAt: Date;
}

interface EnvironmentStore {
  environments: Environment[];
  createEnvironment: (
    environment: Omit<Environment, "id" | "createdAt" | "updatedAt">
  ) => void;
  updateEnvironment: (
    id: string,
    updates: Partial<Omit<Environment, "id" | "createdAt" | "updatedAt">>
  ) => void;
  deleteEnvironment: (id: string) => void;
  listEnvironments: () => Environment[];
}

export const useEnvironmentStore = create<EnvironmentStore>()(
  persist(
    (set, get) => ({
      environments: [],

      createEnvironment: (environment) => {
        const now = new Date();
        const newEnvironment = {
          ...environment,
          id: crypto.randomUUID(),
          createdAt: now,
          updatedAt: now,
        };
        set((state) => ({
          environments: [...state.environments, newEnvironment],
        }));
      },

      updateEnvironment: (id, updates) => {
        set((state) => ({
          environments: state.environments.map((env) =>
            env.id === id ? { ...env, ...updates, updatedAt: new Date() } : env
          ),
        }));
      },

      deleteEnvironment: (id) => {
        set((state) => ({
          environments: state.environments.filter((env) => env.id !== id),
        }));
      },

      listEnvironments: () => get().environments,
    }),
    {
      name: "environments",
    }
  )
);



================================================
FILE: templates/codex-clone/stores/tasks.ts
================================================
// stores/useTaskStore.ts
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { PullRequestResponse } from "@vibe-kit/sdk";

type TaskStatus = "IN_PROGRESS" | "DONE" | "MERGED";

export interface Task {
  id: string;
  title: string;
  description: string;
  messages: {
    role: "user" | "assistant";
    type: string;
    data: Record<string, unknown>;
  }[];
  status: TaskStatus;
  branch: string;
  sessionId: string;
  repository: string;
  createdAt: string;
  updatedAt: string;
  statusMessage?: string;
  isArchived: boolean;
  mode: "code" | "ask";
  hasChanges: boolean;
  pullRequest?: PullRequestResponse;
}

interface TaskStore {
  tasks: Task[];
  addTask: (
    task: Omit<Task, "id" | "createdAt" | "updatedAt" | "isArchived">
  ) => Task;
  updateTask: (
    id: string,
    updates: Partial<Omit<Task, "id" | "createdAt">>
  ) => void;
  setTasks: (tasks: Task[]) => void;
  removeTask: (id: string) => void;
  archiveTask: (id: string) => void;
  unarchiveTask: (id: string) => void;
  clear: () => void;
  getTasks: () => Task[];
  getActiveTasks: () => Task[];
  getArchivedTasks: () => Task[];
  getTaskById: (id: string) => Task | undefined;
  getTasksByStatus: (status: TaskStatus) => Task[];
  getTasksBySessionId: (sessionId: string) => Task[];
}

export const useTaskStore = create<TaskStore>()(
  persist(
    (set, get) => ({
      tasks: [],
      addTask: (task) => {
        const now = new Date().toISOString();
        const id = crypto.randomUUID();
        const newTask = {
          ...task,
          id,
          createdAt: now,
          updatedAt: now,
          isArchived: false,
        };
        set((state) => ({
          tasks: [...state.tasks, newTask],
        }));
        return newTask;
      },
      updateTask: (id, updates) => {
        set((state) => ({
          tasks: state.tasks.map((task) =>
            task.id === id
              ? { ...task, ...updates, updatedAt: new Date().toISOString() }
              : task
          ),
        }));
      },
      setTasks: (tasks) => set(() => ({ tasks })),
      removeTask: (id) => {
        set((state) => ({
          tasks: state.tasks.filter((task) => task.id !== id),
        }));
      },
      archiveTask: (id) => {
        set((state) => ({
          tasks: state.tasks.map((task) =>
            task.id === id
              ? {
                  ...task,
                  isArchived: true,
                  updatedAt: new Date().toISOString(),
                }
              : task
          ),
        }));
      },
      unarchiveTask: (id) => {
        set((state) => ({
          tasks: state.tasks.map((task) =>
            task.id === id
              ? {
                  ...task,
                  isArchived: false,
                  updatedAt: new Date().toISOString(),
                }
              : task
          ),
        }));
      },
      clear: () => set({ tasks: [] }),
      getTasks: () => get().tasks,
      getActiveTasks: () =>
        get()
          .tasks.filter((task) => !task.isArchived)
          .reverse(),
      getArchivedTasks: () => get().tasks.filter((task) => task.isArchived),
      getTaskById: (id) => get().tasks.find((task) => task.id === id),
      getTasksByStatus: (status) =>
        get().tasks.filter((task) => task.status === status),
      getTasksBySessionId: (sessionId) =>
        get().tasks.filter((task) => task.sessionId === sessionId),
    }),
    {
      name: "task-store", // key in localStorage
      // Optionally, customize storage or partialize which fields to persist
      // storage: () => sessionStorage, // for sessionStorage instead
    }
  )
);



================================================
FILE: templates/v0-clone/README.md
================================================
# Vibe0 (v0-clone)

A Next.js app template powered by VibeKit SDK, Inngest, Convex, and Anthropic Claude. This application enables collaborative AI-driven development with real-time updates, GitHub integration, and sandboxed code execution using Northflank.

## âœ¨ Features

- ðŸ¤– AI-powered code generation using Anthropic Claude
- ðŸ”„ Real-time task updates with Inngest
- ðŸ™ GitHub integration for repository management
- ðŸ—ï¸ Sandboxed environment execution with Northflank
- ðŸ“¦ State management with Convex
- ðŸŽ¨ Modern UI with Tailwind CSS and shadcn/ui
- ðŸ—ƒï¸ TypeScript-first, modular architecture

## ðŸš€ Prerequisites

Before you begin, make sure you have:

- **Node.js** (v18 or higher)
- **npm** or **yarn**
- **Inngest CLI** (for local development)
- **Convex account** (for state management)
- **Anthropic API key**
- **Northflank API key and project ID**
- **GitHub OAuth app** (for GitHub integration)

## ðŸ“¦ Installation

### 1. Install Dependencies

```bash
npm install
```

### 2. Install Inngest CLI

The Inngest CLI is required for running background functions locally:

```bash
# Install globally
npm install -g inngest

# Or using npx (recommended)
npx inngest-cli@latest
```

### 3. Set Up Environment Variables

Create a `.env.local` file in the root directory with the following variables:

```bash
# Anthropic Claude API Key
ANTHROPIC_API_KEY=your_anthropic_api_key_here

# Northflank Configuration
NORTHFLANK_API_KEY=your_northflank_api_key_here
NORTHFLANK_PROJECT_ID=your_northflank_project_id_here

# Convex Configuration
NEXT_PUBLIC_CONVEX_URL=your_convex_url_here

# GitHub OAuth Configuration
AUTH_GITHUB_ID=your_github_client_id
AUTH_GITHUB_SECRET=your_github_client_secret
```

#### Getting API Keys:

- **Anthropic API Key**: Get it from [Anthropic Console](https://console.anthropic.com/)
- **Northflank API Key/Project ID**: [Northflank Dashboard](https://northflank.com/)
- **Convex URL**: [Convex Console](https://dashboard.convex.dev/)
- **GitHub OAuth**: Create a new OAuth app in your [GitHub Developer Settings](https://github.com/settings/developers)

## ðŸ› ï¸ Development

### 1. Start the Inngest Dev Server

In one terminal, start the Inngest development server:

```bash
npx inngest-cli@latest dev
```

This will start the Inngest development server on `http://localhost:8288`.

### 2. Start the Next.js Development Server

In another terminal, start the Next.js application:

```bash
npm run dev
```

The application will be available at `http://localhost:3000`.

## ðŸ“‹ Available Scripts

- `npm run dev` - Start the development server
- `npm run build` - Build the application for production
- `npm start` - Start the production server
- `npm run lint` - Run ESLint for code quality

## ðŸ—ï¸ Project Structure

```
â”œâ”€â”€ app/                    # Next.js App Router
â”‚   â”œâ”€â”€ actions/            # Server actions
â”‚   â”œâ”€â”€ api/                # API routes
â”‚   â””â”€â”€ session/            # Session pages
â”œâ”€â”€ components/             # Reusable UI components
â”‚   â””â”€â”€ ui/                 # shadcn/ui components
â”œâ”€â”€ convex/                 # Convex schema and functions
â”œâ”€â”€ lib/                    # Utility libraries and configurations
â”œâ”€â”€ providers/              # React providers (auth, convex, theme)
â”œâ”€â”€ public/                 # Static assets
```

## ðŸ”§ Configuration

### Inngest Functions

The application uses Inngest for background task processing. Main functions are defined in `lib/inngest.ts` and handle AI code generation, session management, and real-time updates.

### VibeKit Integration

The app integrates with VibeKit SDK for AI code generation, supporting:

- Anthropic Claude as the AI model
- Northflank for sandboxed environments
- GitHub repository integration
- Real-time streaming updates

### Convex

Convex is used for state management and real-time data sync. See the `convex/` directory for schema and server functions.

## ðŸŒ Deployment

### Environment Variables for Production

Set all required environment variables in your production environment:

```bash
AUTH_GITHUB_ID=
AUTH_GITHUB_SECRET=
NORTHFLANK_API_KEY=
NORTHFLANK_PROJECT_ID=
NEXT_PUBLIC_CONVEX_URL=
ANTHROPIC_API_KEY=
```

### Deploy to Vercel

1. Connect your repository to Vercel
2. Set the environment variables in the Vercel dashboard
3. Deploy

### Inngest in Production

For production, configure Inngest properly:

1. Set up an Inngest account at [inngest.com](https://inngest.com)
2. Configure your production Inngest endpoint
3. Update your deployment to use the production Inngest configuration

## ðŸ¤ Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## ðŸ“„ License

This project is licensed under the MIT License.

## ðŸ†˜ Troubleshooting

### Common Issues

1. **Inngest functions not working**: Make sure the Inngest CLI is running (`npx inngest-cli@latest dev`)
2. **API key errors**: Verify all environment variables are set correctly
3. **GitHub OAuth issues**: Check your GitHub OAuth app configuration and callback URLs
4. **Northflank connection problems**: Ensure your Northflank API key and project ID are valid
5. **Convex issues**: Make sure your Convex URL is correct and your account is active

### Getting Help

- Check the [Inngest Documentation](https://www.inngest.com/docs)
- Visit [VibeKit Documentation](https://vibekit.dev/docs)
- Review [Next.js Documentation](https://nextjs.org/docs)
- See [Convex Documentation](https://docs.convex.dev/)
- Explore [Anthropic API Docs](https://docs.anthropic.com/claude)
- Visit [Northflank Docs](https://northflank.com/docs)

---

Built with â¤ï¸ using Next.js, VibeKit, Inngest, Convex, and Anthropic Claude



================================================
FILE: templates/v0-clone/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: templates/v0-clone/config.ts
================================================
export interface Template {
  id: string;
  name: string;
  description: string;
  repository: string;
  logos: string[];
  image?: string;
  startCommands: {
    command: string;
    status: "INSTALLING_DEPENDENCIES" | "STARTING_DEV_SERVER";
    background?: boolean;
  }[];
  secrets?: Record<string, string>;
  systemPrompt: string;
}

export const templates: Template[] = [
  {
    id: "nextjs",
    name: "Next.js",
    description:
      "Build scalable web applications with server-side rendering, static site generation, and API routes",
    repository: "https://github.com/superagent-ai/vibekit-nextjs",
    logos: ["nextjs.svg"],
    startCommands: [
      {
        command: "npm i",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "npm run dev",
        status: "STARTING_DEV_SERVER",
        background: true,
      },
    ],
    systemPrompt:
      "# GOAL\nYou are an helpful assistant that is tasked with helping the user build a NextJS app.\n" +
      "- The NextJS dev server is running on port 3000.\n" +
      "- ShadCN UI is installed, togehter with all the ShadCN components.\n",
  },
  {
    id: "nextjs-supabase-auth",
    name: "Next.js + Supabase + Auth",
    description:
      "Build a production-ready SaaS with authentication, database, and real-time features out of the box",
    repository:
      "https://github.com/vercel/next.js/tree/canary/examples/with-supabase",
    logos: ["nextjs.svg", "supabase.jpeg"],
    startCommands: [
      {
        command: "npm i",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "npm run dev",
        status: "STARTING_DEV_SERVER",
        background: true,
      },
    ],
    systemPrompt:
      "# GOAL\nYou are an helpful assistant that is tasked with helping the user build a NextJS app.\n" +
      "- The NextJS dev server is running on port 3000.\n" +
      "- ShadCN UI is installed, togehter with all the ShadCN components.\n" +
      "- Supabase CLI and Auth is installed and ready to be used if needed.\n",
  },
  {
    id: "nextjs-convex-clerk",
    name: "Next.js + Convex + Clerk",
    description:
      "Create collaborative apps with real-time sync, instant auth, and seamless user management",
    repository: "https://github.com/get-convex/convex-clerk-users-table",
    logos: ["nextjs.svg", "convex.webp", "clerk.svg"],
    startCommands: [
      {
        command: "npm i",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "npm run dev",
        status: "STARTING_DEV_SERVER",
        background: true,
      },
      {
        command: "npx convex dev",
        status: "STARTING_DEV_SERVER",
        background: true,
      },
    ],
    systemPrompt:
      "# GOAL\nYou are an helpful assistant that is tasked with helping the user build a NextJS app.\n" +
      "- The NextJS dev server is running on port 3000.\n" +
      "- The convex command npx convex dev is running\n" +
      "- ShadCN UI is installed, togehter with all the ShadCN components.\n" +
      "- Convex CLI is is installed and ready to be used if needed.\n",
  },
  {
    id: "shopify-hydrogen",
    name: "Shopify",
    description:
      "Build fast headless commerce storefronts with Shopify's official framework Hydrogen.",
    repository: "superagent-ai/vibekit-shopify",
    logos: ["shopify.jpeg"],
    startCommands: [
      {
        command: "npm i",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "npm i -g @shopify/cli@latest",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "echo 'SESSION_SECRET=\"foobar\"' > .env",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "shopify hydrogen dev --codegen --host",
        background: true,
        status: "STARTING_DEV_SERVER",
      },
    ],
    secrets: {
      SESSION_SECRET: "foobar",
    },
    systemPrompt:
      "# GOAL\nYou are an helpful assistant that is tasked with helping the user build a Shopify Hydrogen app.\n" +
      "- The hydrogen server is running on port 3000.\n" +
      "- The Shopify CLI is installed and ready to be used if needed.\n",
  },
  {
    id: "fastapi-nextjs",
    name: "FastAPI + Next.js",
    description:
      "Build modern full-stack apps with FastAPI backend and Next.js frontend.",
    repository: "tiangolo/full-stack-fastapi-template",
    logos: ["nextjs.svg", "fastapi.jpg"],
    startCommands: [
      {
        command: "npm i",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "npm run dev",
        status: "STARTING_DEV_SERVER",
        background: true,
      },
    ],
    systemPrompt:
      "# GOAL\nYou are an helpful assistant that is tasked with helping the user build a FastAPI and Next.js app.\n" +
      "- The NextJS dev server is running on port 3000.\n" +
      "- The FastAPI server is running on port 8000.\n" +
      "- ShadCN UI is installed, togehter with all the ShadCN components.\n",
  },
];



================================================
FILE: templates/v0-clone/eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;



================================================
FILE: templates/v0-clone/middleware.ts
================================================
export { auth as middleware } from "@/lib/auth";



================================================
FILE: templates/v0-clone/next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;



================================================
FILE: templates/v0-clone/package.json
================================================
{
  "name": "v0-clone",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.2.12",
    "@hookform/resolvers": "^5.1.1",
    "@inngest/realtime": "^0.3.1",
    "@octokit/rest": "^22.0.0",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-tabs": "^1.1.12",
    "@vibe-kit/sdk": "^0.0.39",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "convex": "^1.25.0",
    "diff": "^8.0.2",
    "framer-motion": "^12.19.1",
    "inngest": "^3.39.2",
    "lucide-react": "^0.523.0",
    "next": "15.3.4",
    "next-auth": "^5.0.0-beta.29",
    "next-themes": "^0.4.6",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7.58.1",
    "react-markdown": "^10.1.0",
    "react-remove-scroll": "^2.7.1",
    "react-syntax-highlighter": "^15.6.1",
    "rehype-raw": "^7.0.0",
    "remark-gfm": "^4.0.1",
    "tailwind-merge": "^3.3.1",
    "usehooks-ts": "^3.1.1",
    "zod": "^3.25.67"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/react-syntax-highlighter": "^15.5.13",
    "eslint": "^9",
    "eslint-config-next": "15.3.4",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.4",
    "typescript": "^5"
  }
}



================================================
FILE: templates/v0-clone/postcss.config.mjs
================================================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;



================================================
FILE: templates/v0-clone/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: templates/v0-clone/.env.example
================================================
ANTHROPIC_API_KEY=

NORTHFLANK_API_KEY=
NORTHFLANK_PROJECT_ID=vibe0

CONVEX_DEPLOYMENT=

NEXT_PUBLIC_CONVEX_URL=

AUTH_SECRET=vibe0
AUTH_GITHUB_ID=
AUTH_GITHUB_SECRET=
NEXTAUTH_URL=http://localhost:3000


================================================
FILE: templates/v0-clone/app/client-page.tsx
================================================
"use client";

import { useRouter } from "next/navigation";
import { useState } from "react";
import { useMutation } from "convex/react";
import { useSession } from "next-auth/react";
import Link from "next/link";

import { api } from "@/convex/_generated/api";

import ChatForm from "@/components/chat/chat-form";
import TemplatesSection from "@/components/templates-section";
import LoginDialog from "@/components/login-dialog";
import { createSessionAction } from "./actions/vibekit";
import { Repo } from "./actions/github";
import { templates } from "@/config";

export default function ClientPage() {
  const { data: session } = useSession();
  const [isLoginDialogOpen, setIsLoginDialogOpen] = useState(false);
  const router = useRouter();
  const createSession = useMutation(api.sessions.create);
  const addMessage = useMutation(api.messages.add);

  const handleChatSubmit = async (message: string, repository?: Repo) => {
    if (!session) {
      setIsLoginDialogOpen(true);
      return;
    }

    const sessionParams = {
      name: "Untitled",
      status: "IN_PROGRESS" as const,
      createdBy: session?.githubId?.toString(),
      templateId: "nextjs",
      ...(repository && { repository: repository.full_name }),
    };

    const sessionId = await createSession(sessionParams);

    const actionParams = {
      sessionId,
      message,
      ...(repository
        ? { repository: repository.full_name }
        : { template: templates.find((t) => t.id === "nextjs") }),
    };

    await createSessionAction(actionParams);

    await addMessage({
      sessionId,
      role: "user",
      content: message,
    });

    router.push(`/session/${sessionId}`);
  };

  const handleTemplateSelect = async (id: string) => {
    const template = templates.find((t) => t.id === id);

    if (template) {
      const sessionId = await createSession({
        name: "Untitled",
        status: "IN_PROGRESS",
        repository: template.repository,
        templateId: id,
        createdBy: session?.githubId?.toString(),
      });

      await createSessionAction({
        sessionId,
        template: template,
      });

      router.push(`/session/${sessionId}`);
    }
  };

  return (
    <>
      <LoginDialog
        open={isLoginDialogOpen}
        onOpenChange={setIsLoginDialogOpen}
      />
      <div className="flex flex-col gap-y-[100px] h-screen bg-background border rounded-lg mb-2">
        <div className="w-full md:max-w-2xl mx-auto md:px-10 px-4 flex flex-col gap-y-10 justify-center mt-[90px]">
          <div className="flex items-center justify-center gap-2">
            <h1 className="text-3xl md:text-4xl font-bold text-center">
              What can I help you ship?
            </h1>
          </div>
          <ChatForm
            onSubmit={handleChatSubmit}
            showRepositories={Boolean(session)}
          />
        </div>
        <div className="flex flex-col gap-y-8">
          <TemplatesSection onSelect={handleTemplateSelect} />
        </div>
        <footer className="mt-auto py-8 text-center justify-end">
          <p className="text-xs text-gray-500 dark:text-gray-400">
            <Link href="/sessions" className="hover:underline">
              Sessions{" "}
            </Link>
            â€¢{" "}
            <Link href="/settings" className="hover:underline">
              Settings{" "}
            </Link>
            â€¢{" "}
            <a href="/billing" className="hover:underline">
              Billing
            </a>{" "}
            â€¢{" "}
            <a
              href="https://vibekit.sh/privacy-policy"
              target="_blank"
              rel="noopener noreferrer"
              className="hover:underline"
            >
              Privacy
            </a>{" "}
            â€¢{" "}
            <a
              href="https://vibekit.sh/terms-of-service"
              target="_blank"
              rel="noopener noreferrer"
              className="hover:underline"
            >
              Terms
            </a>{" "}
            â€¢{" "}
            <a
              href="https://x.com/vibekit_sh"
              target="_blank"
              rel="noopener noreferrer"
              className="hover:underline"
            >
              X
            </a>{" "}
            â€¢{" "}
            <a
              href="https://github.com/superagent-ai/vibekit/tree/main/templates/v0-clone"
              target="_blank"
              rel="noopener noreferrer"
              className="hover:underline"
            >
              GitHub
            </a>
          </p>
        </footer>
      </div>
    </>
  );
}



================================================
FILE: templates/v0-clone/app/globals.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@keyframes tvFlicker {
  0% { 
    opacity: 0.1; 
    transform: scale(1); 
    filter: brightness(1) contrast(1);
  }
  10% { 
    opacity: 0.8; 
    transform: scale(1.02); 
    filter: brightness(1.2) contrast(1.5);
  }
  20% { 
    opacity: 0.3; 
    transform: scale(0.98); 
    filter: brightness(0.8) contrast(0.8);
  }
  30% { 
    opacity: 0.9; 
    transform: scale(1.01); 
    filter: brightness(1.1) contrast(1.3);
  }
  50% { 
    opacity: 0.2; 
    transform: scale(1); 
    filter: brightness(0.9) contrast(1.1);
  }
  70% { 
    opacity: 0.7; 
    transform: scale(1.03); 
    filter: brightness(1.3) contrast(1.2);
  }
  85% { 
    opacity: 0.4; 
    transform: scale(0.97); 
    filter: brightness(0.7) contrast(0.9);
  }
  100% { 
    opacity: 0.1; 
    transform: scale(1); 
    filter: brightness(1) contrast(1);
  }
}

@keyframes fastPulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.animate-fast-pulse {
  animation: fastPulse 0.75s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.scrollbar-hide {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

.scrollbar-hide::-webkit-scrollbar {
  display: none;
}



================================================
FILE: templates/v0-clone/app/layout.tsx
================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { AuthProvider } from "@/providers/auth-provider";
import { ThemeProvider } from "@/providers/theme-provider";

import Navbar from "@/components/navbar";
import { ConvexClientProvider } from "@/providers/convex-provider";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <link rel="icon" href="/favicon.svg" />
      <body
        className={`${geistSans.variable} ${geistMono.variable} bg-muted/40 antialiased h-screen flex flex-col gap-y-2`}
        style={{ padding: "0 8px" }}
      >
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          <AuthProvider>
            <ConvexClientProvider>
              <Navbar />
              {children}
            </ConvexClientProvider>
          </AuthProvider>
        </ThemeProvider>
      </body>
    </html>
  );
}



================================================
FILE: templates/v0-clone/app/page.tsx
================================================
import { Metadata } from "next";
import ClientPage from "./client-page";

export const metadata: Metadata = {
  title: "Vibe0 | VibeKit",
  description: "A v0 clone built with VibeKit",
};

export default function Home() {
  return <ClientPage />;
}



================================================
FILE: templates/v0-clone/app/actions/github.ts
================================================
"use server";

import { Octokit } from "@octokit/rest";
import { auth } from "@/lib/auth";

export interface Repo {
  id: number;
  name: string;
  full_name: string;
  private: boolean;
  description: string | null;
  html_url: string;
  default_branch: string;
  updated_at: string | null;
  language: string | null;
  stargazers_count: number;
  forks_count: number;
}

export async function listRepos(): Promise<Repo[]> {
  const session = await auth();

  if (!session?.accessToken) {
    throw new Error(
      "No GitHub access token provided. Please authenticate first."
    );
  }

  const octokit = new Octokit({
    auth: session.accessToken,
  });

  try {
    // Get user's own repositories and organizations in parallel
    const [{ data: userRepositories }, { data: organizations }] =
      await Promise.all([
        octokit.rest.repos.listForAuthenticatedUser({
          sort: "updated",
          per_page: 100,
          visibility: "all",
          affiliation: "owner,collaborator,organization_member",
        }),
        octokit.rest.orgs.listForAuthenticatedUser({
          per_page: 100,
        }),
      ]);

    // Get repositories from each organization
    const orgRepositoriesPromises = organizations.map(async (org) => {
      try {
        const { data: orgRepos } = await octokit.rest.repos.listForOrg({
          org: org.login,
          per_page: 100,
          sort: "updated",
        });
        return orgRepos;
      } catch (error) {
        // If we can't access org repos (permissions), just return empty array
        console.warn(`Could not fetch repos for org ${org.login}:`, error);
        return [];
      }
    });

    const orgRepositoriesArrays = await Promise.all(orgRepositoriesPromises);
    const orgRepositories = orgRepositoriesArrays.flat();

    // Combine and deduplicate repositories
    const allRepositories = [...userRepositories, ...orgRepositories];
    const uniqueRepositories = allRepositories.filter(
      (repo, index, array) => array.findIndex((r) => r.id === repo.id) === index
    );

    return uniqueRepositories.map(
      (repo): Repo => ({
        id: repo.id,
        name: repo.name,
        full_name: repo.full_name,
        private: repo.private,
        description: repo.description,
        html_url: repo.html_url,
        default_branch: repo.default_branch || "main",
        updated_at: repo.updated_at || null,
        language: repo.language || null,
        stargazers_count: repo.stargazers_count || 0,
        forks_count: repo.forks_count || 0,
      })
    );
  } catch (error) {
    console.error("GitHub API Error:", error);
    throw new Error(
      `Failed to fetch repositories: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}

export async function getBranches(owner: string, repo: string) {
  const session = await auth();

  if (!session?.accessToken) {
    throw new Error(
      "No GitHub access token provided. Please authenticate first."
    );
  }

  const octokit = new Octokit({
    auth: session.accessToken,
  });

  try {
    const { data } = await octokit.rest.repos.listBranches({
      owner,
      repo,
    });

    return data.map((branch) => ({
      name: branch.name,
      protected: branch.protected,
    }));
  } catch (error) {
    console.error("GitHub API Error:", error);
    throw new Error(
      `Failed to fetch branches: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}

export async function createRepo({
  repoName,
  token,
  isPrivate = true,
}: {
  repoName: string;
  token: string;
  isPrivate?: boolean;
}) {
  if (!token) {
    throw new Error(
      "No GitHub access token provided. Please authenticate first."
    );
  }

  const octokit = new Octokit({
    auth: token,
  });

  try {
    const { data } = await octokit.rest.repos.createForAuthenticatedUser({
      name: repoName,
      private: isPrivate,
    });

    return {
      full_name: data.full_name,
      private: data.private,
      description: data.description,
      html_url: data.html_url,
      default_branch: data.default_branch || "main",
      created_at: data.created_at || null,
      language: data.language || null,
      stargazers_count: data.stargazers_count || 0,
      forks_count: data.forks_count || 0,
    };
  } catch (error) {
    console.error("GitHub API Error:", error);
    throw new Error(
      `Failed to create repository: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}



================================================
FILE: templates/v0-clone/app/actions/inngest.ts
================================================
"use server";
import { getSubscriptionToken, Realtime } from "@inngest/realtime";

import { getInngestApp, sessionChannel } from "@/lib/inngest";

export type SessionChannelToken = Realtime.Token<
  typeof sessionChannel,
  ["status", "update"]
>;

export async function fetchRealtimeSubscriptionToken(): Promise<SessionChannelToken> {
  const token = await getSubscriptionToken(getInngestApp(), {
    channel: sessionChannel(),
    topics: ["status", "update"],
  });

  return token;
}



================================================
FILE: templates/v0-clone/app/actions/session.ts
================================================
"use server";
import { generateObject } from "ai";
import { anthropic } from "@ai-sdk/anthropic";
import { z } from "zod";

export async function generateSessionTitle(prompt: string) {
  const response = await generateObject({
    model: anthropic("claude-3-5-sonnet-20240620"),
    schema: z.object({
      title: z.string(),
    }),
    prompt:
      `Generate a title for a session based on the following prompt: ${prompt}\n` +
      "Maximum of three words.",
  });

  return response.object.title;
}



================================================
FILE: templates/v0-clone/app/actions/vibekit.ts
================================================
"use server";
import { VibeKit, VibeKitConfig } from "@vibe-kit/sdk";
import { fetchMutation } from "convex/nextjs";

import { api } from "@/convex/_generated/api";
import { inngest } from "@/lib/inngest";
import { auth } from "@/lib/auth";
import { Id } from "@/convex/_generated/dataModel";
import { Template } from "@/config";

export async function runAgentAction({
  sessionId,
  id,
  message,
  template,
  repository,
  token,
}: {
  sessionId: string;
  id: string;
  message: string;
  template?: Template;
  token: string;
  repository?: string;
}) {
  await inngest.send({
    name: "vibe0/run.agent",
    data: {
      sessionId,
      id,
      message,
      template,
      repository,
      token,
    },
  });
}

export async function createSessionAction({
  sessionId,
  message,
  repository,
  template,
}: {
  sessionId: string;
  message?: string;
  repository?: string;
  template?: Template;
}) {
  const session = await auth();
  await inngest.send({
    name: "vibe0/create.session",
    data: {
      sessionId,
      message,
      repository,
      token: session?.accessToken,
      template,
    },
  });
}

export async function deleteSessionAction(sessionId: string) {
  const config: VibeKitConfig = {
    agent: {
      type: "claude",
      model: {
        apiKey: process.env.ANTHROPIC_API_KEY!,
      },
    },
    environment: {
      northflank: {
        apiKey: process.env.NORTHFLANK_API_KEY!,
        projectId: process.env.NORTHFLANK_PROJECT_ID!,
      },
    },
    sessionId,
  };

  const vibekit = new VibeKit(config);

  await vibekit.setSession(sessionId);

  await vibekit.kill();
}

export const createPullRequestAction = async ({
  id,
  sessionId,
  repository,
}: {
  id: Id<"sessions">;
  sessionId: string;
  repository: string;
}) => {
  const session = await auth();

  if (!session?.accessToken) {
    throw new Error("No GitHub token found. Please authenticate first.");
  }

  const config: VibeKitConfig = {
    agent: {
      type: "claude",
      model: {
        apiKey: process.env.ANTHROPIC_API_KEY!,
      },
    },
    environment: {
      northflank: {
        apiKey: process.env.NORTHFLANK_API_KEY!,
        projectId: process.env.NORTHFLANK_PROJECT_ID!,
      },
    },
    github: {
      token: session?.accessToken,
      repository,
    },
    sessionId,
  };

  const vibekit = new VibeKit(config);

  const pr = await vibekit.createPullRequest(
    {
      name: "ðŸ–– vibe0",
      color: "42460b",
      description: "Pull request created by vibe0",
    },
    "vibe0"
  );

  await fetchMutation(api.sessions.update, {
    id,
    pullRequest: pr,
  });
};



================================================
FILE: templates/v0-clone/app/api/auth/[...nextauth]/route.ts
================================================
import { handlers } from "@/lib/auth";
export const { GET, POST } = handlers;
export const runtime = "edge";



================================================
FILE: templates/v0-clone/app/api/check-url/route.ts
================================================
import { NextRequest, NextResponse } from "next/server";

export async function POST(req: NextRequest) {
  const body = await req.json();
  const { url } = body;

  if (!url) {
    return NextResponse.json({ error: "URL is required" }, { status: 400 });
  }

  console.log("Checking URL", url);

  try {
    const response = await fetch(url);
    console.log("Response", response.status);
    const available = response.status >= 200 && response.status < 400;
    return NextResponse.json({ available });
  } catch (error) {
    console.error("Error fetching URL:", error);
    return NextResponse.json(
      {
        available: false,
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}



================================================
FILE: templates/v0-clone/app/api/inngest/route.ts
================================================
import { serve } from "inngest/next";
import { inngest, runAgent, createSession } from "@/lib/inngest";

export const maxDuration = 800;

// Create an API that serves zero functions
export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [runAgent, createSession],
});



================================================
FILE: templates/v0-clone/app/session/[id]/client-page.tsx
================================================
"use client";

import { useQuery } from "convex/react";

import Chat from "@/components/chat";
import Preview from "@/components/preview";
import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";

export default function ClientPage({ id }: { id: string }) {
  // Use Convex query to get session data
  const session = useQuery(api.sessions.getById, {
    id: id as Id<"sessions">,
  });

  return (
    <div className="flex h-screen overflow-hidden gap-x-2 pb-2">
      {session && <Chat session={session} />}
      {session && <Preview session={session} />}
    </div>
  );
}



================================================
FILE: templates/v0-clone/app/session/[id]/page.tsx
================================================
import ClientPage from "./client-page";

interface Props {
  params: Promise<{ id: string }>;
}

export default async function Home({ params }: Props) {
  const { id } = await params;

  return <ClientPage id={id} />;
}



================================================
FILE: templates/v0-clone/app/sessions/client-page.tsx
================================================
"use client";
import { useQuery, useMutation } from "convex/react";
import { api } from "@/convex/_generated/api";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { useState, useMemo } from "react";
import { Loader, SearchIcon, XIcon, Trash2 } from "lucide-react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import { Id } from "@/convex/_generated/dataModel";
import { deleteSessionAction } from "../actions/vibekit";

const ITEMS_PER_PAGE = 15;

export default function SessionsClientPage() {
  const { data: session } = useSession();
  const sessions = useQuery(
    api.sessions.list,
    session?.githubId
      ? {
          createdBy: session.githubId.toString(),
        }
      : "skip"
  );
  const deleteSession = useMutation(api.sessions.remove);
  const [currentPage, setCurrentPage] = useState(1);
  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilter, setStatusFilter] = useState("");
  const [deletingSessionId, setDeletingSessionId] = useState<string | null>(
    null
  );
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [sessionToDelete, setSessionToDelete] = useState<{
    id: string;
    sessionId?: string;
    name: string;
  } | null>(null);
  const router = useRouter();

  // Get unique statuses for filter dropdown
  const uniqueStatuses = useMemo(() => {
    if (!sessions) return [];
    return [...new Set(sessions.map((session) => session.status))].sort();
  }, [sessions]);

  // Filter and paginate data
  const filteredAndPaginatedData = useMemo(() => {
    if (!sessions) return { data: [], totalPages: 0, filteredCount: 0 };

    // Apply filters
    const filtered = sessions.filter((session) => {
      const matchesSearch =
        searchTerm === "" ||
        session.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        (session.sessionId &&
          session.sessionId.toLowerCase().includes(searchTerm.toLowerCase())) ||
        (session.statusMessage &&
          session.statusMessage
            .toLowerCase()
            .includes(searchTerm.toLowerCase()));

      const matchesStatus =
        statusFilter === "" || session.status === statusFilter;

      return matchesSearch && matchesStatus;
    });

    const filteredCount = filtered.length;

    // Apply pagination
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIndex = startIndex + ITEMS_PER_PAGE;
    const data = filtered.slice(startIndex, endIndex);
    const totalPages = Math.ceil(filteredCount / ITEMS_PER_PAGE);

    return { data, totalPages, filteredCount };
  }, [sessions, searchTerm, statusFilter, currentPage]);

  // Reset to first page when filters change
  const handleSearchChange = (value: string) => {
    setSearchTerm(value);
    setCurrentPage(1);
  };

  const handleStatusFilterChange = (value: string) => {
    setStatusFilter(value);
    setCurrentPage(1);
  };

  const clearFilters = () => {
    setSearchTerm("");
    setStatusFilter("");
    setCurrentPage(1);
  };

  const handleSessionClick = (sessionId: string) => {
    router.push(`/session/${sessionId}`);
  };

  const goToPage = (page: number) => {
    setCurrentPage(page);
  };

  const goToPrevious = () => {
    setCurrentPage((prev) => Math.max(prev - 1, 1));
  };

  const goToNext = () => {
    setCurrentPage((prev) =>
      Math.min(prev + 1, filteredAndPaginatedData.totalPages)
    );
  };

  const formatStatus = (status: string) => {
    return status
      .replace(/_/g, " ")
      .toLowerCase()
      .replace(/\b\w/g, (l) => l.toUpperCase());
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case "RUNNING":
        return "text-green-600 bg-green-50 border-green-200";
      case "IN_PROGRESS":
        return "text-blue-600 bg-blue-50 border-blue-200";
      case "CLONING_REPO":
      case "INSTALLING_DEPENDENCIES":
      case "STARTING_DEV_SERVER":
      case "CREATING_TUNNEL":
        return "text-yellow-600 bg-yellow-50 border-yellow-200";
      default:
        return "text-gray-600 bg-gray-50 border-gray-200";
    }
  };

  const handleDeleteSession = (
    id: string,
    sessionName: string,
    sessionId?: string
  ) => {
    setSessionToDelete({ id, sessionId, name: sessionName });

    setDeleteDialogOpen(true);
  };

  const confirmDeleteSession = async () => {
    if (!sessionToDelete) return;

    try {
      setDeletingSessionId(sessionToDelete.id);

      await deleteSession({ id: sessionToDelete.id as Id<"sessions"> });

      if (sessionToDelete.sessionId) {
        await deleteSessionAction(sessionToDelete.sessionId);
      }

      setDeleteDialogOpen(false);
      setSessionToDelete(null);
    } catch (error) {
      console.error("Failed to delete session:", error);
      alert("Failed to delete session. Please try again.");
    } finally {
      setDeletingSessionId(null);
    }
  };

  const cancelDeleteSession = () => {
    setDeleteDialogOpen(false);
    setSessionToDelete(null);
  };

  if (!sessions) {
    return (
      <div className="flex flex-col h-screen bg-background border rounded-lg">
        <div className="p-6 text-muted-foreground">
          <Loader className="size-5 animate-spin mb-2" />
        </div>
      </div>
    );
  }

  const hasActiveFilters = searchTerm !== "" || statusFilter !== "";

  return (
    <div className="flex flex-col h-screen bg-background border rounded-lg mb-2">
      <div className="p-6">
        <div className="flex items-center justify-between mb-6">
          <div>
            <h1 className="text-2xl font-semibold">Sessions</h1>
            <p className="text-sm text-muted-foreground">
              Manage and monitor your development sessions
            </p>
          </div>
          <div className="text-sm text-muted-foreground">
            {hasActiveFilters ? (
              <span>
                {filteredAndPaginatedData.filteredCount} of {sessions.length}{" "}
                sessions
              </span>
            ) : (
              <span>{sessions.length} total sessions</span>
            )}
          </div>
        </div>

        {/* Search and Filter Controls */}
        <div className="flex flex-col sm:flex-row gap-4 mb-6">
          <div className="relative flex-1">
            <SearchIcon className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4" />
            <Input
              placeholder="Search by name, session ID, or status message..."
              value={searchTerm}
              onChange={(e) => handleSearchChange(e.target.value)}
              className="pl-10 pr-10"
            />
            {searchTerm && (
              <button
                onClick={() => handleSearchChange("")}
                className="absolute right-3 top-1/2 transform -translate-y-1/2 text-muted-foreground hover:text-foreground"
              >
                <XIcon className="w-4 h-4" />
              </button>
            )}
          </div>

          <div className="flex items-center gap-2">
            <Select
              value={statusFilter}
              onValueChange={handleStatusFilterChange}
            >
              <SelectTrigger className="w-48">
                <SelectValue placeholder="All statuses" />
              </SelectTrigger>
              <SelectContent>
                {uniqueStatuses.map((status) => (
                  <SelectItem key={status} value={status}>
                    {formatStatus(status)}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {hasActiveFilters && (
            <Button
              variant="outline"
              size="sm"
              onClick={clearFilters}
              className="whitespace-nowrap"
            >
              <XIcon className="w-4 h-4 mr-1" />
              Clear filters
            </Button>
          )}
        </div>

        <div className="border rounded-lg">
          <ScrollArea className="h-[calc(100vh-300px)]">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-[200px] px-4">Name</TableHead>
                  <TableHead>Session ID</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead>Preview url</TableHead>
                  <TableHead className="w-[40px]">&nbsp;</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredAndPaginatedData.data.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={5} className="text-center py-8">
                      <div className="text-muted-foreground">
                        {hasActiveFilters ? (
                          <div>
                            <p>No sessions match your filters</p>
                            <Button
                              variant="link"
                              onClick={clearFilters}
                              className="mt-2"
                            >
                              Clear filters to see all sessions
                            </Button>
                          </div>
                        ) : (
                          "No sessions found"
                        )}
                      </div>
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredAndPaginatedData.data.map((session) => (
                    <TableRow
                      key={session.id}
                      className="cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSessionClick(session.id)}
                    >
                      <TableCell className="font-medium px-4">
                        {session.name}
                      </TableCell>
                      <TableCell className="font-mono text-sm">
                        {session.sessionId || "N/A"}
                      </TableCell>
                      <TableCell>
                        <span
                          className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium border ${getStatusColor(session.status)}`}
                        >
                          {formatStatus(session.status)}
                        </span>
                      </TableCell>
                      <TableCell>
                        {session.tunnelUrl ? (
                          <a
                            href={session.tunnelUrl}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="text-blue-600 hover:underline truncate block max-w-[200px]"
                            onClick={(e) => e.stopPropagation()}
                          >
                            {session.tunnelUrl}
                          </a>
                        ) : (
                          "N/A"
                        )}
                      </TableCell>
                      <TableCell onClick={(e) => e.stopPropagation()}>
                        <Button
                          variant="outline"
                          size="icon"
                          onClick={() =>
                            handleDeleteSession(
                              session.id,
                              session.name,
                              session.sessionId
                            )
                          }
                          disabled={deletingSessionId === session.id}
                          className="size-7"
                        >
                          {deletingSessionId === session.id ? (
                            <Loader className="w-4 h-4 animate-spin" />
                          ) : (
                            <Trash2 className="w-4 h-4" />
                          )}
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </ScrollArea>
        </div>
        {/* Pagination */}
        {filteredAndPaginatedData.totalPages > 1 && (
          <div className="flex items-center justify-between mt-4">
            <div className="text-sm text-muted-foreground">
              Showing {(currentPage - 1) * ITEMS_PER_PAGE + 1} to{" "}
              {Math.min(
                currentPage * ITEMS_PER_PAGE,
                filteredAndPaginatedData.filteredCount
              )}{" "}
              of {filteredAndPaginatedData.filteredCount}{" "}
              {hasActiveFilters ? "filtered " : ""}sessions
            </div>
            <div className="flex items-center space-x-2">
              <Button
                variant="outline"
                size="sm"
                onClick={goToPrevious}
                disabled={currentPage === 1}
              >
                Previous
              </Button>

              <div className="flex items-center space-x-1">
                {Array.from(
                  { length: filteredAndPaginatedData.totalPages },
                  (_, i) => i + 1
                ).map((page) => (
                  <Button
                    key={page}
                    variant={currentPage === page ? "default" : "outline"}
                    size="sm"
                    onClick={() => goToPage(page)}
                    className="w-8 h-8"
                  >
                    {page}
                  </Button>
                ))}
              </div>

              <Button
                variant="outline"
                size="sm"
                onClick={goToNext}
                disabled={currentPage === filteredAndPaginatedData.totalPages}
              >
                Next
              </Button>
            </div>
          </div>
        )}
      </div>

      {/* Delete Confirmation Dialog */}
      <Dialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Delete Session</DialogTitle>
            <DialogDescription>
              Are you sure you want to delete the session &quot;
              {sessionToDelete?.name}&quot;? This action cannot be undone.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={cancelDeleteSession}
              disabled={deletingSessionId !== null}
            >
              Cancel
            </Button>
            <Button
              onClick={confirmDeleteSession}
              disabled={deletingSessionId !== null}
            >
              {deletingSessionId === sessionToDelete?.id && (
                <Loader className="w-4 h-4 animate-spin" />
              )}
              Delete
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}



================================================
FILE: templates/v0-clone/app/sessions/page.tsx
================================================
import { Metadata } from "next";
import SessionsClientPage from "./client-page";

export const metadata: Metadata = {
  title: "Sessions |Â vibe0",
  description: "Sessions list",
};

export default async function SessionsPage() {
  return <SessionsClientPage />;
}


================================================
FILE: templates/v0-clone/components/booting-machine.tsx
================================================
import { useRef, useEffect } from "react";
import { TextShimmer } from "./ui/text-shimmer";
import { Loader } from "lucide-react";

export default function BootingMachine({
  label,
  size = "md",
}: {
  label: string;
  size?: "md" | "lg";
}) {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const generateStatic = () => {
      const imageData = ctx.createImageData(canvas.width, canvas.height);
      const data = imageData.data;

      // Adjust static intensity based on size
      const staticThreshold = size === "lg" ? 0.3 : 0.5; // lg = more white noise

      for (let i = 0; i < data.length; i += 4) {
        const random = Math.random();
        let noise;

        if (random > staticThreshold) {
          noise = 255; // white
        } else if (random > staticThreshold - 0.2) {
          noise = size === "lg" ? Math.floor(Math.random() * 100) + 155 : 128; // light gray with variation
        } else {
          noise = size === "lg" ? Math.floor(Math.random() * 80) + 50 : 64; // dark gray with variation
        }

        data[i] = noise; // red
        data[i + 1] = noise; // green
        data[i + 2] = noise; // blue
        data[i + 3] = 255; // fully opaque
      }

      ctx.putImageData(imageData, 0, 0);
    };

    // Adjust animation speed based on size
    const animationSpeed = size === "lg" ? 30 : 50; // lg = faster updates
    const interval = setInterval(generateStatic, animationSpeed);
    generateStatic(); // Initial render

    return () => clearInterval(interval);
  }, [size]);

  return (
    <div className="w-auto px-4 rounded-full h-12 border border-muted-foreground/30 bg-background relative overflow-hidden flex items-center justify-center gap-x-2">
      <Loader className="size-4 animate-spin text-muted-foreground" />
      <div className="flex items-center gap-x-1">
        <span className="text-xs font-mono text-orange-500">SANDBOX:</span>
        <TextShimmer className=" text-xs font-mono">{label}</TextShimmer>
      </div>
    </div>
  );
}



================================================
FILE: templates/v0-clone/components/file-diff.tsx
================================================
"use client";

import { useMemo } from "react";
import { cn } from "@/lib/utils";
import * as Diff from "diff";

interface DiffPart {
  added?: boolean;
  removed?: boolean;
  value: string;
}

interface DiffLine {
  type: "added" | "removed" | "unchanged" | "modified";
  content: string;
  oldLineNumber?: number;
  newLineNumber?: number;
  parts?: DiffPart[];
}

interface DiffViewerProps {
  oldContent: string;
  newContent: string;
  className?: string;
}

export default function DiffViewer({
  oldContent,
  newContent,
  className,
}: DiffViewerProps) {
  const diffLines = useMemo(() => {
    return computeDiff(oldContent, newContent);
  }, [oldContent, newContent]);

  return (
    <div className={cn("overflow-hidden bg-background", className)}>
      {/* Diff Content */}
      <div className="font-mono text-xs">
        {diffLines.map((line, index) => (
          <div
            key={index}
            className={cn(
              "flex",
              line.type === "added" && "bg-green-50 dark:bg-green-700/20",
              line.type === "removed" && "bg-red-50 dark:bg-red-700/20",
              line.type === "modified" && "bg-yellow-50 dark:bg-yellow-700/20",
              line.type === "unchanged" && "bg-background"
            )}
          >
            {/* Line Numbers */}
            <div className="flex">
              <div className="w-10 px-2 py-1 text-right text-gray-400 dark:text-gray-500 border-r bg-sidebar select-none">
                {line.oldLineNumber || ""}
              </div>
              <div className="w-10 px-2 py-1 text-right text-gray-400 dark:text-gray-500 border-r bg-sidebar select-none">
                {line.newLineNumber || ""}
              </div>
            </div>

            {/* Diff Indicator */}
            <div className="w-8 px-2 py-1 text-center select-none">
              {line.type === "added" && (
                <span className="text-green-600 dark:text-green-400 font-bold">
                  +
                </span>
              )}
              {line.type === "removed" && (
                <span className="text-red-600 dark:text-red-400 font-bold">
                  -
                </span>
              )}
              {line.type === "modified" && (
                <span className="text-yellow-600 dark:text-yellow-400 font-bold">
                  ~
                </span>
              )}
              {line.type === "unchanged" && (
                <span className="text-primary"> </span>
              )}
            </div>

            {/* Content */}
            <div className="flex-1 px-2 py-1 whitespace-pre-wrap break-all">
              {line.type === "modified" && line.parts ? (
                <span>
                  {line.parts.map((part, partIndex) => (
                    <span
                      key={partIndex}
                      className={cn(
                        part.added &&
                          "bg-green-200 dark:bg-green-900/30 text-green-800 dark:text-green-200",
                        part.removed &&
                          "bg-red-200 dark:bg-red-900/30 text-red-800 dark:text-red-200 line-through",
                        !part.added &&
                          !part.removed &&
                          "text-gray-900 dark:text-gray-100"
                      )}
                    >
                      {part.value}
                    </span>
                  ))}
                </span>
              ) : (
                <span
                  className={cn(
                    line.type === "added" &&
                      "text-green-800 dark:text-green-200",
                    line.type === "removed" && "text-red-800 dark:text-red-200",
                    line.type === "unchanged" && "text-primary"
                  )}
                >
                  {line.content || " "}
                </span>
              )}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

function computeDiff(oldContent: string, newContent: string): DiffLine[] {
  const result: DiffLine[] = [];

  // Use diff package for line-level comparison first
  const lineDiff = Diff.diffLines(oldContent, newContent);

  let oldLineNumber = 1;
  let newLineNumber = 1;

  for (const change of lineDiff) {
    const lines = change.value.split("\n");
    // Remove the last empty line if it exists (from split)
    if (lines[lines.length - 1] === "") {
      lines.pop();
    }

    if (change.added) {
      // Added lines
      for (const line of lines) {
        result.push({
          type: "added",
          content: line,
          newLineNumber: newLineNumber++,
        });
      }
    } else if (change.removed) {
      // Removed lines
      for (const line of lines) {
        result.push({
          type: "removed",
          content: line,
          oldLineNumber: oldLineNumber++,
        });
      }
    } else {
      // Unchanged lines
      for (const line of lines) {
        result.push({
          type: "unchanged",
          content: line,
          oldLineNumber: oldLineNumber++,
          newLineNumber: newLineNumber++,
        });
      }
    }
  }

  // Now enhance with character-level diffing for better precision
  return enhanceWithCharacterDiff(result);
}

function enhanceWithCharacterDiff(diffLines: DiffLine[]): DiffLine[] {
  // Look for adjacent removed/added pairs that might be modifications
  const final: DiffLine[] = [];
  let i = 0;

  while (i < diffLines.length) {
    const current = diffLines[i];
    const next = diffLines[i + 1];

    if (
      current?.type === "removed" &&
      next?.type === "added" &&
      current.oldLineNumber &&
      next.newLineNumber
    ) {
      // This is likely a modified line - do character-level diff
      const charDiff = Diff.diffChars(current.content, next.content);

      final.push({
        type: "modified",
        content: current.content,
        oldLineNumber: current.oldLineNumber,
        newLineNumber: next.newLineNumber,
        parts: charDiff,
      });

      i += 2; // Skip both lines
    } else {
      final.push(current);
      i++;
    }
  }

  return final;
}



================================================
FILE: templates/v0-clone/components/login-dialog.tsx
================================================
"use client";
import Image from "next/image";
import { LucideGithub } from "lucide-react";
import { signIn } from "next-auth/react";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";

export default function LoginDialog({
  open,
  onOpenChange,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="w-[400px]">
        <div className="mb-2 flex flex-col items-center gap-10">
          <Image
            src="logo.svg"
            alt="logo"
            width={100}
            height={100}
            className="mt-6"
          />
          <DialogHeader>
            <DialogTitle className="sm:text-center">
              Sign in to vibe0
            </DialogTitle>
            <DialogDescription className="sm:text-center">
              Sign in to your account to continue.
            </DialogDescription>
          </DialogHeader>
        </div>
        <Button
          type="button"
          className="w-full"
          onClick={() => signIn("github")}
        >
          <LucideGithub />
          Login with Github
        </Button>
        <p className="text-center text-xs text-muted-foreground">
          This will open Github OAuth login page.
        </p>
      </DialogContent>
    </Dialog>
  );
}



================================================
FILE: templates/v0-clone/components/markdown.tsx
================================================
import React, { memo, useState } from "react";
import ReactMarkdown, { type Components } from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeRaw from "rehype-raw";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { CopyIcon, CheckIcon } from "lucide-react";
import { useTheme } from "next-themes";
import {
  oneDark,
  oneLight,
} from "react-syntax-highlighter/dist/cjs/styles/prism";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Separator } from "@/components/ui/separator";
import {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
} from "@/components/ui/table";
import { ScrollArea } from "@/components/ui/scroll-area";

type CodeComponentProps = React.ComponentPropsWithoutRef<"code"> & {
  inline?: boolean;
  className?: string;
  children?: React.ReactNode;
  style?: React.CSSProperties;
};

export const CodeComponent: React.FC<CodeComponentProps> = ({
  inline,
  className,
  children,
  ...props
}) => {
  const match = /language-(\w+)/.exec(className || "");
  const { theme } = useTheme();
  const [copied, setCopied] = useState(false);

  if (inline) {
    return (
      <code
        className="text-sm bg-zinc-100 dark:bg-zinc-800 py-0.5 px-1 rounded-md"
        style={{ wordBreak: "break-all" }}
        {...props}
      >
        {children}
      </code>
    );
  }

  // Code block with language
  if (match) {
    return (
      <div className="border rounded-lg border-muted-foreground/20 my-2 bg-sidebar overflow-hidden">
        <div className="flex items-center justify-between bg-muted px-2 py-1 border-b">
          <span className="text-xs text-muted-foreground">{match[1]}</span>
          <Button
            variant="ghost"
            size="icon"
            className="size-7"
            onClick={() => {
              navigator.clipboard.writeText(String(children));
              setCopied(true);
              setTimeout(() => setCopied(false), 2000);
            }}
          >
            {copied ? (
              <CheckIcon className="w-4 h-4 text-green-500" />
            ) : (
              <CopyIcon className="w-4 h-4" />
            )}
          </Button>
        </div>
        <ScrollArea className="max-w-full">
          <div className="px-4 py-2" style={{ maxWidth: "100%" }}>
            <SyntaxHighlighter
              language={match[1]}
              style={theme === "dark" ? oneDark : oneLight}
              customStyle={{
                fontSize: "12.5px",
                backgroundColor: "transparent",
                padding: "0",
                margin: "0",
                background: "none",
                overflow: "visible",
              }}
              wrapLongLines={true}
              PreTag="div"
              codeTagProps={{
                style: {
                  whiteSpace: "pre-wrap",
                  wordBreak: "break-all",
                  overflowWrap: "anywhere",
                },
              }}
            >
              {String(children).replace(/\n$/, "")}
            </SyntaxHighlighter>
          </div>
        </ScrollArea>
      </div>
    );
  }

  // Code block without language
  return (
    <code
      className="relative rounded !bg-sidebar border border-muted-foreground/20 px-[0.3rem] py-[0.2rem] font-mono text-xs"
      style={{ wordBreak: "break-all" }}
    >
      {children}
    </code>
  );
};

const components: Partial<Components> = {
  code: CodeComponent,
  pre: ({ children }) => <>{children}</>,
  ol: ({ children, ...props }) => (
    <ol className="list-decimal list-outside ml-4" {...props}>
      {children}
    </ol>
  ),
  li: ({ children, ...props }) => (
    <li className="py-1 text-sm" {...props}>
      {children}
    </li>
  ),
  ul: ({ children, ...props }) => (
    <ul className="list-disc list-outside ml-4" {...props}>
      {children}
    </ul>
  ),
  strong: ({ children, ...props }) => (
    <span className="font-semibold" {...props}>
      {children}
    </span>
  ),
  p: ({ children, ...props }) => (
    <p
      className="mb-2 text-sm"
      style={{ wordBreak: "break-word", overflowWrap: "break-word" }}
      {...props}
    >
      {children}
    </p>
  ),
  a: ({ children, href, ...props }) => {
    return (
      <Link
        passHref
        className="text-blue-500 hover:underline"
        style={{
          wordBreak: "break-all",
          maxWidth: "100%",
          display: "inline-block",
          textOverflow: "ellipsis",
        }}
        href={href || "#"}
        target="_blank"
        rel="noreferrer"
        {...props}
      >
        {children}
      </Link>
    );
  },
  h1: ({ children, ...props }) => (
    <h1
      className="text-3xl font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h1>
  ),
  h2: ({ children, ...props }) => (
    <h2
      className="text-2xl font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h2>
  ),
  h3: ({ children, ...props }) => (
    <h3
      className="text-xl font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h3>
  ),
  h4: ({ children, ...props }) => (
    <h4
      className="text-lg font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h4>
  ),
  h5: ({ children, ...props }) => (
    <h5
      className="text-base font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h5>
  ),
  h6: ({ children, ...props }) => (
    <h6
      className="text-sm font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h6>
  ),
  img: ({ alt, src, title, ...props }) => (
    <img
      className="max-w-full h-auto my-2 rounded"
      alt={alt}
      src={src}
      title={title}
      {...props}
    />
  ),
  blockquote: ({ children, ...props }) => (
    <blockquote
      className="border-l-4 border-gray-300 dark:border-gray-700 pl-4 italic my-4"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </blockquote>
  ),
  table: ({ children, ...props }) => <Table {...props}>{children}</Table>,
  thead: ({ children, ...props }) => (
    <TableHeader {...props}>{children}</TableHeader>
  ),
  tbody: ({ children, ...props }) => (
    <TableBody {...props}>{children}</TableBody>
  ),
  tfoot: ({ children, ...props }) => (
    <TableFooter {...props}>{children}</TableFooter>
  ),
  tr: ({ children, ...props }) => <TableRow {...props}>{children}</TableRow>,
  th: ({ children, ...props }) => <TableHead {...props}>{children}</TableHead>,
  td: ({ children, ...props }) => <TableCell {...props}>{children}</TableCell>,
  hr: () => <Separator className="my-8 h-1" />,
};

const remarkPlugins = [remarkGfm];
const rehypePlugins = [rehypeRaw];

const NonMemoizedMarkdown = ({ children }: { children: string }) => {
  return (
    <div style={{ width: "100%", maxWidth: "100%" }}>
      <ReactMarkdown
        remarkPlugins={remarkPlugins}
        rehypePlugins={rehypePlugins}
        components={components}
      >
        {children}
      </ReactMarkdown>
    </div>
  );
};

export const Markdown = memo(
  NonMemoizedMarkdown,
  (prevProps, nextProps) => prevProps.children === nextProps.children
);



================================================
FILE: templates/v0-clone/components/navbar.tsx
================================================
"use client";

import {
  Plus,
  ChevronDown,
  Monitor,
  Settings,
  CreditCard,
  LogOut,
  Lock,
  GitPullRequest,
  Loader,
} from "lucide-react";
import Link from "next/link";
import { usePathname, useRouter } from "next/navigation";
import Image from "next/image";
import { useState, useEffect, useRef, useCallback } from "react";
import { useQuery, useMutation } from "convex/react";
import { useSession, signOut, signIn } from "next-auth/react";

import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { api } from "@/convex/_generated/api";
import { Id } from "@/convex/_generated/dataModel";
import { createSessionAction } from "@/app/actions/vibekit";
import { Avatar, AvatarImage, AvatarFallback } from "@radix-ui/react-avatar";
import { ThemeToggle } from "@/components/ui/theme-toggle";
import { createPullRequestAction } from "@/app/actions/vibekit";
import { templates } from "@/config";

export default function Navbar() {
  const { data: authSession } = useSession();
  const [isCreatingPullRequest, setIsCreatingPullRequest] =
    useState<boolean>(false);
  const pathname = usePathname();
  const isHome = pathname === "/";
  const isSession = pathname.includes("/session") && pathname !== "/sessions";
  const router = useRouter();

  const createSession = useMutation(api.sessions.create);
  const [mounted, setMounted] = useState(false);
  const sessionId = isSession ? pathname.split("/session/")[1] : null;
  const [isEditing, setIsEditing] = useState(false);
  const editRef = useRef<HTMLSpanElement>(null);
  const originalValue = useRef<string>("");

  const session = useQuery(
    api.sessions.getById,
    sessionId ? { id: sessionId as Id<"sessions"> } : "skip"
  );

  const updateSession = useMutation(api.sessions.update);

  useEffect(() => {
    setMounted(true);
  }, []);

  useEffect(() => {
    if (isEditing && editRef.current) {
      editRef.current.focus();
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(editRef.current);
      const selection = window.getSelection();
      selection?.removeAllRanges();
      selection?.addRange(range);
    }
  }, [isEditing]);

  const handleStartEdit = () => {
    if (session) {
      originalValue.current = session.name;
      setIsEditing(true);
    }
  };

  const handleSave = async () => {
    if (sessionId && editRef.current && session) {
      const newValue = editRef.current.textContent?.trim() || "";
      if (newValue && newValue !== originalValue.current) {
        await updateSession({
          id: sessionId as Id<"sessions">,
          name: newValue,
        });
      } else if (!newValue) {
        // Restore original value if empty
        editRef.current.textContent = originalValue.current;
      }
    }
    setIsEditing(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      handleSave();
    } else if (e.key === "Escape") {
      e.preventDefault();
      if (editRef.current) {
        editRef.current.textContent = originalValue.current;
      }
      setIsEditing(false);
    }
  };

  const handleNewSession = useCallback(async () => {
    const template = templates.find((t) => t.id === "nextjs");

    if (!template) return;

    const sessionId = await createSession({
      name: "Untitled session",
      status: "IN_PROGRESS",
      templateId: template.id,
    });

    await createSessionAction({
      sessionId,
      template,
    });

    router.push(`/session/${sessionId}`);
  }, [createSession, router]);

  const handleCreatePullRequest = useCallback(async () => {
    setIsCreatingPullRequest(true);
    const pr = await createPullRequestAction({
      id: sessionId as Id<"sessions">,
      sessionId: session?.sessionId as string,
      repository: session?.repository as string,
    });

    console.log(pr);
    setIsCreatingPullRequest(false);
  }, [session, sessionId]);

  return (
    <div
      className="flex justify-between items-center pt-2"
      style={{ width: "100%" }}
    >
      <div className="flex items-center gap-x-2">
        <Link
          passHref
          href="/"
          className="hover:opacity-30 transition-all duration-300"
        >
          <div className="flex items-center gap-x-1 text-muted-foreground">
            <Image src="/mark.png" alt="Superagent" width={20} height={20} />
            <p className="font-semibold">vibe0</p>
          </div>
        </Link>
        {mounted && authSession && (
          <span className="ml-1 text-muted-foreground/40">/</span>
        )}
        {mounted && authSession && (
          <>
            <DropdownMenu>
              <DropdownMenuTrigger className="flex items-center gap-x-1 px-1 py-1 rounded-md hover:bg-muted transition-colors cursor-pointer group">
                <Avatar className="h-6 w-6 mr-1">
                  <AvatarImage
                    className="rounded-md"
                    src={authSession.user?.image || undefined}
                    alt={authSession.user?.name || "User"}
                  />
                  <AvatarFallback className="text-xs">
                    {authSession.user?.name?.charAt(0) || "U"}
                  </AvatarFallback>
                </Avatar>
                <span className="text-sm font-medium">
                  {authSession.user?.name}
                </span>
                <ChevronDown className="size-4 text-muted-foreground group-hover:text-foreground transition-colors" />
              </DropdownMenuTrigger>
              <DropdownMenuContent align="center" className="w-48">
                <DropdownMenuItem
                  className="font-medium"
                  onClick={handleNewSession}
                >
                  <Plus className="mr-2 h-4 w-4" />
                  New session
                </DropdownMenuItem>
                <DropdownMenuSeparator />
                <DropdownMenuItem
                  className="font-medium"
                  onClick={() => router.push("/sessions")}
                >
                  <Monitor className="mr-2 h-4 w-4" />
                  Sessions
                </DropdownMenuItem>
                <DropdownMenuItem className="font-medium">
                  <Settings className="mr-2 h-4 w-4" />
                  Settings
                </DropdownMenuItem>
                <DropdownMenuItem className="font-medium">
                  <CreditCard className="mr-2 h-4 w-4" />
                  Billing
                </DropdownMenuItem>
                <DropdownMenuSeparator />
                <ThemeToggle />
                <DropdownMenuSeparator />
                <DropdownMenuItem
                  className="font-medium"
                  onClick={() => {
                    signOut();
                  }}
                >
                  <LogOut className="mr-2 h-4 w-4" />
                  Sign out
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
            {isSession && <span className="text-muted-foreground/40">/</span>}
          </>
        )}
        {mounted && isSession && session && (
          <div className="flex items-center gap-x-2">
            <button
              onClick={handleStartEdit}
              className="flex items-center gap-x-1 px-1 py-1.5 rounded-md hover:bg-muted transition-colors group cursor-pointer"
            >
              <span
                ref={editRef}
                contentEditable={isEditing}
                suppressContentEditableWarning={true}
                onBlur={handleSave}
                onKeyDown={handleKeyDown}
                className={`text-sm font-medium outline-none ${
                  isEditing ? "bg-muted rounded" : ""
                }`}
              >
                {session.name}
              </span>
            </button>
          </div>
        )}
      </div>
      <div className="flex items-center gap-x-2">
        {session && session.pullRequest && !isHome && (
          <Link href={session.pullRequest.html_url} target="_blank">
            <Button variant="outline" className="h-8">
              <GitPullRequest />
              View Pull Request
            </Button>
          </Link>
        )}{" "}
        {session && !session.pullRequest && !isHome && (
          <Button
            variant="outline"
            className="h-8"
            onClick={handleCreatePullRequest}
            disabled={isCreatingPullRequest || session?.status !== "RUNNING"}
          >
            {isCreatingPullRequest ? (
              <Loader className="animate-spin" />
            ) : (
              <GitPullRequest />
            )}
            Create Pull Request
          </Button>
        )}
        {isHome && authSession && (
          <Button className="h-8" onClick={handleNewSession}>
            <Plus /> New session
          </Button>
        )}
        {mounted && !authSession && (
          <Button className="h-8" onClick={() => signIn("github")}>
            <Lock />
            Sign in with Github
          </Button>
        )}
        {authSession && isSession && (
          <Button
            className="h-8"
            disabled={isCreatingPullRequest || session?.status !== "RUNNING"}
          >
            Publish
          </Button>
        )}
      </div>
    </div>
  );
}



================================================
FILE: templates/v0-clone/components/templates-section.tsx
================================================
"use client";

import { ChevronLeft, ChevronRight, ExternalLink } from "lucide-react";
import { Avatar, AvatarImage } from "@/components/ui/avatar";
import { useRef } from "react";
import { Button } from "@/components/ui/button";
import { templates } from "@/config";

function TemplateCard({
  template,
  onSelect,
}: {
  template: (typeof templates)[0];
  onSelect: (id: string) => void;
}) {
  const handleTemplateSelect = async () => {
    onSelect(template.id);
  };

  return (
    <div
      className="min-w-[276px] h-40 bg-background rounded-lg border p-4 flex flex-col gap-3 hover:bg-muted/50 transition-colors cursor-pointer group snap-start"
      onClick={handleTemplateSelect}
    >
      <div className="flex items-start justify-between">
        <div className="*:data-[slot=avatar]:ring-background flex -space-x-2 *:data-[slot=avatar]:ring-2">
          {template.logos.map((logo) => (
            <Avatar key={logo} className="w-6 h-6 bg-background">
              <AvatarImage src={logo} alt={logo} />
            </Avatar>
          ))}
        </div>
        <ExternalLink className="w-4 h-4 text-muted-foreground opacity-0 group-hover:opacity-100 transition-opacity" />
      </div>
      <div className="flex-1">
        <h3 className="font-medium text-sm mb-2">{template.name}</h3>
        <p className="text-sm text-muted-foreground leading-relaxed">
          {template.description}
        </p>
      </div>
    </div>
  );
}

export default function TemplatesSection({
  onSelect,
}: {
  onSelect: (id: string) => void;
}) {
  const scrollRef = useRef<HTMLDivElement>(null);

  const scrollLeft = () => {
    if (scrollRef.current) {
      const container = scrollRef.current;
      const scrollAmount = Math.min(container.clientWidth * 0.75, 400);
      container.scrollBy({ left: -scrollAmount, behavior: "smooth" });
    }
  };

  const scrollRight = () => {
    if (scrollRef.current) {
      const container = scrollRef.current;
      const scrollAmount = Math.min(container.clientWidth * 0.75, 400);
      container.scrollBy({ left: scrollAmount, behavior: "smooth" });
    }
  };

  return (
    <div className="flex flex-col gap-y-4 max-w-6xl w-full mx-auto md:px-0 px-4">
      <div className="flex items-center justify-between">
        <p className="font-medium">Templates</p>
        <div className="flex gap-2">
          <Button
            variant="outline"
            size="icon"
            className="h-8 w-8"
            onClick={scrollLeft}
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>
          <Button
            variant="outline"
            size="icon"
            className="h-8 w-8"
            onClick={scrollRight}
          >
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>
      </div>
      <div
        ref={scrollRef}
        className="flex gap-4 overflow-hidden overflow-x-auto scrollbar-hide pb-2 scroll-smooth snap-x snap-mandatory"
        style={{ scrollbarWidth: "none", msOverflowStyle: "none" }}
      >
        {templates.map((template) => (
          <TemplateCard
            key={template.id}
            template={template}
            onSelect={onSelect}
          />
        ))}
      </div>
    </div>
  );
}



================================================
FILE: templates/v0-clone/components/chat/chat-form.tsx
================================================
"use client";

import { ArrowUp, FolderGit2, Loader } from "lucide-react";
import { Repo } from "@/app/actions/github";
import { useRef, useEffect, useState } from "react";
import { useForm } from "react-hook-form";

import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { listRepos } from "@/app/actions/github";

type FormData = {
  message: string;
  repository?: string;
};

interface ChatFormProps {
  onSubmit: (message: string, repository?: Repo) => void | Promise<void>;
  showRepositories?: boolean;
}

export default function ChatForm({
  onSubmit,
  showRepositories = false,
}: ChatFormProps) {
  const [repos, setRepos] = useState<Repo[]>([]);
  const [isLoadingRepos, setIsLoadingRepos] = useState<boolean>(false);
  const [selectedRepo, setSelectedRepo] = useState<Repo | undefined>();

  useEffect(() => {
    if (showRepositories) {
      const fetchRepos = async () => {
        setIsLoadingRepos(true);
        try {
          const repos = await listRepos();
          setRepos(repos as Repo[]);
        } catch (error) {
          console.error("Failed to fetch repositories:", error);
        } finally {
          setIsLoadingRepos(false);
        }
      };
      fetchRepos();
    }
  }, [showRepositories]);

  const { register, handleSubmit, reset, watch, formState, setValue } =
    useForm<FormData>({
      defaultValues: {
        message: "",
        repository: "",
      },
    });
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const [isLoading, setIsLoading] = useState(false);

  const messageValue = watch("message");
  const isMessageEmpty = !messageValue || messageValue.trim().length === 0;
  const { isSubmitting } = formState;

  // Combine both loading states
  const isFormSubmitting = isSubmitting || isLoading;

  const handleInput = () => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = "auto";
      textarea.style.height = `${Math.min(textarea.scrollHeight, 160)}px`;
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      if (!isMessageEmpty && !isFormSubmitting) {
        handleSubmit(handleFormSubmit)();
      }
    }
  };

  const handleRepositoryChange = (repoId: string) => {
    const repo = repos.find((r) => r.id.toString() === repoId);
    setSelectedRepo(repo);
    setValue("repository", repoId);
  };

  const handleFormSubmit = async (data: FormData) => {
    if (!data.message.trim()) return;

    setIsLoading(true);
    try {
      await onSubmit(data.message.trim(), selectedRepo);
      reset();
      setSelectedRepo(undefined);
    } finally {
      setIsLoading(false);
    }
  };

  // Group repositories by organization/owner
  const groupedRepos = repos.reduce(
    (acc, repo) => {
      const owner = repo.full_name.split("/")[0];
      if (!acc[owner]) {
        acc[owner] = [];
      }
      acc[owner].push(repo);
      return acc;
    },
    {} as Record<string, Repo[]>
  );

  // Sort organizations alphabetically
  const sortedOrgs = Object.keys(groupedRepos).sort();

  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = "56px";
    }
  }, []);

  // Combine register with ref
  const { ref, ...registerProps } = register("message", { required: true });

  return (
    <form
      onSubmit={handleSubmit(handleFormSubmit)}
      className="rounded-lg border p-4 flex flex-col justify-between bg-background"
    >
      <textarea
        {...registerProps}
        ref={(e) => {
          ref(e);
          textareaRef.current = e;
        }}
        className="w-full resize-none focus:outline-none text-sm min-h-14 overflow-hidden"
        placeholder="Ask vibe0 to build..."
        onInput={handleInput}
        onKeyDown={handleKeyDown}
        disabled={isFormSubmitting}
      />
      <div className="flex items-center justify-between">
        {showRepositories && (
          <div className="mb-">
            {isLoadingRepos ? (
              <Skeleton className="w-[200px] h-9" />
            ) : (
              <Select
                onValueChange={handleRepositoryChange}
                value={selectedRepo?.id.toString() || ""}
              >
                <SelectTrigger className="w-full">
                  <SelectValue placeholder="Select a repository (optional)" />
                </SelectTrigger>
                <SelectContent>
                  {sortedOrgs.map((org) => (
                    <SelectGroup key={org}>
                      <SelectLabel>
                        {org} ({groupedRepos[org].length})
                      </SelectLabel>
                      {groupedRepos[org].map((repo) => (
                        <SelectItem key={repo.id} value={repo.id.toString()}>
                          <div className="flex items-center gap-2">
                            <FolderGit2 />
                            <span className="font-medium">{repo.name}</span>
                          </div>
                        </SelectItem>
                      ))}
                    </SelectGroup>
                  ))}
                </SelectContent>
              </Select>
            )}
          </div>
        )}
        <Button
          size="icon"
          className="ml-auto size-8"
          type="submit"
          disabled={isMessageEmpty || isFormSubmitting}
        >
          {isFormSubmitting ? (
            <Loader className="h-4 w-4 animate-spin" />
          ) : (
            <ArrowUp className="h-4 w-4" />
          )}
        </Button>
      </div>
    </form>
  );
}



================================================
FILE: templates/v0-clone/components/chat/index.tsx
================================================
import ChatForm from "./chat-form";
import { useMutation, useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";
import { Doc, Id } from "@/convex/_generated/dataModel";
import { ScrollArea } from "@/components/ui/scroll-area";
import Message from "./message";
import { TextShimmer } from "../ui/text-shimmer";
import { ListTodo } from "lucide-react";
import { useState } from "react";
import { runAgentAction } from "@/app/actions/vibekit";
import { useSession } from "next-auth/react";

interface Todo {
  id: string;
  content: string;
  status: string;
  priority: string;
}

// Helper function to extract the latest todos from assistant messages
function extractLatestTodos(messages: Doc<"messages">[]): Todo[] {
  // Find the most recent assistant message with todos
  for (let i = messages.length - 1; i >= 0; i--) {
    const message = messages[i];
    if (
      message.role === "assistant" &&
      message.todos &&
      message.todos.length > 0
    ) {
      return message.todos;
    }
  }
  return [];
}

// Helper function to calculate progress based on todo status
function calculateProgress(todos: Todo[]): number {
  if (todos.length === 0) return 0;
  const completedCount = todos.filter(
    (todo) =>
      todo.status.toLowerCase() === "completed" ||
      todo.status.toLowerCase() === "done"
  ).length;
  return Math.round((completedCount / todos.length) * 100);
}

// Helper function to get completed todo count
function getCompletedCount(todos: Todo[]): number {
  return todos.filter(
    (todo) =>
      todo.status.toLowerCase() === "completed" ||
      todo.status.toLowerCase() === "done"
  ).length;
}

// Round progress bar component
function RoundProgress({
  progress,
  completed,
  total,
}: {
  progress: number;
  completed: number;
  total: number;
}) {
  const circumference = 2 * Math.PI * 8; // radius of 8
  const strokeDashoffset = circumference - (progress / 100) * circumference;

  return (
    <div className="flex items-center justify-center">
      <span className="text-xs font-medium text-muted-foreground mr-1">
        {completed}/{total}
      </span>
      <div className="relative w-4 h-4">
        <svg className="w-4 h-4 transform -rotate-90" viewBox="0 0 20 20">
          <circle
            cx="10"
            cy="10"
            r="8"
            stroke="currentColor"
            strokeWidth="3"
            fill="transparent"
            className="text-muted-foreground/30"
          />
          <circle
            cx="10"
            cy="10"
            r="8"
            stroke="currentColor"
            strokeWidth="3"
            fill="transparent"
            strokeDasharray={circumference}
            strokeDashoffset={strokeDashoffset}
            className="text-green-500 transition-all duration-300 ease-in-out"
            strokeLinecap="round"
          />
        </svg>
      </div>
    </div>
  );
}

export default function Chat({ session }: { session: Doc<"sessions"> }) {
  const { data: authSession } = useSession();
  const addMessage = useMutation(api.messages.add);
  const messages = useQuery(api.messages.getBySession, {
    sessionId: session._id,
  });
  const [todosExpanded, setTodosExpanded] = useState(false);

  const handleSubmit = async (message: string) => {
    await addMessage({
      sessionId: session._id as Id<"sessions">,
      role: "user",
      content: message,
    });

    await runAgentAction({
      sessionId: session.sessionId!,
      id: session._id,
      message,
      repository: session.repository,
      token: authSession?.accessToken as string,
    });
  };

  const toggleTodos = () => {
    setTodosExpanded(!todosExpanded);
  };

  // Early return if messages are not loaded yet
  if (!messages) {
    return (
      <div className="w-[600px] bg-background rounded-lg flex flex-col border relative" />
    );
  }

  const latestTodos = extractLatestTodos(messages);
  const todosProgress = calculateProgress(latestTodos);
  const completedTodos = getCompletedCount(latestTodos);

  return (
    <div className="w-[600px] bg-background rounded-lg flex flex-col border relative">
      {/* Top fade */}
      <div className="absolute top-0 left-0 right-0 h-6 bg-gradient-to-b from-background to-transparent z-10 rounded-t-lg pointer-events-none" />
      <ScrollArea className="h-[calc(100vh-100px)] px-2">
        <div className="flex flex-col gap-y-2 p-1 pb-[200px] pt-4">
          {messages.length === 0 && (
            <Message
              message={
                {
                  role: "assistant",
                  content: "Hello, I'm vibe0. How can I help you today?",
                } as Doc<"messages">
              }
              showAvatar={true}
            />
          )}
          {messages
            .filter((message) => !message.todos || message.todos.length <= 1)
            .map((message, index) => {
              // Show avatar if it's the first message or if the role changed from the previous message
              const showAvatar =
                index === 0 || messages[index - 1]?.role !== message.role;
              // Convert to Doc<"messages"> by removing extra properties

              return (
                <Message
                  key={message._id}
                  message={message as Doc<"messages">}
                  showAvatar={showAvatar}
                />
              );
            })}
          {session.status === "CUSTOM" && (
            <div className="flex items-center gap-x-2 mt-2 pl-10">
              <div className="size-3 bg-primary rounded-full animate-fast-pulse" />
              <TextShimmer className="text-sm">
                {`${session.statusMessage?.slice(0, 45)}...` || "Working"}
              </TextShimmer>
            </div>
          )}
        </div>
      </ScrollArea>
      <div className="absolute bottom-2 left-3 right-3 bg-background flex flex-col gap-y-2 backdrop-blur-md">
        <div className="flex flex-col gap-y-0">
          <div className="flex flex-col gap-y-2 mx-2 rounded-t-lg hover:bg-muted cursor-pointer bg-muted border-t border-l border-r transition-colors duration-300">
            <div
              className="flex items-center justify-between p-2"
              onClick={toggleTodos}
            >
              <div className="flex items-center gap-x-1">
                <ListTodo className="size-3" />
                <p className="text-xs font-medium">Todo&apos;s</p>
              </div>
              <div className="flex items-center gap-x-2">
                {latestTodos.length > 0 && (
                  <RoundProgress
                    progress={todosProgress}
                    completed={completedTodos}
                    total={latestTodos.length}
                  />
                )}
              </div>
            </div>
            {latestTodos.length > 0 && todosExpanded && (
              <div className="flex flex-col gap-y-1 px-2 pb-2 transition-all duration-300 ease-in-out">
                {latestTodos.slice(0, 3).map((todo) => (
                  <div
                    key={todo.id}
                    className="flex items-center gap-x-2 text-xs"
                  >
                    <div
                      className={`w-2 h-2 rounded-full ${
                        todo.status.toLowerCase() === "completed" ||
                        todo.status.toLowerCase() === "done"
                          ? "bg-green-500"
                          : todo.status.toLowerCase() === "in_progress" ||
                              todo.status.toLowerCase() === "in progress"
                            ? "bg-yellow-500"
                            : "bg-gray-400"
                      }`}
                    />
                    <span className="text-muted-foreground truncate flex-1">
                      {todo.content}
                    </span>
                    <span
                      className={`text-xs px-1.5 py-0.5 ${
                        todo.priority.toLowerCase() === "high"
                          ? "text-red-500"
                          : todo.priority.toLowerCase() === "medium"
                            ? "text-orange-500"
                            : "text-blue-500"
                      }`}
                    >
                      {todo.priority}
                    </span>
                  </div>
                ))}
                {latestTodos.length > 3 && (
                  <p className="text-xs text-muted-foreground">
                    +{latestTodos.length - 3} more todos
                  </p>
                )}
              </div>
            )}
          </div>
          <ChatForm onSubmit={handleSubmit} />
        </div>

        <p className="text-xs text-muted-foreground text-center">
          vibe0 never makes mistakes. Like the other ones do.
        </p>
      </div>
    </div>
  );
}



================================================
FILE: templates/v0-clone/components/chat/message.tsx
================================================
"use client";
import { useCopyToClipboard } from "usehooks-ts";
import { useState } from "react";
import { useParams } from "next/navigation";
import { Copy, Trash2, Check, Pen, Eye } from "lucide-react";
import { useQuery, useMutation } from "convex/react";
import { useSession } from "next-auth/react";

import { api } from "@/convex/_generated/api";
import { Id, Doc } from "@/convex/_generated/dataModel";
import { Button } from "@/components/ui/button";
import { Markdown } from "../markdown";
import { cn } from "@/lib/utils";
import { Avatar, AvatarImage, AvatarFallback } from "@radix-ui/react-avatar";

export default function Message({
  message,
  showAvatar = true,
}: {
  message: Doc<"messages">;
  showAvatar?: boolean;
}) {
  const { data: authSession } = useSession();
  const params = useParams();
  const sessionId = params.id as string;
  const session = useQuery(api.sessions.getById, {
    id: sessionId as Id<"sessions">,
  });
  const deleteMessage = useMutation(api.messages.remove);
  const [, copy] = useCopyToClipboard();
  const [isCopied, setIsCopied] = useState(false);

  const handleCopy = async () => {
    const success = await copy(message.content);
    if (success) {
      setIsCopied(true);
      setTimeout(() => setIsCopied(false), 2000);
    }
  };

  const handleDelete = async () => {
    if (session) {
      await deleteMessage({
        id: message._id as Id<"messages">,
        sessionId: session.id as Id<"sessions">,
      });
    }
  };

  if (message.role === "user") {
    return (
      <div className="group relative rounded-lg cursor-pointer hover:bg-muted">
        <div className="flex items-start gap-x-2">
          {showAvatar ? (
            <div className="size-8 rounded-lg border bg-muted flex items-center justify-center">
              <Avatar>
                <AvatarImage
                  src={authSession?.user?.image || ""}
                  className="rounded-md"
                />
                <AvatarFallback>
                  {authSession?.user?.name?.charAt(0)}
                </AvatarFallback>
              </Avatar>
            </div>
          ) : (
            <div className="size-8" />
          )}
          <div className="flex flex-col gap-y-1 flex-1">
            <p className="text-sm">
              {message.content.length > 250
                ? message.content.slice(0, 250) + "..."
                : message.content}
            </p>
          </div>
        </div>
        <div className="absolute border rounded-lg p-1 bg-background top-2 right-2 flex opacity-0 group-hover:opacity-100 transition-opacity">
          <Button
            variant="ghost"
            size="icon"
            className="size-6"
            aria-label="Copied!"
            onClick={handleCopy}
          >
            {isCopied ? (
              <Check className="size-4 text-green-600" />
            ) : (
              <Copy className="size-4" />
            )}
          </Button>
          <Button
            variant="ghost"
            size="icon"
            onClick={handleDelete}
            className="size-6"
          >
            <Trash2 className="size-4" />
          </Button>
        </div>
      </div>
    );
  }

  if (message.edits) {
    return (
      <div className="pl-10">
        <p className="text-xs flex items-center gap-x-2">
          <span className="font-medium text-muted-foreground flex items-center gap-x-1">
            <Pen className="size-3" />
            Updated:
          </span>
          <span className="text-muted-foreground truncate max-w-[250px]">
            {message.edits.filePath}
          </span>
        </p>
      </div>
    );
  }

  if (message.read) {
    return (
      <div className="pl-10">
        <p className="text-xs flex items-center gap-x-2">
          <span className="font-medium text-muted-foreground flex items-center gap-x-1">
            <Eye className="size-3" />
            Read:
          </span>
          <span className="text-muted-foreground truncate max-w-[270px]">
            {message.read.filePath}
          </span>
        </p>
      </div>
    );
  }

  return (
    <div className="group relative rounded-lg cursor-pointer hover:bg-muted">
      <div className="flex items-start gap-x-2">
        {showAvatar ? (
          <div className="size-8 rounded-lg bg-background border flex items-center justify-center -mt-1.5">
            <span role="img" aria-label="spock emoji">
              ðŸ––
            </span>
          </div>
        ) : (
          <div className="size-8" />
        )}
        <div className={cn("flex flex-col gap-y-1 flex-1")}>
          <Markdown>{message.content}</Markdown>
        </div>
      </div>
      <div className="absolute border rounded-lg p-1 bg-background top-2 right-2 flex opacity-0 group-hover:opacity-100 transition-opacity">
        <Button
          variant="ghost"
          size="icon"
          className="size-6"
          aria-label="Copied!"
          onClick={handleCopy}
        >
          {isCopied ? (
            <Check className="size-4 text-green-600" />
          ) : (
            <Copy className="size-4" />
          )}
        </Button>
      </div>
    </div>
  );
}



================================================
FILE: templates/v0-clone/components/preview/code.tsx
================================================
"use client";
import { useState, useMemo } from "react";
import { useQuery } from "convex/react";
import { FileIcon, ChevronDown, ChevronRight } from "lucide-react";

import { Doc } from "@/convex/_generated/dataModel";
import { api } from "@/convex/_generated/api";
import { cn } from "@/lib/utils";
import FileDiff from "../file-diff";

interface FileEditItemProps {
  message: {
    edits?: {
      filePath?: string;
      oldString?: string;
      newString?: string;
    };
  };
}

function calculateDiffStats(oldContent: string, newContent: string) {
  const oldLines = oldContent.split("\n");
  const newLines = newContent.split("\n");

  // Simple line-based diff calculation
  const oldSet = new Set(oldLines);
  const newSet = new Set(newLines);

  let insertions = 0;
  let deletions = 0;

  // Count insertions (lines in new but not in old)
  for (const line of newLines) {
    if (!oldSet.has(line)) {
      insertions++;
    }
  }

  // Count deletions (lines in old but not in new)
  for (const line of oldLines) {
    if (!newSet.has(line)) {
      deletions++;
    }
  }

  return { insertions, deletions };
}

function FileEditItem({ message }: FileEditItemProps) {
  const [isExpanded, setIsExpanded] = useState<boolean>(true);
  const filePath = message.edits?.filePath ?? "";

  const diffStats = useMemo(() => {
    const oldContent = message.edits?.oldString ?? "";
    const newContent = message.edits?.newString ?? "";
    return calculateDiffStats(oldContent, newContent);
  }, [message.edits?.oldString, message.edits?.newString]);

  const toggleExpanded = () => {
    setIsExpanded((prev) => !prev);
  };

  return (
    <div
      className="flex flex-col gap-0 bg-background border rounded-lg overflow-hidden mb-4"
      key={filePath}
    >
      <div
        className={cn(
          "flex items-center gap-2 h-10 px-4 cursor-pointer hover:bg-sidebar transition-colors",
          isExpanded && " border-b"
        )}
        onClick={toggleExpanded}
      >
        {isExpanded ? (
          <ChevronDown className="w-4 h-4 text-gray-500" />
        ) : (
          <ChevronRight className="w-4 h-4 text-gray-500" />
        )}
        <FileIcon className="w-4 h-4" />
        <p className="text-sm flex-1">{filePath}</p>
        <div className="flex items-center gap-1 text-xs">
          <span className="text-green-600">+{diffStats.insertions}</span>
          <span className="text-red-600">-{diffStats.deletions}</span>
        </div>
      </div>
      {isExpanded && (
        <FileDiff
          oldContent={message.edits?.oldString ?? ""}
          newContent={message.edits?.newString ?? ""}
        />
      )}
    </div>
  );
}

export default function Files({ session }: { session: Doc<"sessions"> }) {
  const messages = useQuery(api.messages.getBySession, {
    sessionId: session._id,
  });

  const messageWithEdits = messages?.filter(
    (message) => message.role === "assistant" && message.edits
  );

  return (
    <div className="flex-1 h-full overflow-hidden relative">
      <div className="flex-1 h-full overflow-hidden relative p-4">
        {messageWithEdits?.map((message) => {
          const filePath = message.edits?.filePath ?? "";

          return <FileEditItem key={filePath} message={message} />;
        })}
      </div>
    </div>
  );
}



================================================
FILE: templates/v0-clone/components/preview/index.tsx
================================================
"use client";

import { ExternalLink, Maximize2 } from "lucide-react";
import { useRef, useEffect, useState } from "react";

import { Button } from "@/components/ui/button";
import BootingMachine from "../booting-machine";
import { Doc } from "@/convex/_generated/dataModel";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import Files from "./code";
import { ScrollArea } from "@/components/ui/scroll-area";

export default function Preview({ session }: { session?: Doc<"sessions"> }) {
  const iframeRef = useRef<HTMLIFrameElement>(null);
  const [isUrlAvailable, setIsUrlAvailable] = useState(false);

  useEffect(() => {
    const intervalRef = { current: null as NodeJS.Timeout | null };
    const checkUrlAvailability = async () => {
      if (session?.tunnelUrl) {
        try {
          console.log("Checking URL availability", session.tunnelUrl);
          const response = await fetch("/api/check-url", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ url: session.tunnelUrl }),
          });
          const data = await response.json();
          setIsUrlAvailable(data.available);
          if (data.available && intervalRef.current) {
            clearInterval(intervalRef.current);
            intervalRef.current = null;
          }
        } catch (error) {
          console.error("Error checking URL availability:", error);
          setIsUrlAvailable(false);
        }
      }
    };

    checkUrlAvailability(); // Initial check
    intervalRef.current = setInterval(checkUrlAvailability, 2000);

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [session?.tunnelUrl]);

  // Check if the tunnel URL is available
  return (
    <div className="w-full bg-muted rounded-lg border overflow-hidden flex flex-col">
      <Tabs defaultValue="preview" className="h-full gap-0">
        <div className="flex items-center p-2 border-b bg-background justify-between">
          {/* Left side - Home and Refresh */}
          <TabsList>
            <TabsTrigger value="preview">Preview</TabsTrigger>
            <TabsTrigger value="code">Code</TabsTrigger>
          </TabsList>

          {/* Right side - New Window and Fullscreen */}
          <div className="flex items-center gap-1">
            <Button variant="ghost" size="icon" className="h-8 w-8">
              <ExternalLink className="h-4 w-4" />
            </Button>
            <Button variant="ghost" size="icon" className="h-8 w-8">
              <Maximize2 className="h-4 w-4" />
            </Button>
          </div>
        </div>
        <TabsContent value="preview" className="flex-1 h-full">
          <div className="flex-1 h-full overflow-hidden relative">
            {session?.tunnelUrl && isUrlAvailable ? (
              <iframe
                ref={iframeRef}
                src={session.tunnelUrl}
                className="w-full h-full border-none"
              />
            ) : (
              <div className="flex h-full w-full items-center justify-center">
                <div className="max-w-xs rounded-lg h-[200px] mx-auto w-full flex items-center justify-center">
                  <BootingMachine
                    label={
                      session?.tunnelUrl && !isUrlAvailable
                        ? "GENERATING PREVIEW"
                        : (session?.status?.replace(/_/g, " ") ??
                          "BOOTING MACHINE")
                    }
                    size="lg"
                  />
                </div>
              </div>
            )}
          </div>
        </TabsContent>
        <TabsContent value="code" className="flex-1 overflow-hidden">
          <ScrollArea className="h-[calc(100%-0px)]">
            <Files session={session!} />
          </ScrollArea>
        </TabsContent>
      </Tabs>
    </div>
  );
}



================================================
FILE: templates/v0-clone/components/preview/toolbar.tsx
================================================
import { Button } from "@/components/ui/button";
import { ExternalLink, Maximize2 } from "lucide-react";

export default function Toolbar() {
  return (
    <div className="flex items-center gap-2 p-2 border-b bg-background justify-between">
      {/* Left side - Home and Refresh */}
      <div className="flex items-center pl-2">
        <p className="text-sm font-medium">Preview</p>
      </div>

      {/* Right side - New Window and Fullscreen */}
      <div className="flex items-center gap-1">
        <Button variant="ghost" size="icon" className="h-8 w-8">
          <ExternalLink className="h-4 w-4" />
        </Button>
        <Button variant="ghost" size="icon" className="h-8 w-8">
          <Maximize2 className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}



================================================
FILE: templates/v0-clone/components/ui/avatar.tsx
================================================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }



================================================
FILE: templates/v0-clone/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: templates/v0-clone/components/ui/dialog.tsx
================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}



================================================
FILE: templates/v0-clone/components/ui/dropdown-menu.tsx
================================================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}



================================================
FILE: templates/v0-clone/components/ui/form.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}



================================================
FILE: templates/v0-clone/components/ui/input.tsx
================================================
import * as React from "react";

import { cn } from "@/lib/utils";

const Input = React.forwardRef<
  HTMLInputElement,
  React.InputHTMLAttributes<HTMLInputElement>
>(({ className, type, ...props }, ref) => {
  return (
    <input
      type={type}
      className={cn(
        "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-xs transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      ref={ref}
      {...props}
    />
  );
});
Input.displayName = "Input";

export { Input };



================================================
FILE: templates/v0-clone/components/ui/label.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }



================================================
FILE: templates/v0-clone/components/ui/scroll-area.tsx
================================================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }



================================================
FILE: templates/v0-clone/components/ui/select.tsx
================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}



================================================
FILE: templates/v0-clone/components/ui/separator.tsx
================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }



================================================
FILE: templates/v0-clone/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: templates/v0-clone/components/ui/table.tsx
================================================
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}



================================================
FILE: templates/v0-clone/components/ui/tabs.tsx
================================================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: templates/v0-clone/components/ui/text-shimmer.tsx
================================================
"use client";
import React, { useMemo, type JSX } from "react";
import { motion } from "framer-motion";
import { cn } from "@/lib/utils";

interface TextShimmerProps {
  children: string;
  as?: React.ElementType;
  className?: string;
  duration?: number;
  spread?: number;
}

export function TextShimmer({
  children,
  as: Component = "p",
  className,
  duration = 2,
  spread = 2,
}: TextShimmerProps) {
  const MotionComponent = motion(Component as keyof JSX.IntrinsicElements);

  const dynamicSpread = useMemo(() => {
    return children.length * spread;
  }, [children, spread]);

  return (
    <MotionComponent
      className={cn(
        "relative inline-block bg-[length:250%_100%,auto] bg-clip-text",
        "text-transparent [--base-color:#a1a1aa] [--base-gradient-color:#000]",
        "[--bg:linear-gradient(90deg,#0000_calc(50%-var(--spread)),var(--base-gradient-color),#0000_calc(50%+var(--spread)))] [background-repeat:no-repeat,padding-box]",
        "dark:[--base-color:#71717a] dark:[--base-gradient-color:#ffffff] dark:[--bg:linear-gradient(90deg,#0000_calc(50%-var(--spread)),var(--base-gradient-color),#0000_calc(50%+var(--spread)))]",
        className
      )}
      initial={{ backgroundPosition: "100% center" }}
      animate={{ backgroundPosition: "0% center" }}
      transition={{
        repeat: Infinity,
        duration,
        ease: "linear",
      }}
      style={
        {
          "--spread": `${dynamicSpread}px`,
          backgroundImage: `var(--bg), linear-gradient(var(--base-color), var(--base-color))`,
        } as React.CSSProperties
      }
    >
      {children}
    </MotionComponent>
  );
}



================================================
FILE: templates/v0-clone/components/ui/theme-toggle.tsx
================================================
"use client";

import * as React from "react";
import { Moon, Sun } from "lucide-react";
import { useTheme } from "next-themes";

import { DropdownMenuItem } from "@/components/ui/dropdown-menu";

export function ThemeToggle() {
  const { theme, setTheme } = useTheme();
  const [mounted, setMounted] = React.useState(false);

  React.useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return (
      <DropdownMenuItem disabled>
        <Sun className="mr-2 h-4 w-4" />
        Toggle theme
      </DropdownMenuItem>
    );
  }

  const isDark = theme === "dark";

  return (
    <DropdownMenuItem
      onClick={() => setTheme(isDark ? "light" : "dark")}
      className="font-medium"
    >
      {isDark ? (
        <>
          <Sun className="mr-2 h-4 w-4" />
          Light mode
        </>
      ) : (
        <>
          <Moon className="mr-2 h-4 w-4" />
          Dark mode
        </>
      )}
    </DropdownMenuItem>
  );
}



================================================
FILE: templates/v0-clone/convex/messages.ts
================================================
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";

export const getBySession = query({
  args: { sessionId: v.id("sessions") },
  handler: async (ctx, args) => {
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_session", (q) => q.eq("sessionId", args.sessionId))
      .order("asc")
      .collect();

    return messages.map((msg) => ({
      ...msg,
      id: msg._id,
    }));
  },
});

export const getById = query({
  args: { id: v.id("messages") },
  handler: async (ctx, args) => {
    const message = await ctx.db.get(args.id);
    if (!message) return null;

    return {
      ...message,
      id: message._id,
    };
  },
});

export const add = mutation({
  args: {
    sessionId: v.id("sessions"),
    role: v.union(v.literal("user"), v.literal("assistant")),
    content: v.string(),
    edits: v.optional(
      v.object({
        filePath: v.string(),
        oldString: v.string(),
        newString: v.string(),
      })
    ),
    read: v.optional(
      v.object({
        filePath: v.string(),
      })
    ),
    todos: v.optional(
      v.array(
        v.object({
          id: v.string(),
          content: v.string(),
          status: v.string(),
          priority: v.string(),
        })
      )
    ),
    checkpoint: v.optional(
      v.object({
        branch: v.string(),
        patch: v.optional(v.string()),
      })
    ),
  },
  handler: async (ctx, args) => {
    const messageId = await ctx.db.insert("messages", {
      ...args,
    });

    return messageId;
  },
});

export const update = mutation({
  args: {
    id: v.id("messages"),
    role: v.optional(v.union(v.literal("user"), v.literal("assistant"))),
    content: v.optional(v.string()),
    edits: v.optional(
      v.object({
        filePath: v.string(),
        oldString: v.string(),
        newString: v.string(),
      })
    ),
    read: v.optional(
      v.object({
        filePath: v.string(),
      })
    ),
    todos: v.optional(
      v.array(
        v.object({
          id: v.string(),
          content: v.string(),
          status: v.string(),
          priority: v.string(),
        })
      )
    ),
    checkpoint: v.optional(
      v.object({
        branch: v.string(),
        patch: v.optional(v.string()),
      })
    ),
  },
  handler: async (ctx, args) => {
    const { id, ...updates } = args;

    // Remove undefined values to avoid overwriting with undefined
    const cleanUpdates = Object.fromEntries(
      Object.entries(updates).filter(([, value]) => value !== undefined)
    );

    await ctx.db.patch(id, cleanUpdates);
  },
});

export const remove = mutation({
  args: {
    id: v.id("messages"),
    sessionId: v.id("sessions"),
  },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.id);
  },
});

export const clearBySession = mutation({
  args: { sessionId: v.id("sessions") },
  handler: async (ctx, args) => {
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_session", (q) => q.eq("sessionId", args.sessionId))
      .collect();

    for (const message of messages) {
      await ctx.db.delete(message._id);
    }
  },
});



================================================
FILE: templates/v0-clone/convex/schema.ts
================================================
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  sessions: defineTable({
    createdBy: v.optional(v.string()),
    sessionId: v.optional(v.string()),
    name: v.string(),
    tunnelUrl: v.optional(v.string()),
    repository: v.optional(v.string()),
    templateId: v.string(),
    pullRequest: v.optional(v.any()),
    status: v.union(
      v.literal("IN_PROGRESS"),
      v.literal("CLONING_REPO"),
      v.literal("INSTALLING_DEPENDENCIES"),
      v.literal("STARTING_DEV_SERVER"),
      v.literal("CREATING_TUNNEL"),
      v.literal("CUSTOM"),
      v.literal("RUNNING")
    ),
    statusMessage: v.optional(v.string()),
  }).index("by_createdBy", ["createdBy"]),

  messages: defineTable({
    sessionId: v.id("sessions"),
    role: v.union(v.literal("user"), v.literal("assistant")),
    edits: v.optional(
      v.object({
        filePath: v.string(),
        oldString: v.string(),
        newString: v.string(),
      })
    ),
    todos: v.optional(
      v.array(
        v.object({
          id: v.string(),
          content: v.string(),
          status: v.string(),
          priority: v.string(),
        })
      )
    ),
    read: v.optional(
      v.object({
        filePath: v.string(),
      })
    ),
    checkpoint: v.optional(
      v.object({
        branch: v.string(),
        patch: v.optional(v.string()),
      })
    ),
    content: v.string(),
  }).index("by_session", ["sessionId"]),
});



================================================
FILE: templates/v0-clone/convex/sessions.ts
================================================
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";

// Queries
export const list = query({
  args: {
    createdBy: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    let sessions;

    if (args.createdBy) {
      sessions = await ctx.db
        .query("sessions")
        .withIndex("by_createdBy", (q) => q.eq("createdBy", args.createdBy))
        .order("desc")
        .collect();
    } else {
      sessions = await ctx.db.query("sessions").order("desc").collect();
    }

    // Get messages for each session
    const sessionsWithMessages = await Promise.all(
      sessions.map(async (session) => {
        const messages = await ctx.db
          .query("messages")
          .withIndex("by_session", (q) => q.eq("sessionId", session._id))
          .order("asc")
          .collect();

        return {
          ...session,
          id: session._id,
          messages: messages.map((msg) => ({
            ...msg,
            id: msg._id,
          })),
        };
      })
    );

    return sessionsWithMessages;
  },
});

export const getById = query({
  args: { id: v.id("sessions") },
  handler: async (ctx, args) => {
    const session = await ctx.db.get(args.id);
    if (!session) return null;

    const messages = await ctx.db
      .query("messages")
      .withIndex("by_session", (q) => q.eq("sessionId", args.id))
      .order("asc")
      .collect();

    return {
      ...session,
      id: session._id,
      messages: messages.map((msg) => ({
        ...msg,
        id: msg._id,
      })),
    };
  },
});

// Mutations
export const create = mutation({
  args: {
    sessionId: v.optional(v.string()),
    branch: v.optional(v.string()),
    createdBy: v.optional(v.string()),
    repository: v.optional(v.string()),
    pullRequest: v.optional(v.any()),
    name: v.string(),
    tunnelUrl: v.optional(v.string()),
    templateId: v.string(),
    status: v.union(
      v.literal("IN_PROGRESS"),
      v.literal("CLONING_REPO"),
      v.literal("INSTALLING_DEPENDENCIES"),
      v.literal("STARTING_DEV_SERVER"),
      v.literal("CREATING_TUNNEL"),
      v.literal("CUSTOM"),
      v.literal("RUNNING")
    ),
    statusMessage: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const id = await ctx.db.insert("sessions", {
      ...args,
    });

    return id;
  },
});

export const update = mutation({
  args: {
    id: v.id("sessions"),
    sessionId: v.optional(v.string()),
    name: v.optional(v.string()),
    tunnelUrl: v.optional(v.string()),
    repository: v.optional(v.string()),
    pullRequest: v.optional(v.any()),
    templateId: v.optional(v.string()),
    branch: v.optional(v.string()),
    status: v.optional(
      v.union(
        v.literal("IN_PROGRESS"),
        v.literal("CLONING_REPO"),
        v.literal("INSTALLING_DEPENDENCIES"),
        v.literal("STARTING_DEV_SERVER"),
        v.literal("CREATING_TUNNEL"),
        v.literal("CUSTOM"),
        v.literal("RUNNING")
      )
    ),
    statusMessage: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const { id, ...updates } = args;

    await ctx.db.patch(id, {
      ...updates,
    });
  },
});

export const remove = mutation({
  args: { id: v.id("sessions") },
  handler: async (ctx, args) => {
    // Delete all messages for this session first
    const messages = await ctx.db
      .query("messages")
      .withIndex("by_session", (q) => q.eq("sessionId", args.id))
      .collect();

    for (const message of messages) {
      await ctx.db.delete(message._id);
    }

    await ctx.db.delete(args.id);
  },
});



================================================
FILE: templates/v0-clone/convex/_generated/api.d.ts
================================================
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  ApiFromModules,
  FilterApi,
  FunctionReference,
} from "convex/server";
import type * as messages from "../messages.js";
import type * as sessions from "../sessions.js";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
declare const fullApi: ApiFromModules<{
  messages: typeof messages;
  sessions: typeof sessions;
}>;
export declare const api: FilterApi<
  typeof fullApi,
  FunctionReference<any, "public">
>;
export declare const internal: FilterApi<
  typeof fullApi,
  FunctionReference<any, "internal">
>;



================================================
FILE: templates/v0-clone/convex/_generated/api.js
================================================
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import { anyApi } from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
export const api = anyApi;
export const internal = anyApi;



================================================
FILE: templates/v0-clone/convex/_generated/dataModel.d.ts
================================================
/* eslint-disable */
/**
 * Generated data model types.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  DataModelFromSchemaDefinition,
  DocumentByName,
  TableNamesInDataModel,
  SystemTableNames,
} from "convex/server";
import type { GenericId } from "convex/values";
import schema from "../schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<
  DataModel,
  TableName
>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames | SystemTableNames> =
  GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like `queryGeneric` and
 * `mutationGeneric` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;



================================================
FILE: templates/v0-clone/convex/_generated/server.d.ts
================================================
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  ActionBuilder,
  HttpActionBuilder,
  MutationBuilder,
  QueryBuilder,
  GenericActionCtx,
  GenericMutationCtx,
  GenericQueryCtx,
  GenericDatabaseReader,
  GenericDatabaseWriter,
} from "convex/server";
import type { DataModel } from "./dataModel.js";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const query: QueryBuilder<DataModel, "public">;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const internalQuery: QueryBuilder<DataModel, "internal">;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const mutation: MutationBuilder<DataModel, "public">;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const internalMutation: MutationBuilder<DataModel, "internal">;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export declare const action: ActionBuilder<DataModel, "public">;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export declare const internalAction: ActionBuilder<DataModel, "internal">;

/**
 * Define an HTTP action.
 *
 * This function will be used to respond to HTTP requests received by a Convex
 * deployment if the requests matches the path and method where this action
 * is routed. Be sure to route your action in `convex/http.js`.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Import this function from `convex/http.js` and route it to hook it up.
 */
export declare const httpAction: HttpActionBuilder;

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;

/**
 * A set of services for use within Convex action functions.
 *
 * The action context is passed as the first argument to any Convex action
 * function run on the server.
 */
export type ActionCtx = GenericActionCtx<DataModel>;

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link Id}, or {@link DatabaseReader.query}, which starts
 * building a query.
 */
export type DatabaseReader = GenericDatabaseReader<DataModel>;

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 */
export type DatabaseWriter = GenericDatabaseWriter<DataModel>;



================================================
FILE: templates/v0-clone/convex/_generated/server.js
================================================
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
} from "convex/server";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const query = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const internalQuery = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const mutation = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const internalMutation = internalMutationGeneric;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export const action = actionGeneric;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export const internalAction = internalActionGeneric;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */
export const httpAction = httpActionGeneric;



================================================
FILE: templates/v0-clone/lib/auth.ts
================================================
import NextAuth from "next-auth";
import GitHub from "next-auth/providers/github";

// Extend the session type to include custom properties
declare module "next-auth" {
  interface Session {
    accessToken?: string;
    githubId?: string;
    githubUsername?: string;
  }
}

export const { handlers, signIn, signOut, auth } = NextAuth({
  providers: [
    GitHub({
      clientId: process.env.AUTH_GITHUB_ID!,
      clientSecret: process.env.AUTH_GITHUB_SECRET!,
      authorization: {
        params: {
          scope: "read:user user:email repo read:org",
        },
      },
    }),
  ],
  callbacks: {
    async signIn({ account }) {
      if (account?.provider === "github") {
        return true;
      }
      return true;
    },

    async jwt({ token, account, profile }) {
      // Persist the OAuth access_token and refresh_token to the token right after signin
      if (account) {
        token.accessToken = account.access_token;
        token.refreshToken = account.refresh_token;
        token.githubId = profile?.id;
        token.githubUsername = profile?.login;
      }

      return token;
    },

    async session({ session, token }) {
      // Send properties to the client
      if (token.accessToken) {
        session.accessToken = token.accessToken as string;
        session.githubId = token.githubId as string;
        session.githubUsername = token.githubUsername as string;
      }

      return session;
    },
  },
  debug: process.env.NODE_ENV === "development", // Enable debug mode to see more logs
});



================================================
FILE: templates/v0-clone/lib/hooks.ts
================================================
import { useEffect, useState, useRef } from "react";

interface UseUrlAvailabilityOptions {
  url?: string;
  enabled?: boolean;
  retryInterval?: number;
  timeout?: number;
}

export function useUrlAvailability({
  url,
  enabled = true,
  retryInterval = 2000,
  timeout = 5000,
}: UseUrlAvailabilityOptions) {
  const [isUrlReady, setIsUrlReady] = useState(false);
  const [isChecking, setIsChecking] = useState(false);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  const checkUrlWithIframe = (urlToCheck: string) => {
    if (!urlToCheck) return;

    setIsChecking(true);
    setIsUrlReady(false);

    // Create a hidden iframe to test the URL
    const testIframe = document.createElement("iframe");
    testIframe.style.display = "none";
    testIframe.style.width = "1px";
    testIframe.style.height = "1px";

    let hasLoaded = false;
    let hasError = false;

    const cleanup = () => {
      if (document.body.contains(testIframe)) {
        document.body.removeChild(testIframe);
      }
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
    };

    const onLoad = () => {
      if (!hasLoaded && !hasError) {
        hasLoaded = true;
        setIsUrlReady(true);
        setIsChecking(false);
        cleanup();
      }
    };

    const onError = () => {
      if (!hasLoaded && !hasError) {
        hasError = true;
        // If error, try again after retry interval
        timeoutRef.current = setTimeout(() => {
          if (!isUrlReady) {
            checkUrlWithIframe(urlToCheck);
          }
        }, retryInterval);
        cleanup();
      }
    };

    // Set timeout to prevent infinite waiting
    timeoutRef.current = setTimeout(() => {
      if (!hasLoaded && !hasError) {
        hasError = true;
        // If timeout, try again after retry interval
        timeoutRef.current = setTimeout(() => {
          if (!isUrlReady) {
            checkUrlWithIframe(urlToCheck);
          }
        }, retryInterval);
        cleanup();
      }
    }, timeout);

    testIframe.onload = onLoad;
    testIframe.onerror = onError;
    testIframe.src = urlToCheck;

    document.body.appendChild(testIframe);
  };

  useEffect(() => {
    if (url && enabled) {
      checkUrlWithIframe(url);
    } else {
      setIsUrlReady(false);
      setIsChecking(false);
    }

    // Cleanup on unmount or when dependencies change
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
    };
  }, [url, enabled, retryInterval, timeout]);

  return {
    isUrlReady,
    isChecking,
    checkUrl: () => url && checkUrlWithIframe(url),
  };
}



================================================
FILE: templates/v0-clone/lib/inngest.ts
================================================
import { Inngest } from "inngest";
import { realtimeMiddleware, channel, topic } from "@inngest/realtime";
import { VibeKit, VibeKitConfig } from "@vibe-kit/sdk";
import { fetchMutation } from "convex/nextjs";

import { api } from "@/convex/_generated/api";
import { runAgentAction } from "@/app/actions/vibekit";
import { generateSessionTitle } from "@/app/actions/session";
import { createRepo } from "@/app/actions/github";
import { Template } from "@/config";
import { Id } from "@/convex/_generated/dataModel";

let app: Inngest | undefined;
// Create a client to send and receive events
export const inngest = new Inngest({
  id: "vibe0",
  middleware: [realtimeMiddleware()],
});

export const sessionChannel = channel("sessions")
  .addTopic(
    topic("status").type<{
      status:
        | "IN_PROGRESS"
        | "CLONING_REPO"
        | "INSTALLING_DEPENDENCIES"
        | "STARTING_DEV_SERVER"
        | "CREATING_TUNNEL"
        | "RUNNING";
      sessionId: string;
      id: string;
    }>()
  )
  .addTopic(
    topic("update").type<{
      sessionId: string;
      message: Record<string, unknown>;
    }>()
  );

export const getInngestApp = () => {
  return (app ??= new Inngest({
    id: typeof window !== "undefined" ? "client" : "server",
    middleware: [realtimeMiddleware()],
  }));
};

export const runAgent = inngest.createFunction(
  { id: "run-agent", retries: 0, concurrency: 100 },
  { event: "vibe0/run.agent" },
  async ({ event, step }) => {
    const {
      sessionId,
      id,
      message,
      template,
    }: {
      sessionId: string;
      id: Id<"sessions">;
      message: string;
      template: Template;
    } = event.data;

    const config: VibeKitConfig = {
      agent: {
        type: "claude",
        model: {
          apiKey: process.env.ANTHROPIC_API_KEY!,
        },
      },
      environment: {
        northflank: {
          apiKey: process.env.NORTHFLANK_API_KEY!,
          projectId: process.env.NORTHFLANK_PROJECT_ID!,
        },
      },
      sessionId,
    };

    const result = await step.run("generate code", async () => {
      const vibekit = new VibeKit(config);

      await fetchMutation(api.sessions.update, {
        id,
        status: "CUSTOM",
        statusMessage: "Working on task",
      });

      const prompt =
        template?.systemPrompt ||
        "# GOAL\nYou are an helpful assistant that is tasked with helping the user build a NextJS app.\n" +
          "- The NextJS dev server is running on port 3000.\n" +
          +"Do not run tests or restart the dev server.\n" +
          `Follow the users intructions:\n\n# INSTRUCTIONS\n${message}`;

      const response = await vibekit.generateCode({
        prompt: prompt,
        mode: "code",
        callbacks: {
          async onUpdate(message) {
            const data = JSON.parse(message);

            if (data.type === "user") {
              await fetchMutation(api.sessions.update, {
                id,
                status: "CUSTOM",
                statusMessage: data.message.content[0].content,
              });
            }

            if (data.type === "assistant") {
              await fetchMutation(api.sessions.update, {
                id,
                status: "CUSTOM",
                statusMessage: "Working on task",
              });

              switch (data.message.content[0].type) {
                case "text":
                  await fetchMutation(api.messages.add, {
                    sessionId: id,
                    content: data.message.content[0].text,
                    role: "assistant",
                  });
                  break;
                case "tool_use":
                  const toolName = data.message.content[0].name;

                  switch (toolName) {
                    case "TodoWrite":
                      await fetchMutation(api.messages.add, {
                        sessionId: id,
                        role: "assistant",
                        content: "",
                        todos: data.message.content[0].input.todos,
                      });
                      break;
                    case "Write":
                      await fetchMutation(api.messages.add, {
                        sessionId: id,
                        role: "assistant",
                        content: "",
                        edits: {
                          filePath: data.message.content[0].input.file_path,
                          oldString: "",
                          newString: data.message.content[0].input.content,
                        },
                      });
                      break;
                    case "Edit":
                      await fetchMutation(api.messages.add, {
                        sessionId: id,
                        role: "assistant",
                        content: "",
                        edits: {
                          filePath: data.message.content[0].input.file_path,
                          oldString: data.message.content[0].input.old_string,
                          newString: data.message.content[0].input.new_string,
                        },
                      });
                      break;
                    case "Read":
                      await fetchMutation(api.messages.add, {
                        sessionId: id,
                        role: "assistant",
                        content: "",
                        read: {
                          filePath: data.message.content[0].input.file_path,
                        },
                      });
                      break;
                    case "Write":
                      await fetchMutation(api.messages.add, {
                        sessionId: id,
                        role: "assistant",
                        content: "",
                        read: {
                          filePath: data.message.content[0].input.file_path,
                        },
                      });
                    default:
                      break;
                  }
                  break;
                default:
                  break;
              }
            }
          },
        },
      });

      // // Save checkpoint to database
      // if (checkpointBranch) {
      //   await fetchMutation(api.messages.add, {
      //     sessionId: id,
      //     role: "assistant",
      //     content: "",
      //     checkpoint: {
      //       branch: checkpointBranch,
      //       patch: patchContent.length > 0 ? patchContent : undefined,
      //     },
      //   });

      //   console.log("Checkpoint saved:", checkpointBranch);
      // }

      return response;
    });

    await step.run("update session", async () => {
      await fetchMutation(api.sessions.update, {
        id,
        status: "RUNNING",
      });
    });

    return result;
  }
);

export const createSession = inngest.createFunction(
  { id: "create-session", retries: 0, concurrency: 100 },
  { event: "vibe0/create.session" },

  async ({ event, step }) => {
    const {
      sessionId: id,
      message,
      repository,
      token,
      template,
    }: {
      sessionId: Id<"sessions">;
      message: string;
      repository: string;
      token: string;
      template: Template;
    } = event.data;

    let sandboxId: string;

    const config: VibeKitConfig = {
      agent: {
        type: "claude",
        model: {
          apiKey: process.env.ANTHROPIC_API_KEY!,
        },
      },
      environment: {
        northflank: {
          apiKey: process.env.NORTHFLANK_API_KEY!,
          projectId: process.env.NORTHFLANK_PROJECT_ID!,
          image: template?.image,
        },
      },
      secrets: template?.secrets,
    };

    const vibekit = new VibeKit(config);

    const data = await step.run("get tunnel url", async () => {
      const title = await generateSessionTitle(message);

      await fetchMutation(api.sessions.update, {
        id,
        status: "CLONING_REPO",
        name: title,
      });

      if (!repository && template) {
        const repository = await createRepo({
          repoName: `vibe0-${template.repository.replace("https://github.com/", "").replace("/", "-")}-${Date.now().toString().slice(-6)}`,
          token,
        });

        // Handle both full GitHub URLs and repo paths
        const templateCloneUrl = template.repository.startsWith(
          "https://github.com/"
        )
          ? `${template.repository}.git`
          : `https://github.com/${template.repository}.git`;

        const commands = [
          // Clone the template repo directly to root
          `git clone ${templateCloneUrl} .`,
          // Configure git user for commits
          `git config --global user.email "vibe0@vibekit.sh"`,
          `git config --global user.name "Vibe0 Bot"`,
          // Remove the template's git history and set up new repo
          `rm -rf .git`,
          `git init`,
          `git checkout -b main`,
          `git remote add origin https://${token}@github.com/${repository.full_name}.git`,
          // Add, commit and push all files
          `git add . && git commit -m "Initial commit from template ${template}" && git push -u origin main`,
        ];

        for (const command of commands) {
          const { sandboxId: _sandboxId } = await vibekit.executeCommand(
            command,
            {
              callbacks: {
                onUpdate(message) {
                  console.log(message);
                },
              },
            }
          );

          sandboxId = _sandboxId;
        }

        await fetchMutation(api.sessions.update, {
          id,
          repository: repository.full_name,
        });

        for await (const command of template.startCommands) {
          await fetchMutation(api.sessions.update, {
            id,
            status: command.status,
            sessionId: sandboxId,
          });

          await vibekit.executeCommand(command.command, {
            background: command.background,
            callbacks: {
              onUpdate(message) {
                console.log(message);
              },
            },
          });
        }

        const host = await vibekit.getHost(3000);

        return {
          sandboxId: sandboxId,
          tunnelUrl: `https://${host}`,
        };
      } else {
        const { sandboxId: _sandboxId } = await vibekit.executeCommand(
          `git clone https://${token}@github.com/${repository}.git .`
        );

        sandboxId = _sandboxId;

        await fetchMutation(api.sessions.update, {
          id,
          status: "INSTALLING_DEPENDENCIES",
        });

        await vibekit.executeCommand("npm i", {
          callbacks: {
            onUpdate(message) {
              console.log(message);
            },
          },
        });

        await fetchMutation(api.sessions.update, {
          id,
          status: "STARTING_DEV_SERVER",
        });

        await vibekit.executeCommand("npm run dev", {
          background: true,
          callbacks: {
            onUpdate(message) {
              console.log(message);
            },
          },
        });

        await fetchMutation(api.sessions.update, {
          id,
          status: "CREATING_TUNNEL",
        });

        const host = await vibekit.getHost(3000);

        return {
          sandboxId: sandboxId,
          tunnelUrl: `https://${host}`,
        };
      }
    });

    await step.sleep("wait-with-ms", 2 * 1000);

    await step.run("update session", async () => {
      await fetchMutation(api.sessions.update, {
        id,
        status: "RUNNING",
        tunnelUrl: data.tunnelUrl,
      });
    });

    if (message) {
      await step.run("run agent", async () => {
        await runAgentAction({
          sessionId: data.sandboxId,
          id,
          message,
          template,
          repository,
          token,
        });
      });
    }

    return data;
  }
);



================================================
FILE: templates/v0-clone/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================
FILE: templates/v0-clone/providers/auth-provider.tsx
================================================
"use client";

import { SessionProvider } from "next-auth/react";
import { ReactNode } from "react";

interface ProvidersProps {
  children: ReactNode;
}

export function AuthProvider({ children }: ProvidersProps) {
  return <SessionProvider>{children}</SessionProvider>;
}



================================================
FILE: templates/v0-clone/providers/convex-provider.tsx
================================================
"use client";

import { ConvexProvider, ConvexReactClient } from "convex/react";
import { ReactNode } from "react";

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({ children }: { children: ReactNode }) {
  return <ConvexProvider client={convex}>{children}</ConvexProvider>;
}



================================================
FILE: templates/v0-clone/providers/theme-provider.tsx
================================================
"use client";

import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";

type ThemeProviderProps = React.ComponentProps<typeof NextThemesProvider>;

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}



================================================
FILE: templates/v0-clone/public/convex.webp
================================================
[Binary file]


================================================
FILE: test/claude-oauth-web.test.ts
================================================
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { 
  ClaudeWebAuth, 
  MemoryTokenStorage, 
  LocalStorageTokenStorage,
  type TokenStorage,
  type OAuthToken 
} from '../packages/auth/src/browser.js';

describe('ClaudeWebAuth - CLI-like OAuth Flow', () => {
  let storage: TokenStorage;
  let auth: ClaudeWebAuth;
  
  beforeEach(() => {
    storage = new MemoryTokenStorage('test-session');
    auth = new ClaudeWebAuth(storage);
    global.fetch = vi.fn();
  });
  
  describe('Complete OAuth Flow (like CLI)', () => {
    it('should complete authentication flow with manual code input', async () => {
      // Step 1: Generate authorization URL (like CLI)
      const { url, state, codeVerifier } = await ClaudeWebAuth.createAuthorizationUrl();
      
      // Verify URL is correct for manual code copying
      expect(url).toContain('https://claude.ai/oauth/authorize');
      expect(url).toContain('code=true'); // Important: enables manual code copying
      expect(url).toContain(`state=${state}`);
      
      // Step 2: User opens URL in browser (we can't test this part)
      // In real usage: window.open(url, '_blank');
      
      // Step 3: User copies and pastes authentication code
      const userPastedCode = `test-auth-code#${state}`; // Format: code#state
      
      // Mock successful token exchange
      (global.fetch as any).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          access_token: 'access-token-from-claude',
          token_type: 'Bearer',
          expires_in: 86400, // 24 hours
          refresh_token: 'refresh-token-from-claude',
          scope: 'org:create_api_key user:profile user:inference'
        })
      });
      
      // Step 4: Complete authentication
      const token = await auth.authenticate(userPastedCode, codeVerifier, state);
      
      // Verify results
      expect(token.access_token).toBe('access-token-from-claude');
      expect(token.refresh_token).toBe('refresh-token-from-claude');
      expect(token.created_at).toBeDefined();
      
      // Verify token was saved
      const savedToken = await auth.getToken();
      expect(savedToken?.access_token).toBe('access-token-from-claude');
    });
    
    it('should reject invalid code format', async () => {
      const { state, codeVerifier } = await ClaudeWebAuth.createAuthorizationUrl();
      
      // User pastes wrong format (missing #state)
      const invalidCode = 'just-a-code-without-state';
      
      await expect(
        auth.authenticate(invalidCode, codeVerifier, state)
      ).rejects.toThrow('Invalid authentication code format. Expected: code#state');
    });
    
    it('should reject state mismatch', async () => {
      const { state, codeVerifier } = await ClaudeWebAuth.createAuthorizationUrl();
      
      // User somehow gets a code with wrong state
      const codeWithWrongState = 'test-code#wrong-state';
      
      await expect(
        auth.authenticate(codeWithWrongState, codeVerifier, state)
      ).rejects.toThrow('State mismatch. Authentication failed.');
    });
  });
  
  describe('Token Management (after authentication)', () => {
    const mockToken: OAuthToken = {
      access_token: 'current-access-token',
      refresh_token: 'refresh-token',
      token_type: 'Bearer',
      expires_in: 3600,
      created_at: Date.now() - 7200 * 1000 // Expired 2 hours ago
    };
    
    it('should auto-refresh expired token', async () => {
      // Setup: User already authenticated
      await storage.set(mockToken);
      
      // Mock refresh token exchange
      (global.fetch as any).mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          access_token: 'new-refreshed-token',
          expires_in: 86400
        })
      });
      
      // Get valid token (should trigger refresh)
      const validToken = await auth.getValidToken();
      
      expect(validToken).toBe('new-refreshed-token');
      expect(global.fetch).toHaveBeenCalledWith(
        'https://console.anthropic.com/v1/oauth/token',
        expect.objectContaining({
          body: expect.stringContaining('"grant_type":"refresh_token"')
        })
      );
    });
    
    it('should check authentication status', async () => {
      // Not authenticated
      expect(await auth.isAuthenticated()).toBe(false);
      
      // After authentication
      await storage.set({
        access_token: 'valid-token',
        token_type: 'Bearer',
        created_at: Date.now()
      });
      
      expect(await auth.isAuthenticated()).toBe(true);
    });
    
    it('should verify token with Claude API', async () => {
      await storage.set({
        access_token: 'valid-token',
        token_type: 'Bearer',
        created_at: Date.now()
      });
      
      // Mock successful API call
      (global.fetch as any).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ content: [{ text: 'OK' }] })
      });
      
      const isValid = await auth.verify();
      expect(isValid).toBe(true);
      
      // Verify correct headers were sent
      expect(global.fetch).toHaveBeenCalledWith(
        'https://api.anthropic.com/v1/messages',
        expect.objectContaining({
          headers: expect.objectContaining({
            'Authorization': 'Bearer valid-token',
            'X-API-Key': '',
            'anthropic-beta': 'oauth-2025-04-20'
          })
        })
      );
    });
    
    it('should logout and clear token', async () => {
      await storage.set(mockToken);
      await auth.logout();
      
      expect(await auth.getToken()).toBeNull();
      expect(await auth.isAuthenticated()).toBe(false);
    });
  });
  
  describe('Storage Options', () => {
    it('should work with different storage implementations', async () => {
      // Test with in-memory storage
      const memStorage = new MemoryTokenStorage('session-123');
      const memAuth = new ClaudeWebAuth(memStorage);
      
      const token: OAuthToken = {
        access_token: 'test-token',
        token_type: 'Bearer',
        created_at: Date.now()
      };
      
      await memStorage.set(token);
      const retrieved = await memStorage.get();
      expect(retrieved?.access_token).toBe('test-token');
    });
    
    it('should handle localStorage in browser environment', async () => {
      // Mock browser environment
      (global as any).window = {
        localStorage: {
          getItem: vi.fn(),
          setItem: vi.fn(),
          removeItem: vi.fn()
        }
      };
      
      const storage = new LocalStorageTokenStorage('test-key');
      const token: OAuthToken = {
        access_token: 'browser-token',
        token_type: 'Bearer',
        created_at: Date.now()
      };
      
      await storage.set(token);
      expect(window.localStorage.setItem).toHaveBeenCalledWith(
        'test-key',
        JSON.stringify(token)
      );
      
      // Cleanup
      delete (global as any).window;
    });
  });
  
  describe('Error Handling', () => {
    it('should handle API errors gracefully', async () => {
      const { state, codeVerifier } = await ClaudeWebAuth.createAuthorizationUrl();
      
      // Mock API error
      (global.fetch as any).mockResolvedValueOnce({
        ok: false,
        text: async () => 'Invalid authorization code'
      });
      
      await expect(
        auth.authenticate(`code#${state}`, codeVerifier, state)
      ).rejects.toThrow('Failed to exchange code for token: Invalid authorization code');
    });
    
    it('should handle network errors', async () => {
      await storage.set({
        access_token: 'token',
        token_type: 'Bearer',
        created_at: Date.now()
      });
      
      // Mock network error
      (global.fetch as any).mockRejectedValueOnce(new Error('Network error'));
      
      const isValid = await auth.verify();
      expect(isValid).toBe(false);
    });
  });
});


================================================
FILE: test/claude-oauth.test.ts
================================================
import { describe, it, expect, beforeAll } from "vitest";
import { ClaudeAgent } from "../packages/sdk/src/agents/claude";
import { getValidToken, loadToken, ClaudeAuth } from "../packages/auth/src/node.js";
import type { ClaudeConfig } from "../packages/sdk/src/types";
import dotenv from "dotenv";

dotenv.config();

describe("Claude OAuth Authentication", () => {
  let oauthToken: string | null = null;

  beforeAll(async () => {
    // Try to get OAuth token from saved credentials
    oauthToken = await getValidToken();
    if (!oauthToken && process.env.CLAUDE_CODE_OAUTH_TOKEN) {
      oauthToken = process.env.CLAUDE_CODE_OAUTH_TOKEN;
    }
  });

  describe("Agent Configuration", () => {
    it("should create Claude agent with OAuth token from config", () => {
      const config: ClaudeConfig = {
        oauthToken: "test-oauth-token",
        model: "claude-sonnet-4-20250514",
      };

      const agent = new ClaudeAgent(config);
      expect(agent).toBeDefined();
      expect(agent.getApiKey()).toBe("test-oauth-token");
    });

    it("should prioritize OAuth token from config over environment variable", () => {
      const originalToken = process.env.CLAUDE_CODE_OAUTH_TOKEN;
      process.env.CLAUDE_CODE_OAUTH_TOKEN = "env-oauth-token";

      const config: ClaudeConfig = {
        oauthToken: "config-oauth-token",
        model: "claude-sonnet-4-20250514",
      };

      const agent = new ClaudeAgent(config);
      expect(agent.getApiKey()).toBe("config-oauth-token");

      // Restore
      if (originalToken) {
        process.env.CLAUDE_CODE_OAUTH_TOKEN = originalToken;
      } else {
        delete process.env.CLAUDE_CODE_OAUTH_TOKEN;
      }
    });

    it("should use OAuth token from environment when not provided in config", () => {
      const originalToken = process.env.CLAUDE_CODE_OAUTH_TOKEN;
      process.env.CLAUDE_CODE_OAUTH_TOKEN = "env-oauth-token";

      const config: ClaudeConfig = {
        model: "claude-sonnet-4-20250514",
      };

      const agent = new ClaudeAgent(config);
      expect(agent.getApiKey()).toBe("env-oauth-token");

      // Restore
      if (originalToken) {
        process.env.CLAUDE_CODE_OAUTH_TOKEN = originalToken;
      } else {
        delete process.env.CLAUDE_CODE_OAUTH_TOKEN;
      }
    });

    it("should throw error when neither API key nor OAuth token is provided", async () => {
      const originalApiKey = process.env.ANTHROPIC_API_KEY;
      const originalToken = process.env.CLAUDE_CODE_OAUTH_TOKEN;
      
      delete process.env.ANTHROPIC_API_KEY;
      delete process.env.CLAUDE_CODE_OAUTH_TOKEN;

      const config: ClaudeConfig = {
        model: "claude-sonnet-4-20250514",
      };

      const agent = new ClaudeAgent(config);
      
      // The error is thrown when the agent is used, not during construction
      await expect(agent.generateCode("test")).rejects.toThrow(
        "Claude agent requires either providerApiKey or oauthToken"
      );

      // Restore
      if (originalApiKey) process.env.ANTHROPIC_API_KEY = originalApiKey;
      if (originalToken) process.env.CLAUDE_CODE_OAUTH_TOKEN = originalToken;
    });
  });

  describe("API Integration", () => {
    it("should make successful API call with OAuth token", async () => {
      if (!oauthToken) {
        console.log("Skipping API test - No OAuth token available");
        console.log("Run 'vibekit auth login claude' to authenticate");
        return;
      }

      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          "anthropic-version": "2023-06-01",
          "anthropic-beta": "oauth-2025-04-20",
          "Authorization": `Bearer ${oauthToken}`,
          "X-API-Key": "",
        },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 20,
          system: "You are Claude Code, Anthropic's official CLI for Claude.",
          messages: [{
            role: "user",
            content: "Reply with 'OAuth works!' only"
          }]
        }),
      });

      expect(response.ok).toBe(true);
      expect(response.status).toBe(200);
      
      const data = await response.json();
      expect(data).toHaveProperty("content");
      expect(data.content[0].text).toContain("OAuth works!");
    }, 30000);

    it("should verify token details", async () => {
      const tokenData = await loadToken();
      
      if (!tokenData) {
        console.log("Skipping token details test - No saved token");
        return;
      }

      expect(tokenData).toHaveProperty("access_token");
      expect(tokenData).toHaveProperty("refresh_token");
      expect(tokenData).toHaveProperty("created_at");
      
      if (tokenData.expires_in) {
        const expiresAt = new Date(tokenData.created_at + tokenData.expires_in * 1000);
        const now = new Date();
        console.log(`Token expires at: ${expiresAt.toLocaleString()}`);
        console.log(`Time remaining: ${Math.round((expiresAt.getTime() - now.getTime()) / 1000 / 60)} minutes`);
      }
    });

    it("should fail with invalid OAuth token", async () => {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: {
          "content-type": "application/json",
          "anthropic-version": "2023-06-01",
          "anthropic-beta": "oauth-2025-04-20",
          "Authorization": "Bearer invalid-token-12345",
          "X-API-Key": "",
        },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 10,
          system: "You are Claude Code, Anthropic's official CLI for Claude.",
          messages: [{ role: "user", content: "test" }]
        }),
      });

      expect(response.ok).toBe(false);
      expect(response.status).toBe(401);
    });
  });

  describe("Library API", () => {
    it("should check authentication status", async () => {
      const isAuthenticated = await ClaudeAuth.isAuthenticated();
      expect(typeof isAuthenticated).toBe("boolean");
    });

    it("should get authentication status details", async () => {
      const status = await ClaudeAuth.getStatus();
      expect(status).toHaveProperty("authenticated");
      
      if (status.authenticated) {
        expect(status).toHaveProperty("tokenType");
        expect(status).toHaveProperty("scope");
        expect(status).toHaveProperty("hasRefreshToken");
      }
    });

    it("should export token when authenticated", async () => {
      const isAuthenticated = await ClaudeAuth.isAuthenticated();
      
      if (isAuthenticated) {
        const envExport = await ClaudeAuth.exportToken("env");
        expect(typeof envExport).toBe("string");
        expect(envExport).toContain("export CLAUDE_CODE_OAUTH_TOKEN=");
        
        const jsonExport = await ClaudeAuth.exportToken("json");
        expect(jsonExport).toHaveProperty("access_token");
      }
    });

    it("should handle verify method", async () => {
      const isVerified = await ClaudeAuth.verify();
      expect(typeof isVerified).toBe("boolean");
    });
  });
});


================================================
FILE: test/claude.test.ts
================================================
import { describe, it, expect, vi } from "vitest";
import { VibeKit } from "../packages/sdk/src/index.js";
import { createE2BProvider } from "../packages/e2b/dist/index.js";
import { skipIfNoClaudeKeys, skipTest } from "./helpers/test-utils.js";
import dotenv from "dotenv";

dotenv.config();

describe("Claude Code CLI", () => {
  it("should generate code with claude cli", async () => {
    if (skipIfNoClaudeKeys()) {
      return skipTest();
    }

    const prompt = "Hi there";

    const e2bProvider = createE2BProvider({
      apiKey: process.env.E2B_API_KEY!,
      templateId: "vibekit-claude",
    });

    const vibeKit = new VibeKit()
      .withAgent({
        type: "claude",
        provider: "anthropic",
        apiKey: process.env.ANTHROPIC_API_KEY!,
        model: "claude-sonnet-4-20250514",
      })
      .withSandbox(e2bProvider);

    const updateSpy = vi.fn();
    const errorSpy = vi.fn();

    vibeKit.on("update", updateSpy);
    vibeKit.on("error", errorSpy);

    const result = await vibeKit.generateCode({ prompt, mode: "ask" });
    const host = await vibeKit.getHost(3000);

    await vibeKit.kill();

    expect(result).toBeDefined();
    expect(host).toBeDefined();
    expect(updateSpy).toHaveBeenCalled();
    expect(errorSpy).not.toHaveBeenCalled();
  }, 60000);
});



================================================
FILE: test/cloudflare.test.ts
================================================
/**
 * Unit Tests for Cloudflare Sandbox Provider
 *
 * Unit tests that verify interface compliance, configuration handling,
 * and Cloudflare-specific functionality using mocked dependencies.
 * These tests run in Node.js and mock the @cloudflare/sandbox package
 * since it only works within Cloudflare Workers.
 */

import { describe, it, expect, beforeEach, vi } from "vitest";
import {
  createCloudflareProvider,
  CloudflareSandboxProvider,
  type CloudflareConfig,
} from "../packages/cloudflare/dist/index.js";

describe("Cloudflare Sandbox Provider - Unit Tests", () => {
  // Mock Worker environment with Durable Object binding
  const mockEnv = {
    Sandbox: {
      idFromName: vi.fn().mockReturnValue({ toString: () => "mock-id" }),
      get: vi.fn().mockReturnValue({}),
    },
  };

  const validConfig: CloudflareConfig = {
    env: mockEnv,
    hostname: "test-worker.example.workers.dev",
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("Provider Creation and Configuration", () => {
    it("should create a cloudflare provider instance", () => {
      const provider = createCloudflareProvider(validConfig);

      expect(provider).toBeDefined();
      expect(provider).toBeInstanceOf(CloudflareSandboxProvider);
      expect(typeof provider.create).toBe("function");
      expect(typeof provider.resume).toBe("function");
    });

    it("should accept valid configuration", () => {
      const config = {
        env: mockEnv,
        hostname: "my-worker.custom-domain.workers.dev",
      };

      const provider = createCloudflareProvider(config);
      expect(provider).toBeDefined();
      expect(provider).toBeInstanceOf(CloudflareSandboxProvider);
    });

    it("should handle different hostname formats", () => {
      const configs = [
        { env: mockEnv, hostname: "worker.example.workers.dev" },
        { env: mockEnv, hostname: "custom-domain.com" },
        { env: mockEnv, hostname: "localhost" },
      ];

      for (const config of configs) {
        const provider = createCloudflareProvider(config);
        expect(provider).toBeDefined();
      }
    });
  });

  describe("Error Handling for Missing Bindings", () => {
    it("should throw error when Sandbox binding is missing", async () => {
      const invalidConfig = {
        env: {} as any, // No Sandbox binding
        hostname: "test-worker.workers.dev",
      };

      const provider = createCloudflareProvider(invalidConfig);

      await expect(provider.create()).rejects.toThrow(
        'Cloudflare Durable Object binding "Sandbox" not found'
      );
    });

    it("should throw error when env is null", async () => {
      const invalidConfig = {
        env: null as any,
        hostname: "test-worker.workers.dev",
      };

      const provider = createCloudflareProvider(invalidConfig);

      await expect(provider.create()).rejects.toThrow(
        'Cloudflare Durable Object binding "Sandbox" not found'
      );
    });

    it("should throw error when Sandbox binding is undefined", async () => {
      const invalidConfig = {
        env: { Sandbox: undefined },
        hostname: "test-worker.workers.dev",
      };

      const provider = createCloudflareProvider(invalidConfig);

      await expect(provider.create()).rejects.toThrow(
        'Cloudflare Durable Object binding "Sandbox" not found'
      );
    });
  });

  describe("Provider Interface Compliance", () => {
    it("should implement SandboxProvider interface", () => {
      const provider = createCloudflareProvider(validConfig);

      // Check required methods exist
      expect(typeof provider.create).toBe("function");
      expect(typeof provider.resume).toBe("function");
    });

    it("should return sandbox instances with correct interface", async () => {
      const provider = createCloudflareProvider(validConfig);

      const sandbox = await provider.create();

      expect(sandbox).toBeDefined();
      expect(sandbox.sandboxId).toBeDefined();
      expect(sandbox.sandboxId).toMatch(/^vibekit-default-/);

      // Check SandboxInstance interface compliance
      expect(typeof sandbox.commands.run).toBe("function");
      expect(typeof sandbox.kill).toBe("function");
      expect(typeof sandbox.pause).toBe("function");
      expect(typeof sandbox.getHost).toBe("function");
    });
  });

  describe("Sandbox ID Generation", () => {
    it("should generate unique sandbox IDs", async () => {
      const provider = createCloudflareProvider(validConfig);

      const sandbox1 = await provider.create();
      // Add small delay to ensure different timestamps
      await new Promise((resolve) => setTimeout(resolve, 1));
      const sandbox2 = await provider.create();

      expect(sandbox1.sandboxId).not.toBe(sandbox2.sandboxId);
      expect(sandbox1.sandboxId).toMatch(/^vibekit-default-/);
      expect(sandbox2.sandboxId).toMatch(/^vibekit-default-/);
    });

    it("should include agent type in sandbox ID", async () => {
      const provider = createCloudflareProvider(validConfig);

      const claudeSandbox = await provider.create({}, "claude");
      const codexSandbox = await provider.create({}, "codex");

      expect(claudeSandbox.sandboxId).toContain("claude");
      expect(codexSandbox.sandboxId).toContain("codex");
      expect(claudeSandbox.sandboxId).not.toBe(codexSandbox.sandboxId);
    });

    it("should use default agent type when none specified", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      expect(sandbox).toBeDefined();
      expect(sandbox.sandboxId).toMatch(/^vibekit-default-/);
    });

    it("should handle all supported agent types", async () => {
      const provider = createCloudflareProvider(validConfig);
      const agentTypes = ["claude", "codex", "opencode", "gemini"] as const;

      for (const agentType of agentTypes) {
        const sandbox = await provider.create({}, agentType);
        expect(sandbox).toBeDefined();
        expect(sandbox.sandboxId).toContain(agentType);
      }
    });
  });

  describe("Environment Variables and Configuration", () => {
    it("should handle environment variables parameter", async () => {
      const provider = createCloudflareProvider(validConfig);
      const envVars = {
        NODE_ENV: "test",
        API_KEY: "test-key",
        DEBUG: "true",
      };

      const sandbox = await provider.create(envVars);
      expect(sandbox).toBeDefined();
      expect(sandbox.sandboxId).toMatch(/^vibekit-default-/);
    });

    it("should handle working directory parameter", async () => {
      const provider = createCloudflareProvider(validConfig);
      const workingDir = "/app/workspace";

      const sandbox = await provider.create({}, "claude", workingDir);
      expect(sandbox).toBeDefined();
      expect(sandbox.sandboxId).toMatch(/^vibekit-claude-/);
    });

    it("should handle all optional parameters", async () => {
      const provider = createCloudflareProvider(validConfig);

      // Test with minimal parameters
      const sandbox1 = await provider.create();
      expect(sandbox1).toBeDefined();

      // Test with all parameters
      const sandbox2 = await provider.create(
        { NODE_ENV: "production" },
        "codex",
        "/custom/workdir"
      );
      expect(sandbox2).toBeDefined();
    });
  });

  describe("Command Execution Interface", () => {
    it("should provide command execution interface", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      expect(typeof sandbox.commands.run).toBe("function");

      // Test command execution
      const result = await sandbox.commands.run("echo hello");
      expect(result).toBeDefined();
      expect(typeof result.exitCode).toBe("number");
      expect(typeof result.stdout).toBe("string");
      expect(typeof result.stderr).toBe("string");
    });

    it("should handle foreground command execution", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      const result = await sandbox.commands.run("ls -la");
      expect(result.exitCode).toBe(0);
      expect(result.stdout).toBe("Mock command output");
      expect(result.stderr).toBe("");
    });

    it("should handle background command execution", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      const result = await sandbox.commands.run("node server.js", {
        background: true,
      });
      expect(result.exitCode).toBe(0);
      expect(result.stdout).toBe("Background command started successfully");
    });

    it("should handle command execution with streaming callbacks", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      const stdoutSpy = vi.fn();
      const stderrSpy = vi.fn();

      await sandbox.commands.run("npm test", {
        onStdout: stdoutSpy,
        onStderr: stderrSpy,
      });

      // Note: The actual callback execution depends on mock implementation timing
      expect(stdoutSpy).toBeDefined();
      expect(stderrSpy).toBeDefined();
    });

    it("should handle command execution errors", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      await expect(
        sandbox.commands.run("nonexistent-command-xyz")
      ).rejects.toThrow("Command not found: nonexistent-command-xyz");
    });

    it("should handle commands with non-zero exit codes", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      const result = await sandbox.commands.run("exit 42");
      expect(result.exitCode).toBe(42);
      expect(result.stderr).toBe("Process exited with code 42");
    });
  });

  describe("Port Exposure and Preview URLs", () => {
    it("should generate preview URLs for exposed ports", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      const url = await sandbox.getHost(3000);
      expect(url).toBe("https://3000-sandbox-mock.test-worker.example.workers.dev");
    });

    it("should handle different port numbers", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      const ports = [3000, 8080, 8000, 5000];
      for (const port of ports) {
        const url = await sandbox.getHost(port);
        expect(url).toContain(`${port}-sandbox-mock`);
        expect(url).toContain("test-worker.example.workers.dev");
      }
    });

    it("should use correct hostname in preview URLs", async () => {
      const customConfig = {
        env: mockEnv,
        hostname: "custom-worker.my-domain.workers.dev",
      };
      const provider = createCloudflareProvider(customConfig);
      const sandbox = await provider.create();

      const url = await sandbox.getHost(8080);
      expect(url).toBe("https://8080-sandbox-mock.custom-worker.my-domain.workers.dev");
    });
  });

  describe("Lifecycle Management", () => {
    it("should provide sandbox lifecycle methods", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      // Test lifecycle methods exist and can be called without throwing
      expect(typeof sandbox.kill).toBe("function");
      expect(typeof sandbox.pause).toBe("function");

      await sandbox.pause();
      await sandbox.kill();
    });

    it("should handle pause operation", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      // Should not throw
      await expect(sandbox.pause()).resolves.toBeUndefined();
    });

    it("should handle kill operation", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      // Should not throw
      await expect(sandbox.kill()).resolves.toBeUndefined();
    });
  });

  describe("Resume Functionality", () => {
    it("should handle resume operation", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandboxId = "existing-vibekit-claude-12345";

      const resumedSandbox = await provider.resume(sandboxId);
      expect(resumedSandbox).toBeDefined();
      expect(resumedSandbox.sandboxId).toBe(sandboxId);
    });

    it("should resume with proper interface", async () => {
      const provider = createCloudflareProvider(validConfig);
      const resumedSandbox = await provider.resume("test-sandbox-id");

      // Verify interface compliance
      expect(typeof resumedSandbox.commands.run).toBe("function");
      expect(typeof resumedSandbox.kill).toBe("function");
      expect(typeof resumedSandbox.pause).toBe("function");
      expect(typeof resumedSandbox.getHost).toBe("function");
    });

    it("should handle resume with different sandbox IDs", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandboxIds = [
        "vibekit-claude-123",
        "vibekit-codex-456",
        "vibekit-gemini-789",
      ];

      for (const sandboxId of sandboxIds) {
        const sandbox = await provider.resume(sandboxId);
        expect(sandbox.sandboxId).toBe(sandboxId);
      }
    });
  });

  describe("Configuration Edge Cases", () => {
    it("should handle empty hostname", () => {
      const config = {
        env: mockEnv,
        hostname: "",
      };

      const provider = createCloudflareProvider(config);
      expect(provider).toBeDefined();
    });

    it("should handle complex environment objects", async () => {
      const complexEnv = {
        Sandbox: mockEnv.Sandbox,
        SOME_OTHER_BINDING: {},
        KV_NAMESPACE: {},
        D1_DATABASE: {},
      };

      const config = {
        env: complexEnv,
        hostname: "complex-worker.workers.dev",
      };

      const provider = createCloudflareProvider(config);
      const sandbox = await provider.create();
      expect(sandbox).toBeDefined();
    });
  });

  describe("Interface Type Checking", () => {
    it("should satisfy SandboxProvider type requirements", async () => {
      const provider = createCloudflareProvider(validConfig);

      // These should compile without TypeScript errors
      const sandbox = await provider.create();
      const resumedSandbox = await provider.resume("test-id");

      expect(sandbox).toBeDefined();
      expect(resumedSandbox).toBeDefined();
    });

    it("should satisfy SandboxInstance type requirements", async () => {
      const provider = createCloudflareProvider(validConfig);
      const sandbox = await provider.create();

      // These should compile without TypeScript errors
      const result = await sandbox.commands.run("test");
      const host = await sandbox.getHost(3000);
      await sandbox.pause();
      await sandbox.kill();

      expect(result).toBeDefined();
      expect(host).toBeDefined();
    });
  });

  describe("Worker Environment Simulation", () => {
    it("should work with realistic Worker env object", async () => {
      const realisticEnv = {
        Sandbox: mockEnv.Sandbox,
        ANTHROPIC_API_KEY: "test-key",
        NODE_ENV: "production",
        // Other Worker bindings would be here
      };

      const config = {
        env: realisticEnv,
        hostname: "production-worker.company.workers.dev",
      };

      const provider = createCloudflareProvider(config);
      const sandbox = await provider.create(
        { CUSTOM_VAR: "value" },
        "claude",
        "/app"
      );

      expect(sandbox).toBeDefined();
      expect(sandbox.sandboxId).toContain("claude");
    });
  });
});


================================================
FILE: test/codex.test.ts
================================================
import { describe, it, expect, vi } from "vitest";
import { VibeKit } from "../packages/sdk/src/index.js";
import { createE2BProvider } from "../packages/e2b/src/index.js";
import { skipIfNoCodexKeys, skipTest } from "./helpers/test-utils.js";
import dotenv from "dotenv";

dotenv.config();

describe("Codex CLI", () => {
  it("should generate code with codex cli", async () => {
    if (skipIfNoCodexKeys()) {
      return skipTest();
    }

    const prompt = "Replace the README with the text 'HELLO WORLD'";

    const e2bProvider = createE2BProvider({
      apiKey: process.env.E2B_API_KEY!,
      templateId: "vibekit-codex",
    });

    const vibeKit = new VibeKit()
      .withAgent({
        type: "codex",
        provider: "openai",
        apiKey: process.env.OPENAI_API_KEY!,
        model: "codex-mini-latest",
      })
      .withGithub({
        token: process.env.GH_TOKEN || process.env.GITHUB_TOKEN!,
        repository: process.env.GH_REPOSITORY || "superagent-ai/signals",
      })
      .withSandbox(e2bProvider);

    const updateSpy = vi.fn();
    const errorSpy = vi.fn();

    vibeKit.on("update", updateSpy);
    vibeKit.on("error", errorSpy);

    const result = await vibeKit.generateCode({ prompt, mode: "ask" });
    const host = await vibeKit.getHost(3000);

    await vibeKit.kill();

    expect(result).toBeDefined();
    expect(host).toBeDefined();
    expect(updateSpy).toHaveBeenCalled();
    expect(errorSpy).not.toHaveBeenCalled();
  }, 600000);
});



================================================
FILE: test/dagger.test.ts
================================================
/**
 * Unit Tests for Local Dagger Sandbox Provider
 *
 * Fast unit tests that verify interface compliance, configuration handling,
 * and basic functionality using mocked dependencies. These tests should run
 * quickly without requiring Docker or external dependencies.
 */

import { describe, it, expect, beforeEach, vi } from "vitest";
import {
  createLocalProvider,
  LocalSandboxProvider,
} from "../packages/dagger/dist/index.js";

describe("Local Dagger Sandbox Provider - Unit Tests", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("Provider Creation", () => {
    it("should create a local dagger provider instance", () => {
      const provider = createLocalProvider({});

      expect(provider).toBeDefined();
      expect(provider).toBeInstanceOf(LocalSandboxProvider);
      expect(typeof provider.create).toBe("function");
      expect(typeof provider.resume).toBe("function");
    });

    it("should accept configuration options", () => {
      const config = {
        githubToken: "test-token",
        preferRegistryImages: true,
      };

      const provider = createLocalProvider(config);
      expect(provider).toBeDefined();
      expect(provider).toBeInstanceOf(LocalSandboxProvider);
    });

    it("should create provider with empty config", () => {
      const provider = createLocalProvider();
      expect(provider).toBeDefined();
      expect(provider).toBeInstanceOf(LocalSandboxProvider);
    });
  });

  describe("Provider Interface Compliance", () => {
    it("should implement SandboxProvider interface", () => {
      const provider = createLocalProvider({});

      // Check required methods exist
      expect(typeof provider.create).toBe("function");
      expect(typeof provider.resume).toBe("function");
    });

    it("should return sandbox instances with correct interface", async () => {
      const provider = createLocalProvider({});

      // Note: This test uses mocked Dagger calls from test/setup.ts
      const sandbox = await provider.create();

      expect(sandbox).toBeDefined();
      expect(sandbox.sandboxId).toBeDefined();
      expect(sandbox.sandboxId).toMatch(/^dagger-/);

      // Check SandboxInstance interface compliance
      expect(typeof sandbox.commands.run).toBe("function");
      expect(typeof sandbox.kill).toBe("function");
      expect(typeof sandbox.pause).toBe("function");
      expect(typeof sandbox.getHost).toBe("function");
      expect(typeof sandbox.on).toBe("function");
      expect(typeof sandbox.emit).toBe("function");
    });
  });

  describe("Configuration Validation", () => {
    it("should handle agent type configuration", async () => {
      const provider = createLocalProvider({});

      const agentTypes = ["claude", "codex", "opencode", "gemini"] as const;

      for (const agentType of agentTypes) {
        const sandbox = await provider.create({}, agentType);
        expect(sandbox).toBeDefined();
        expect(sandbox.sandboxId).toContain(agentType);
      }
    });

    it("should handle environment variables parameter", async () => {
      const provider = createLocalProvider({});
      const envVars = {
        TEST_VAR: "test-value",
        NODE_ENV: "test",
      };

      const sandbox = await provider.create(envVars);
      expect(sandbox).toBeDefined();
      expect(sandbox.sandboxId).toMatch(/^dagger-/);
    });

    it("should handle working directory parameter", async () => {
      const provider = createLocalProvider({});
      const workingDir = "/custom/work/dir";

      const sandbox = await provider.create({}, "claude", workingDir);
      expect(sandbox).toBeDefined();
      expect(sandbox.sandboxId).toMatch(/^dagger-claude-/);
    });

    it("should handle optional parameters", async () => {
      const provider = createLocalProvider({});

      // Test with minimal parameters
      const sandbox1 = await provider.create();
      expect(sandbox1).toBeDefined();

      // Test with all parameters
      const sandbox2 = await provider.create(
        { NODE_ENV: "test" },
        "codex",
        "/workdir"
      );
      expect(sandbox2).toBeDefined();
    });
  });

  describe("Sandbox ID Generation", () => {
    it("should generate unique sandbox IDs", async () => {
      const provider = createLocalProvider({});

      const sandbox1 = await provider.create();
      // Add small delay to ensure different timestamps
      await new Promise((resolve) => setTimeout(resolve, 1));
      const sandbox2 = await provider.create();

      expect(sandbox1.sandboxId).not.toBe(sandbox2.sandboxId);
      expect(sandbox1.sandboxId).toMatch(/^dagger-default-/);
      expect(sandbox2.sandboxId).toMatch(/^dagger-default-/);
    });

    it("should include agent type in sandbox ID", async () => {
      const provider = createLocalProvider({});

      const claudeSandbox = await provider.create({}, "claude");
      const codexSandbox = await provider.create({}, "codex");

      expect(claudeSandbox.sandboxId).toContain("claude");
      expect(codexSandbox.sandboxId).toContain("codex");
      expect(claudeSandbox.sandboxId).not.toBe(codexSandbox.sandboxId);
    });

    it("should use default agent type when none specified", async () => {
      const provider = createLocalProvider({});
      const sandbox = await provider.create();

      expect(sandbox).toBeDefined();
      expect(sandbox.sandboxId).toMatch(/^dagger-default-/);
    });
  });

  describe("Lifecycle Management Interface", () => {
    it("should provide sandbox lifecycle methods", async () => {
      const provider = createLocalProvider({});
      const sandbox = await provider.create();

      // Test lifecycle methods exist and can be called without throwing
      expect(typeof sandbox.kill).toBe("function");
      expect(typeof sandbox.pause).toBe("function");

      await sandbox.pause();
      await sandbox.kill();
    });

    it("should provide port mapping functionality", async () => {
      const provider = createLocalProvider({});
      const sandbox = await provider.create();

      expect(typeof sandbox.getHost).toBe("function");
      const host = await sandbox.getHost(3000);
      expect(typeof host).toBe("string");
      expect(host).toBe("localhost"); // Mocked response
    });
  });

  describe("Event Emitter Interface", () => {
    it("should implement EventEmitter interface", async () => {
      const provider = createLocalProvider({});
      const sandbox = await provider.create();

      expect(typeof sandbox.on).toBe("function");
      expect(typeof sandbox.emit).toBe("function");

      // Test event handling
      const listener = vi.fn();
      sandbox.on("test-event", listener);

      const emitted = sandbox.emit("test-event", "test-data");
      expect(emitted).toBe(true);
      expect(listener).toHaveBeenCalledWith("test-data");
    });

    it("should support multiple event listeners", async () => {
      const provider = createLocalProvider({});
      const sandbox = await provider.create();

      const listener1 = vi.fn();
      const listener2 = vi.fn();

      sandbox.on("multi-event", listener1);
      sandbox.on("multi-event", listener2);

      sandbox.emit("multi-event", "data");

      expect(listener1).toHaveBeenCalledWith("data");
      expect(listener2).toHaveBeenCalledWith("data");
    });
  });

  describe("Resume Functionality", () => {
    it("should handle resume operation", async () => {
      const provider = createLocalProvider({});
      const sandboxId = "test-sandbox-id";

      // Resume should work (currently returns a new instance with mocked implementation)
      const resumedSandbox = await provider.resume(sandboxId);
      expect(resumedSandbox).toBeDefined();
      expect(resumedSandbox.sandboxId).toBeDefined();
    });

    it("should resume with proper interface", async () => {
      const provider = createLocalProvider({});
      const resumedSandbox = await provider.resume("test-id");

      // Verify interface compliance
      expect(typeof resumedSandbox.commands.run).toBe("function");
      expect(typeof resumedSandbox.kill).toBe("function");
      expect(typeof resumedSandbox.pause).toBe("function");
      expect(typeof resumedSandbox.getHost).toBe("function");
    });
  });

  describe("Error Handling with Mocks", () => {
    it("should handle provider creation with invalid config gracefully", () => {
      // Provider should still be created even with potentially invalid config
      // since validation happens during sandbox creation
      const provider = createLocalProvider({ invalidOption: "invalid" } as any);
      expect(provider).toBeDefined();
    });

    it("should handle sandbox creation with invalid parameters", async () => {
      const provider = createLocalProvider({});

      // Should not throw with unusual but not invalid parameters
      const sandbox = await provider.create(
        { WEIRD_VAR: "" },
        "claude" as any,
        ""
      );
      expect(sandbox).toBeDefined();
    });
  });
});



================================================
FILE: test/daytona.test.ts
================================================
import { describe, it, expect, vi } from "vitest";
import { VibeKit } from "../packages/sdk/src/index.js";
import { createDaytonaProvider } from "../packages/daytona/dist/index.js";
import { skipIfNoDaytonaKeys, skipTest } from "./helpers/test-utils.js";
import dotenv from "dotenv";

dotenv.config();

describe("Daytona Sandbox", () => {
  it("should generate code with daytona sandbox", async () => {
    if (skipIfNoDaytonaKeys()) {
      return skipTest();
    }

    const prompt = "Hi there";

    const daytonaProvider = createDaytonaProvider({
      apiUrl: process.env.DAYTONA_SERVER_URL!,
      apiKey: process.env.DAYTONA_SERVER_API_KEY!,
      targetId: process.env.DAYTONA_TARGET_ID!,
    });

    const vibeKit = new VibeKit()
      .withAgent({
        type: "claude",
        provider: "anthropic",
        apiKey: process.env.ANTHROPIC_API_KEY!,
        model: "claude-sonnet-4-20250514",
      })
      .withSandbox(daytonaProvider);

    const updateSpy = vi.fn();
    const errorSpy = vi.fn();

    vibeKit.on("update", updateSpy);
    vibeKit.on("error", errorSpy);

    const result = await vibeKit.generateCode({ prompt, mode: "ask" });
    const host = await vibeKit.getHost(3000);

    await vibeKit.kill();

    expect(result).toBeDefined();
    expect(host).toBeDefined();
    expect(updateSpy).toHaveBeenCalled();
    expect(errorSpy).not.toHaveBeenCalled();
  }, 60000);
});



================================================
FILE: test/gemini.test.ts
================================================
import { describe, it, expect, vi } from "vitest";
import { VibeKit } from "../packages/sdk/src/index.js";
import { createE2BProvider } from "../packages/e2b/dist/index.js";
import { skipIfNoGeminiKeys, skipTest } from "./helpers/test-utils.js";
import dotenv from "dotenv";

dotenv.config();

describe("Gemini CLI", () => {
  it("should generate code with gemini cli", async () => {
    if (skipIfNoGeminiKeys()) {
      skipTest();
      return;
    }

    const prompt = "Hi there";

    console.log("Creating E2B provider...");
    const e2bProvider = createE2BProvider({
      apiKey: process.env.E2B_API_KEY!,
      templateId: "vibekit-gemini",
    });

    console.log("Creating VibeKit instance...");
    const vibeKit = new VibeKit()
      .withAgent({
        type: "gemini",
        provider: "google",
        apiKey: process.env.GEMINI_API_KEY!,
        model: "gemini-2.5-pro",
      })
      .withSandbox(e2bProvider);

    const updateSpy = vi.fn();
    const errorSpy = vi.fn();

    vibeKit.on("update", updateSpy);
    vibeKit.on("error", errorSpy);

    console.log("Starting code generation...");
    const result = await vibeKit.generateCode({ prompt, mode: "ask" });
    console.log("Code generation completed, getting host...");
    const host = await vibeKit.getHost(3000);

    console.log("Killing vibekit...");
    await vibeKit.kill();

    expect(result).toBeDefined();
    expect(host).toBeDefined();
    expect(updateSpy).toHaveBeenCalled();
    expect(errorSpy).not.toHaveBeenCalled();
  }, 120000);
});



================================================
FILE: test/grok.test.ts
================================================
import { describe, it, expect, vi } from "vitest";
import { VibeKit } from "../packages/sdk/src/index.js";
import { createE2BProvider } from "../packages/e2b/dist/index.js";
import { skipIfNoGrokKeys, skipTest } from "./helpers/test-utils.js";
import dotenv from "dotenv";

dotenv.config();

describe("Grok CLI", () => {
  it("should generate code with grok cli", async () => {
    if (skipIfNoGrokKeys()) {
      return skipTest();
    }

    const prompt = "Hi there";

    const e2bProvider = createE2BProvider({
      apiKey: process.env.E2B_API_KEY!,
      templateId: "vibekit-grok",
    });

    const vibeKit = new VibeKit()
      .withAgent({
        type: "grok",
        provider: "xai",
        apiKey: process.env.GROK_API_KEY!,
        model: "grok-beta",
      })
      .withSandbox(e2bProvider);

    const updateSpy = vi.fn();
    const errorSpy = vi.fn();

    vibeKit.on("update", updateSpy);
    vibeKit.on("error", errorSpy);

    const result = await vibeKit.generateCode({ prompt, mode: "ask" });
    const host = await vibeKit.getHost(3000);

    await vibeKit.kill();

    expect(result).toBeDefined();
    expect(host).toBeDefined();
    expect(updateSpy).toHaveBeenCalled();
    expect(errorSpy).not.toHaveBeenCalled();
  }, 60000);
});



================================================
FILE: test/opencode.test.ts
================================================
import { describe, it, expect, vi } from "vitest";
import { VibeKit } from "../packages/sdk/src/index.js";
import { createE2BProvider } from "../packages/e2b/dist/index.js";
import { skipIfNoOpenCodeKeys, skipTest } from "./helpers/test-utils.js";
import dotenv from "dotenv";

dotenv.config();

describe("Opencode CLI", () => {
  it("should generate code with opencode cli", async () => {
    if (skipIfNoOpenCodeKeys()) {
      return skipTest();
    }

    const prompt = "Hi there";

    const e2bProvider = createE2BProvider({
      apiKey: process.env.E2B_API_KEY!,
      templateId: "vibekit-opencode",
    });

    const vibeKit = new VibeKit()
      .withAgent({
        type: "opencode",
        provider: "anthropic",
        apiKey: process.env.ANTHROPIC_API_KEY!,
        model: "claude-sonnet-4-20250514",
      })
      .withSandbox(e2bProvider);

    const updateSpy = vi.fn();
    const errorSpy = vi.fn();

    vibeKit.on("update", updateSpy);
    vibeKit.on("error", errorSpy);

    const result = await vibeKit.generateCode({ prompt, mode: "ask" });
    const host = await vibeKit.getHost(3000);

    await vibeKit.kill();

    expect(result).toBeDefined();
    expect(host).toBeDefined();
    expect(updateSpy).toHaveBeenCalled();
    expect(errorSpy).not.toHaveBeenCalled();
  }, 60000);
});



================================================
FILE: test/setup.ts
================================================
import dotenv from "dotenv";
import { resolve } from "path";
import { vi } from "vitest";

dotenv.config({ path: resolve(process.cwd(), ".env") });

// Create mock factory functions to be used by vi.mock
const createDaggerMock = () => {
  // Mock container interface with realistic behavior
  const mockContainer = {
    from: vi.fn().mockReturnThis(),
    withEnvVariable: vi.fn().mockReturnThis(),
    withWorkdir: vi.fn().mockReturnThis(),
    withDirectory: vi.fn().mockReturnThis(),
    withExec: vi.fn().mockImplementation(function(this: any, command: string[]) {
      // Check if this is a command that should fail for error testing
      const fullCommand = Array.isArray(command) ? command.join(' ') : String(command);

      if (fullCommand.includes('nonexistent-command-xyz')) {
        // Mock container that will throw on stdout/stderr
        return {
          ...this,
          stdout: vi.fn().mockRejectedValue(new Error('resolve: process "sh -c nonexistent-command-xyz" did not complete successfully: exit code: 127')),
          stderr: vi.fn().mockResolvedValue('command not found: nonexistent-command-xyz'),
        };
      } else if (fullCommand.includes('exit 42')) {
        // Mock container that will throw on stdout/stderr with specific exit code
        return {
          ...this,
          stdout: vi.fn().mockRejectedValue(new Error('resolve: process "sh -c exit 42" did not complete successfully: exit code: 42')),
          stderr: vi.fn().mockResolvedValue(''),
        };
      }

      return this;
    }),
    withNewFile: vi.fn().mockReturnThis(),
    build: vi.fn().mockReturnThis(),
    export: vi.fn().mockResolvedValue(undefined),
    stdout: vi.fn().mockResolvedValue("Mock command output"),
    stderr: vi.fn().mockResolvedValue(""),
    directory: vi.fn().mockReturnValue({
      // Mock directory object for workspace persistence
      entries: vi.fn().mockResolvedValue([]),
    }),
    file: vi.fn().mockReturnValue({
      contents: vi.fn().mockResolvedValue("Mock file content"),
    }),
  };

  // Mock client interface
  const mockClient = {
    container: vi.fn().mockReturnValue(mockContainer),
    host: vi.fn().mockReturnValue({
      directory: vi.fn().mockReturnValue(mockContainer),
    }),
  };

  // Mock connect function - this is the main entry point that triggers CLI download
  const mockConnect = vi.fn().mockImplementation(async (callback: (client: any) => Promise<any>) => {
    // Call the callback with our mock client
    return await callback(mockClient);
  });

  return {
    connect: mockConnect,
    // Export mock types for TypeScript compatibility
    Client: vi.fn(),
    Container: vi.fn(),
    Directory: vi.fn(),
  };
};

// Mock the Dagger module entirely
vi.mock("@dagger.io/dagger", () => createDaggerMock());

// Mock exec functionality for Docker commands used in prebuildAgentImages
vi.mock("child_process", async () => {
  const actual = await vi.importActual("child_process");
  return {
    ...actual,
    exec: vi.fn((command, options, callback) => {
      // Mock different responses based on command
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      let stdout = "";
      let stderr = "";

      if (command.includes("docker images")) {
        // Mock existing images to simulate cached state
        stdout = "abc123def456"; // Mock image ID
      } else if (command.includes("docker pull")) {
        // Mock successful pulls
        stdout = "Pull complete";
      } else if (command.includes("docker info")) {
        stdout = "Docker info output";
      }

      // Simulate async execution
      setTimeout(() => {
        if (callback) {
          callback(null, { stdout, stderr });
        }
      }, 0);
    }),
  };
});

// Mock filesystem operations
vi.mock("fs/promises", () => ({
  readFile: vi.fn().mockResolvedValue("{}"),
  writeFile: vi.fn().mockResolvedValue(undefined),
}));

vi.mock("fs", () => ({
  existsSync: vi.fn().mockReturnValue(true),
}));

// Mock util.promisify for exec operations
vi.mock("util", async () => {
  const actual = await vi.importActual("util") as any;
  return {
    ...actual,
    promisify: vi.fn((fn) => {
      if (fn.name === 'exec') {
        return vi.fn().mockResolvedValue({ stdout: '', stderr: '' });
      }
      return actual.promisify(fn);
    }),
  };
});

// Create mock factory functions for Cloudflare Sandbox
const createCloudflareSandboxMock = () => {
  // Mock SSE log events for background processes
  const mockLogEvents = [
    { type: 'stdout', data: 'Command output line 1' },
    { type: 'stdout', data: 'Command output line 2' },
    { type: 'exit', code: 0 }
  ];

  // Mock SSE stream parser
  const mockParseSSEStream = vi.fn().mockImplementation(async function* (stream: any) {
    // Simulate streaming log events
    for (const event of mockLogEvents) {
      yield event;
    }
  });

  // Mock sandbox instance with realistic behavior
  const mockSandbox = {
    // Foreground command execution
    exec: vi.fn().mockImplementation(async (command: string, options?: any) => {
      // Check for error-inducing commands
      if (command.includes('nonexistent-command-xyz')) {
        throw new Error('Command not found: nonexistent-command-xyz');
      } else if (command.includes('exit 42')) {
        return {
          exitCode: 42,
          stdout: '',
          stderr: 'Process exited with code 42'
        };
      }

      // Handle streaming output
      if (options?.stream && options.onOutput) {
        // Simulate streaming output
        setTimeout(() => {
          options.onOutput('stdout', 'Mock command output line 1\n');
          options.onOutput('stdout', 'Mock command output line 2\n');
        }, 0);
      }

      return {
        exitCode: 0,
        stdout: 'Mock command output',
        stderr: ''
      };
    }),

    // Background process management
    startProcess: vi.fn().mockResolvedValue({
      id: 'mock-process-id-123'
    }),

    streamProcessLogs: vi.fn().mockImplementation(async (processId: string) => {
      // Return a mock stream that parseSSEStream can consume
      return {
        [Symbol.asyncIterator]: async function* () {
          for (const event of mockLogEvents) {
            yield JSON.stringify(event);
          }
        }
      };
    }),

    killProcess: vi.fn().mockResolvedValue(undefined),

    // Port exposure for preview URLs
    exposePort: vi.fn().mockImplementation(async (port: number, options?: any) => {
      const hostname = options?.hostname || 'localhost';
      return {
        url: `https://${port}-sandbox-mock.${hostname}`
      };
    }),

    // Environment and configuration
    setEnvVars: vi.fn().mockResolvedValue(undefined),

    // Lifecycle management
    destroy: vi.fn().mockResolvedValue(undefined),
    stop: vi.fn().mockResolvedValue(undefined)
  };

  // Mock getSandbox function
  const mockGetSandbox = vi.fn().mockImplementation((namespace: any, sandboxId: string) => {
    return mockSandbox;
  });

  return {
    getSandbox: mockGetSandbox,
    parseSSEStream: mockParseSSEStream,
    // Export mock types for TypeScript compatibility
    Sandbox: vi.fn(),
    LogEvent: vi.fn(),
  };
};

// Mock the @cloudflare/sandbox module entirely
vi.mock("@cloudflare/sandbox", () => createCloudflareSandboxMock());



================================================
FILE: test/vibekit-core.test.ts
================================================
/**
 * Unit Tests for VibeKit Core SDK
 * 
 * Tests core SDK functionality, configuration, and interface compliance
 * without requiring external API calls or real sandbox providers.
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { VibeKit } from '../packages/sdk/src/index.js';

// Mock provider for testing
const createMockProvider = () => ({
  create: vi.fn().mockResolvedValue({
    sandboxId: 'mock-sandbox-123',
    commands: {
      run: vi.fn().mockResolvedValue({
        exitCode: 0,
        stdout: 'Mock command output',
        stderr: ''
      })
    },
    kill: vi.fn().mockResolvedValue(undefined),
    pause: vi.fn().mockResolvedValue(undefined),
    getHost: vi.fn().mockResolvedValue('localhost:3000'),
    on: vi.fn(),
    emit: vi.fn()
  }),
  resume: vi.fn().mockResolvedValue({
    sandboxId: 'mock-sandbox-123',
    commands: { run: vi.fn() },
    kill: vi.fn(),
    pause: vi.fn(),
    getHost: vi.fn(),
    on: vi.fn(),
    emit: vi.fn()
  })
});

describe('VibeKit Core SDK - Unit Tests', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('SDK Initialization', () => {
    it('should create VibeKit instance', () => {
      const vibeKit = new VibeKit();
      expect(vibeKit).toBeDefined();
      expect(vibeKit).toBeInstanceOf(VibeKit);
    });

    it('should provide fluent configuration API', () => {
      const mockProvider = createMockProvider();
      
      const vibeKit = new VibeKit()
        .withAgent({
          type: 'claude',
          provider: 'anthropic',
          apiKey: 'test-key',
          model: 'claude-sonnet-4-20250514'
        })
        .withSandbox(mockProvider)
        .withWorkingDirectory('/test/dir');

      expect(vibeKit).toBeDefined();
      expect(vibeKit).toBeInstanceOf(VibeKit);
    });
  });

  describe('Configuration Methods', () => {
    it('should configure agent settings', () => {
      const vibeKit = new VibeKit();
      
      const configured = vibeKit.withAgent({
        type: 'claude',
        provider: 'anthropic',
        apiKey: 'test-api-key',
        model: 'claude-sonnet-4-20250514'
      });

      expect(configured).toBe(vibeKit); // Should return same instance for chaining
    });

    it('should configure sandbox provider', () => {
      const vibeKit = new VibeKit();
      const mockProvider = createMockProvider();
      
      const configured = vibeKit.withSandbox(mockProvider);
      
      expect(configured).toBe(vibeKit); // Should return same instance for chaining
    });

    it('should configure working directory', () => {
      const vibeKit = new VibeKit();
      const testDir = '/var/test-workspace';
      
      const configured = vibeKit.withWorkingDirectory(testDir);
      
      expect(configured).toBe(vibeKit); // Should return same instance for chaining
    });

    it('should support method chaining', () => {
      const mockProvider = createMockProvider();
      
      const vibeKit = new VibeKit()
        .withAgent({
          type: 'claude',
          provider: 'anthropic',
          apiKey: 'test-key',
          model: 'claude-sonnet-4-20250514'
        })
        .withSandbox(mockProvider)
        .withWorkingDirectory('/test/dir');

      expect(vibeKit).toBeInstanceOf(VibeKit);
    });
  });

  describe('Agent Configuration Validation', () => {
    it('should accept valid agent types', () => {
      const vibeKit = new VibeKit();
      const agentTypes = ['claude', 'codex', 'opencode', 'gemini'] as const;
      
      agentTypes.forEach(type => {
        expect(() => {
          vibeKit.withAgent({
            type,
            provider: 'anthropic',
            apiKey: 'test-key',
            model: 'test-model'
          });
        }).not.toThrow();
      });
    });

    it('should accept provider configurations', () => {
      const vibeKit = new VibeKit();
      const providers = ['anthropic', 'openai'] as const;
      
      providers.forEach(provider => {
        expect(() => {
          vibeKit.withAgent({
            type: 'claude',
            provider,
            apiKey: 'test-key',
            model: 'test-model'
          });
        }).not.toThrow();
      });
    });
  });

  describe('Event Emitter Interface', () => {
    it('should implement EventEmitter methods', () => {
      const vibeKit = new VibeKit();
      
      expect(typeof vibeKit.on).toBe('function');
      expect(typeof vibeKit.emit).toBe('function');
      expect(typeof vibeKit.removeListener).toBe('function');
    });

    it('should handle event registration and emission', () => {
      const vibeKit = new VibeKit();
      const listener = vi.fn();
      
      vibeKit.on('test-event', listener);
      vibeKit.emit('test-event', 'test-data');
      
      expect(listener).toHaveBeenCalledWith('test-data');
    });
  });

  describe('Command Execution Interface', () => {
    it('should provide executeCommand method', async () => {
      const vibeKit = new VibeKit();
      const mockProvider = createMockProvider();
      
      vibeKit.withSandbox(mockProvider);
      
      expect(typeof vibeKit.executeCommand).toBe('function');
    });

    it('should provide generateCode method', async () => {
      const vibeKit = new VibeKit();
      const mockProvider = createMockProvider();
      
      vibeKit
        .withAgent({
          type: 'claude',
          provider: 'anthropic',
          apiKey: 'test-key',
          model: 'claude-sonnet-4-20250514'
        })
        .withSandbox(mockProvider);
      
      expect(typeof vibeKit.generateCode).toBe('function');
    });
  });

  describe('Lifecycle Management', () => {
    it('should provide lifecycle methods', () => {
      const vibeKit = new VibeKit();
      
      expect(typeof vibeKit.kill).toBe('function');
      expect(typeof vibeKit.getHost).toBe('function');
    });

    it('should handle kill operation', async () => {
      const vibeKit = new VibeKit();
      const mockProvider = createMockProvider();
      
      vibeKit.withSandbox(mockProvider);
      
      // Should not throw
      await expect(vibeKit.kill()).resolves.not.toThrow();
    });
  });

  describe('Error Handling', () => {
    it('should handle missing configuration gracefully', () => {
      const vibeKit = new VibeKit();
      
      // Should not throw during construction
      expect(vibeKit).toBeDefined();
    });

    it('should validate required configuration before operations', async () => {
      const vibeKit = new VibeKit();
      
      // Should handle missing sandbox provider gracefully
      // (Actual behavior depends on implementation)
      expect(vibeKit).toBeDefined();
    });
  });

  describe('Working Directory Configuration', () => {
    it('should accept various directory formats', () => {
      const vibeKit = new VibeKit();
      const directories = [
        '/var/workspace',
        '/tmp/test',
        '/home/user/project',
        './relative/path'
      ];
      
      directories.forEach(dir => {
        expect(() => {
          vibeKit.withWorkingDirectory(dir);
        }).not.toThrow();
      });
    });
  });

  describe('Type Safety', () => {
    it('should maintain type safety in configuration', () => {
      const vibeKit = new VibeKit();
      const mockProvider = createMockProvider();
      
      // This should compile without TypeScript errors
      const configured = vibeKit
        .withAgent({
          type: 'claude',
          provider: 'anthropic',
          apiKey: 'test-key',
          model: 'claude-sonnet-4-20250514'
        })
        .withSandbox(mockProvider)
        .withWorkingDirectory('/test');

      expect(configured).toBeInstanceOf(VibeKit);
    });
  });
}); 


================================================
FILE: test/vibekit.test.ts
================================================
import { describe, it, expect, vi } from "vitest";
import dotenv from "dotenv";

import { VibeKit } from "../packages/sdk/src/index.js";
import { createE2BProvider } from "../packages/e2b/dist/index.js";
import { skipIfNoVibeKitKeys, skipTest } from "./helpers/test-utils.js";

// Type imports to verify they are properly exported
import type {
  AgentMode,
  ModelProvider,
  Conversation,
  PullRequestResult,
  AgentResponse,
  ExecuteCommandOptions,
} from "../packages/sdk/src/index.js";

dotenv.config();

describe("VibeKit SDK", () => {
  it("should have all types properly exported", () => {
    // Type checking test - these will fail at compile time if types are not exported
    // We're just verifying the types can be used, not testing runtime behavior
    type TestAgentMode = AgentMode;
    type TestProvider = ModelProvider;
    type TestConversation = Conversation;
    type TestAgentResponse = AgentResponse;
    type TestExecuteOptions = ExecuteCommandOptions;
    type TestPrResult = PullRequestResult;
    
    // Example usage to verify types work correctly
    const agentMode: TestAgentMode = "code";
    const provider: TestProvider = "anthropic";
    
    // If this test compiles and runs, all types are properly exported
    expect(agentMode).toBe("code");
    expect(provider).toBe("anthropic");
  });

  it("should create working directory", async () => {
    if (skipIfNoVibeKitKeys()) {
      return skipTest();
    }

    const dir = "/var/vibe0";

    const e2bProvider = createE2BProvider({
      apiKey: process.env.E2B_API_KEY!,
      templateId: "vibekit-claude",
    });

    const vibeKit = new VibeKit()
      .withAgent({
        type: "claude",
        provider: "anthropic",
        apiKey: process.env.ANTHROPIC_API_KEY!,
        model: "claude-sonnet-4-20250514",
      })
      .withSandbox(e2bProvider)
      .withWorkingDirectory(dir);

    const result = await vibeKit.executeCommand("pwd");

    const pwd = result.stdout.trim();

    await vibeKit.kill();

    expect(pwd).toBe(dir);
  }, 60000);

  it("should download repository", async () => {
    if (skipIfNoVibeKitKeys()) {
      return skipTest();
    }

    const dir = "/var/vibe0";

    const e2bProvider = createE2BProvider({
      apiKey: process.env.E2B_API_KEY!,
      templateId: "vibekit-claude",
    });

    const vibeKit = new VibeKit()
      .withAgent({
        type: "claude",
        provider: "anthropic",
        apiKey: process.env.ANTHROPIC_API_KEY!,
        model: "claude-sonnet-4-20250514",
      })
      .withSandbox(e2bProvider)
      .withGithub({
        token: process.env.GH_TOKEN || process.env.GITHUB_TOKEN!,
        repository: process.env.GH_REPOSITORY || "superagent-ai/signals",
      })
      .withWorkingDirectory(dir);

    let gitUpdateReceived = false;

    vibeKit.on("update", (data) => {
      try {
        const parsedData = JSON.parse(data);
        if (
          parsedData.type === "git" &&
          parsedData.output === "Cloning repository: superagent-ai/signals"
        ) {
          gitUpdateReceived = true;
        }
      } catch {}
    });

    await vibeKit.generateCode({ prompt: "Hi there" });

    await vibeKit.kill();

    expect(gitUpdateReceived).toBe(true);
  }, 60000);
  it("should set env variables", async () => {
    if (skipIfNoVibeKitKeys()) {
      return skipTest();
    }

    const e2bProvider = createE2BProvider({
      apiKey: process.env.E2B_API_KEY!,
      templateId: "vibekit-claude",
    });

    const vibeKit = new VibeKit()
      .withAgent({
        type: "claude",
        provider: "anthropic",
        apiKey: process.env.ANTHROPIC_API_KEY!,
        model: "claude-sonnet-4-20250514",
      })
      .withSandbox(e2bProvider)
      .withGithub({
        token: process.env.GH_TOKEN || process.env.GITHUB_TOKEN!,
        repository: process.env.GH_REPOSITORY || "superagent-ai/signals",
      })
      .withSecrets({ MY_SECRET: "test" });

    const output = await vibeKit.executeCommand("echo $MY_SECRET");
    const secret = output.stdout.trim();

    expect(secret).toBe("test");
  }, 60000);
});



================================================
FILE: test/helpers/test-utils.ts
================================================
import { expect } from "vitest";

// Helper to check if required API keys are missing
export const skipIfNoAPIKeys = (requiredKeys: string[] = ['E2B_API_KEY']) => {
  const missingKeys = requiredKeys.filter(key => !process.env[key]);
  
  if (missingKeys.length > 0) {
    console.log(`Skipping test - Missing API keys: ${missingKeys.join(', ')}`);
    return true;
  }
  
  return false;
};

// Helper to create a mock test that passes when skipped
export const skipTest = () => {
  expect(true).toBe(true);
  return;
};

// Agent-specific skip helpers
export const skipIfNoClaudeKeys = () => skipIfNoAPIKeys(['E2B_API_KEY', 'ANTHROPIC_API_KEY']);
export const skipIfNoCodexKeys = () => skipIfNoAPIKeys(['E2B_API_KEY', 'OPENAI_API_KEY']);
export const skipIfNoGeminiKeys = () => skipIfNoAPIKeys(['E2B_API_KEY', 'GEMINI_API_KEY']);
export const skipIfNoGrokKeys = () => skipIfNoAPIKeys(['E2B_API_KEY', 'GROK_API_KEY']);
export const skipIfNoOpenCodeKeys = () => skipIfNoAPIKeys(['E2B_API_KEY', 'ANTHROPIC_API_KEY']);
export const skipIfNoDaytonaKeys = () => skipIfNoAPIKeys(['DAYTONA_SERVER_URL', 'DAYTONA_SERVER_API_KEY', 'DAYTONA_TARGET_ID', 'ANTHROPIC_API_KEY']);
export const skipIfNoVibeKitKeys = () => skipIfNoAPIKeys(['E2B_API_KEY', 'ANTHROPIC_API_KEY', 'GH_TOKEN']);

// Skip integration tests in CI unless explicitly enabled
export const skipIntegrationTest = () => {
  const isCI = process.env.CI;
  const runIntegration = process.env.RUN_INTEGRATION_TESTS;
  
  if (isCI && !runIntegration) {
    console.log('Skipping integration test in CI - Set RUN_INTEGRATION_TESTS=true to run');
    return true;
  }
  
  return false;
};



================================================
FILE: .github/PULL_REQUEST_TEMPLATE.md
================================================
## Description
<!-- A brief summary of the changes in this pull request. -->

## Related Issue
Fixes #<issue number>

## Checklist
- [ ] I tested my changes
- [ ] I reviewed my own code


================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.yml
================================================
name: Bug Report
description: File a bug report
title: "[Bug]: "
labels: ["bug"]
body:
  - type: textarea
    id: description
    attributes:
      label: Bug Description
      description: Describe what happened and what you expected
      placeholder: What went wrong?
    validations:
      required: true

  - type: textarea
    id: steps
    attributes:
      label: Steps to reproduce
      placeholder: |
        1. 
        2. 
        3. 
    validations:
      required: false


================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.yml
================================================
name: Feature Request
description: Suggest an idea for this project
title: "[Feature]: "
labels: ["enhancement"]
body:
  - type: textarea
    id: description
    attributes:
      label: Feature Description
      description: What feature would you like to see?
      placeholder: Describe the feature you'd like
    validations:
      required: true


================================================
FILE: .github/workflows/ci.yml
================================================
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  lint:
    name: Type Checking
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm install -g npm@latest
      - run: npm ci
      - run: npm run type-check

  test:
    name: Test
    runs-on: ubuntu-latest
    needs: lint
    env:
      E2B_API_KEY: ${{ secrets.E2B_API_KEY }}
      DAYTONA_API_KEY: ${{ secrets.DAYTONA_API_KEY }}
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      GROK_API_KEY: ${{ secrets.GROK_API_KEY }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}
      GH_REPOSITORY: ${{ secrets.GH_REPOSITORY }}
      WORKING_DIRECTORY: ${{ secrets.WORKING_DIRECTORY }}
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm install -g npm@latest
      - run: npm ci
      - run: npm run build
      - run: npm test -- --coverage


================================================
FILE: .github/workflows/claude-code-review.yml
================================================
name: Claude Code Review

on:
  pull_request:
    types: [opened, synchronize]
    # Optional: Only run on specific file changes
    # paths:
    #   - "src/**/*.ts"
    #   - "src/**/*.tsx"
    #   - "src/**/*.js"
    #   - "src/**/*.jsx"

jobs:
  claude-review:
    # Optional: Filter by PR author
    # if: |
    #   github.event.pull_request.user.login == 'external-contributor' ||
    #   github.event.pull_request.user.login == 'new-developer' ||
    #   github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR'
    
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code Review
        id: claude-review
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}

          # Optional: Specify model (defaults to Claude Sonnet 4, uncomment for Claude Opus 4.1)
          # model: "claude-opus-4-1-20250805"

          # Direct prompt for automated review (no @claude mention needed)
          direct_prompt: |
            Please review this pull request and provide feedback on:
            - Code quality and best practices
            - Potential bugs or issues
            - Performance considerations
            - Security concerns
            - Test coverage
            
            Be constructive and helpful in your feedback.

          # Optional: Use sticky comments to make Claude reuse the same comment on subsequent pushes to the same PR
          # use_sticky_comment: true
          
          # Optional: Customize review based on file types
          # direct_prompt: |
          #   Review this PR focusing on:
          #   - For TypeScript files: Type safety and proper interface usage
          #   - For API endpoints: Security, input validation, and error handling
          #   - For React components: Performance, accessibility, and best practices
          #   - For tests: Coverage, edge cases, and test quality
          
          # Optional: Different prompts for different authors
          # direct_prompt: |
          #   ${{ github.event.pull_request.author_association == 'FIRST_TIME_CONTRIBUTOR' && 
          #   'Welcome! Please review this PR from a first-time contributor. Be encouraging and provide detailed explanations for any suggestions.' ||
          #   'Please provide a thorough code review focusing on our coding standards and best practices.' }}
          
          # Optional: Add specific tools for running tests or linting
          # allowed_tools: "Bash(npm run test),Bash(npm run lint),Bash(npm run typecheck)"
          
          # Optional: Skip review for certain conditions
          # if: |
          #   !contains(github.event.pull_request.title, '[skip-review]') &&
          #   !contains(github.event.pull_request.title, '[WIP]')




================================================
FILE: .github/workflows/claude.yml
================================================
name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

jobs:
  claude:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude')))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
      actions: read # Required for Claude to read CI results on PRs
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code
        id: claude
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}

          # This is an optional setting that allows Claude to read CI results on PRs
          additional_permissions: |
            actions: read
          
          # Optional: Specify model (defaults to Claude Sonnet 4, uncomment for Claude Opus 4.1)
          # model: "claude-opus-4-1-20250805"
          
          # Optional: Customize the trigger phrase (default: @claude)
          # trigger_phrase: "/claude"
          
          # Optional: Trigger when specific user is assigned to an issue
          # assignee_trigger: "claude-bot"
          
          # Optional: Allow Claude to run specific commands
          # allowed_tools: "Bash(npm install),Bash(npm run build),Bash(npm run test:*),Bash(npm run lint:*)"
          
          # Optional: Add custom instructions for Claude to customize its behavior for your project
          # custom_instructions: |
          #   Follow our coding standards
          #   Ensure all new code has tests
          #   Use TypeScript for new files
          
          # Optional: Custom environment variables for Claude
          # claude_env: |
          #   NODE_ENV: test



